## 函数式思想

> 面向对象编程（OO）通过封装变化使得代码更易理解。
>
> 函数式编程（FP）通过最小化变化使得代码更易理解。

函数式编程的目标是使用函数来抽象作用在数据之上的控制流与操作，从而在系统中消除副作用并减少对状态的改变。

不同于我们熟悉的过程式编程，函数式编程是声明式编程。

```ts
const arr = [1, 2, 3, 4, 5, 6];

// 过程式/命令式
const newArr: number[] = [];
for (const i of arr) {
  if (i > 2) newArr.push(i);
}

// 函数式
const findNumberGreatThanTwo = (val: number) => val > 2;
const newArr2 = arr.filter(findNumberGreatThanTwo);

console.log(newArr, newArr2);
```

函数式编程基于一个前提，即使用纯函数构建具有不变性的程序。纯函数的性质：

* 仅取决于提供的输入，而不依赖于任何函数在求值期间获调用间隔时可能变化的隐藏状态和外部状态。
* 不会造成超出其作用域的变化，例如修改全局对象或引用传递的参数。

```ts
let counter = 0;

function increment() {
  return ++counter; // 不纯的函数
}
```

引用透明是定义一个纯函数较为正确的方式。纯度在这个意义上表明一个函数的参数和返回值之间映射的关系。如果一个函数对于相同的输入始终产生相同的结果，那么它就是引用透明的。

```ts
let counter = 0;
function increment() {
  return ++counter;
}

console.log(increment());  // 1
console.log(increment());  // 2

const newCounter = 0;
const plus1 = (counter: number) => {
  return counter + 1;
};

const myCounter1 = plus1(newCounter); // 1
const myCounter2 = plus1(newCounter); // 1

console.log(myCounter1, myCounter2);
```

**不可变数据**是指那些被创建后就不能更改的数据。JavaScript 和其他许多语言意义，它的基本类型（String、Number 等）从本质上来说是不可变的。但是其他对象（引用值）都是可变的。即使函数的参数是按值进行传递的，但是我们任然可以通过改变原有内容的方式产生副作用。

```ts
const person = {
  name: 'xfy',
  age: 18,
};

const changeName = (person: { name: string; age: number }) => {
  person.name = 'dfy';
  person = {
    name: 'aha',
    age: 19,
  };
};

changeName(person);
console.log(person); // name: 'dfy', age: 18
```

根据上述一些基本原则（声明式、纯的和不可变），可以更简洁的描述函数式编程：函数式编程是指创建不可变的程序，通过消除外部可见的副作用，来对函数的声明式的求值过程。