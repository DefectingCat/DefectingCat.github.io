浏览器发展至今，各种主流浏览器都实现了各自的长处，随之而来的就是各种不一致性的问题。

## 能力检测

最常用的一种客户端检测形式就是**能力检测**（特征检测）。能力检测不是去识别特定的浏览器，而是去识别浏览器的能力。只要确定了浏览器支持的特定能力，就可以给出特定的解决方案。检测手段也很简单，只需要用到简单的类型转换：

```js
if (Object.propertyInQuestion) {
    // 使用特定能力
}
```

来看一个简单的例子，在IE5.0之前不支持`document.getElementById()`这个DOM方法，但是可以使用非标准的`document.all`属性来实现相同的目的。所以：

```js
function getElementId(id) {
    if (document.getElementById) {
        return document.getElementById(id);
    } else if (document.all) {
        return document.all(id);
    } else {
        throw new Error('No way to get element id.')
    }
}
```

这里先判断标准方法是否存在，如果存在就直接使用。如果不存在，就使用IE5.0之前的非标准方法。如果二者都没有，则抛出一个错误。

### 更可靠的能力检测

仅仅靠简单的类型转换来检测是不够完善的，不仅仅要知道某个属性是否存在，还需要知道它是不是我们所需要的那个方法。如果仅使用类型转换来做判断，那么可能会遇到这样的问题：

```js
function isSortable(obj) {
    return !!obj.sort;
}

let someObj = {
    sort: 1
}

isSortable(someObj); //true
```

可以考虑善用`typeof`操作符，例如：

```js
function isSortable(obj) {
    return typeof obj.sort == 'function';
}
```

不过`typeof`操作符也不是完美的解决方案，在早期的IE中，某些DOM方法返回的是`object`而不是`function`。例如`document.createElement()`方法。

除此之外，IE的ActiveX对象与其他对象的行为差异很大。例如：

```js
let xhr = new ActiveXObject('Microsoft.XMLHttp');
if (xhr.open) {  //发生错误
    // do something...
}

typeof (xhr.open);  //unknow
```

当然针对IE也是有解决办法的：

```js
//来自 Peter Michaux
function isHostMethod(object, property) {
    let t = object[property];
    return t == 'function' || (!!(t == 'object' && object[property])) || t == 'unknow';
}
```

## 怪癖检测

怪癖检测，也就是Bug检测。通过确定浏览器以有的Bug来确定某一个特性不能正常工作。

在IE8以及之前中有个Bug，将某个实例的属性设置为与标记了`[[Enumerbale]]`为`false`的某个原型属性同名，那么该属性就不会被枚举。可以这样来检测：

```js
(function hasEnumerableQuirk() {
    let obj = {
        toString: function () {}
    }
    for (let i in obj) {
        if (i == 'toString') {
            return false;
        }
    }
    return true;
})();
```

在Safari 3以前的版本中也有一个Bug，实例会枚举被隐藏的同名的原型属性。

```js
(function hasEnumerShadowQuirk() {
    let obj = {
        toString: function () {}
    }
    let count = 0;
    for (i in obj) {
        if (i == 'toString') {
            count++;
        }
    }
    return (count > 1);
})()
```

## 用户代理字符串的历史

这是一段很有趣的浏览器历史。

// maybe later

## 用户代理字符串检测

用户代理字符串也就是常见的UA（UserAgent）。