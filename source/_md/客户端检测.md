浏览器发展至今，各种主流浏览器都实现了各自的长处，随之而来的就是各种不一致性的问题。

## 能力检测

最常用的一种客户端检测形式就是**能力检测**（特征检测）。能力检测不是去识别特定的浏览器，而是去识别浏览器的能力。只要确定了浏览器支持的特定能力，就可以给出特定的解决方案。检测手段也很简单，只需要用到简单的类型转换：

```js
if (Object.propertyInQuestion) {
    // 使用特定能力
}
```

来看一个简单的例子，在IE5.0之前不支持`document.getElementById()`这个DOM方法，但是可以使用非标准的`document.all`属性来实现相同的目的。所以：

```js
function getElementId(id) {
    if (document.getElementById) {
        return document.getElementById(id);
    } else if (document.all) {
        return document.all(id);
    } else {
        throw new Error('No way to get element id.')
    }
}
```

这里先判断标准方法是否存在，如果存在就直接使用。如果不存在，就使用IE5.0之前的非标准方法。如果二者都没有，则抛出一个错误。

### 更可靠的能力检测

仅仅靠简单的类型转换来检测是不够完善的，不仅仅要知道某个属性是否存在，还需要知道它是不是我们所需要的那个方法。如果仅使用类型转换来做判断，那么可能会遇到这样的问题：

```js
function isSortable(obj) {
    return !!obj.sort;
}

let someObj = {
    sort: 1
}

isSortable(someObj); //true
```

可以考虑善用`typeof`操作符，例如：

```js
function isSortable(obj) {
    return typeof obj.sort == 'function';
}
```

不过`typeof`操作符也不是完美的解决方案，在早期的IE中，某些DOM方法返回的是`object`而不是`function`。例如`document.createElement()`方法。

除此之外，IE的ActiveX对象与其他对象的行为差异很大。例如：

```js
let xhr = new ActiveXObject('Microsoft.XMLHttp');
if (xhr.open) {  //发生错误
    // do something...
}

typeof (xhr.open);  //unknow
```

当然针对IE也是有解决办法的：

```js
//来自 Peter Michaux
function isHostMethod(object, property) {
    let t = object[property];
    return t == 'function' || (!!(t == 'object' && object[property])) || t == 'unknow';
}
```

## 怪癖检测

怪癖检测，也就是Bug检测。通过确定浏览器以有的Bug来确定某一个特性不能正常工作。

在IE8以及之前中有个Bug，将某个实例的属性设置为与标记了`[[Enumerbale]]`为`false`的某个原型属性同名，那么该属性就不会被枚举。可以这样来检测：

```js
(function hasEnumerableQuirk() {
    let obj = {
        toString: function () {}
    }
    for (let i in obj) {
        if (i == 'toString') {
            return false;
        }
    }
    return true;
})();
```

在Safari 3以前的版本中也有一个Bug，实例会枚举被隐藏的同名的原型属性。

```js
(function hasEnumerShadowQuirk() {
    let obj = {
        toString: function () {}
    }
    let count = 0;
    for (i in obj) {
        if (i == 'toString') {
            count++;
        }
    }
    return (count > 1);
})()
```

## 用户代理字符串的历史

这是一段很有趣的浏览器历史。

// maybe later

## 用户代理字符串检测

用户代理字符串也就是常见的UA（UserAgent）。考虑到各个主流浏览器的发展历史，所以UA的判断也变的比较复杂。当然对于现代更加复杂的浏览器环境来说，识别出详细的浏览器还是需要更多的检测依据。

### 识别呈现引擎

呈现引擎，也就是浏览器的内核。每个引擎都有一些自己的特性，但是要正确的识别出引擎，关键还是识别顺序。

为了不污染全局变量，这里使用局部变量的命名来命名。这个方法最终返回一个对象，这个对象就是根据检测到的引擎版本的键值对。

```js
let client = function () {
    let engine = {
        // 主流引擎
        trident: 0,
        gecko: 0,
        webkit: 0,
        khtml: 0,
        opera: 0,

        // 具体版本号
        ver: null
    }

    return {
        engine: engine
    }
```

基本的变量命名都准备好了，接下来就是判断了。我们的第一步就是识别opera，因为它的用户代理字符串有可能完全模仿其他浏览器。

判断opera很简单，不需要去检测ua中的字符串，它有个全局变量`window.opera`供我们检测：

```js
    if (window.opera) {
        engine.ver = window.opera.version();
        engine.opera = parseFloat(engine.ver);
    }
```

第二步就是WebKit了，WebKit需要我们通过判断ua字符串内的特定内容来识别它。在客户端获取UA最好的办法就是通过`navigator.userAgent`属性。
                        
```js
let ua = navigator.userAgent;
let webkit = /AppleWebKit\/(\S+)/;

if (webkit.test(ua)) {
    engine.ver = ua.match(webkit)[1];
    engine.webkit = parseFloat(engine.ver);
}
```

KHTML 的用户代理字符串中也包含 Gecko，因此在排除 KHTML 之前，无法准确检测基于 Gecko 的浏览器。

```js
let khtml = /KHTML\/(\S+)/;
let khtml1 = /Konqueror\/([^;]+)/;

if (khtml.test(ua) || khtml1.test(ua)) {
    engine.ver = ua.match(khtml)[1];
    engine.khtml = parseFloat(engine.ver);
}
```