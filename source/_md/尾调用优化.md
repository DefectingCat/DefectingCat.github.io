ECMAScript 规范新增了一项内存管理优化机制，让 JavaScript 引擎再满足条件时可以重用函数栈帧。这项优化非常适合使用“尾调用”，即外部函数的返回值时一个内部函数的返回值。

```js
function outerFunc() {
  return innerFunc(); // 尾调用
}
```

这和递归有点类似，区别就是通常的递归都是递归函数本身，而尾调用再递归其他外部函数时才会触发优化。

上述和递归类似的尾调用函数在 ES6 优化之前的调用栈类似于这样：

1. 执行到`outerFunc`，第一个栈帧被推到栈上；
2. 执行`outerFunc`函数体，直到 return 语句。计算返回值必须先计算`innerFunc`；
3. 执行到`innerFunc`，第二个栈帧被推到栈上；
4. 执行`innerFunc`函数体，计算返回值；
5. 如果`innerFunc`内部返回值还是递归，则按照同样的方式推入到栈中；
6. 待到栈内最后一个函数返回完后，返回值会随着栈一层一层的往回返回；
7. 直到返回到`outerFunc`函数，然后`outerFunc`再返回值；
8. 将栈帧弹出栈外。

## 调用栈

在考虑尾调用优化之前，先来看下调用栈。调用栈是解释器追踪函数执行流的一种机制。当执行环境中调用了多个[函数](https://developer.mozilla.org/zh-CN/docs/Glossary/Function)时，通过这种机制，我们能够追踪到哪个函数正在执行，执行的函数体中又调用了哪个函数。

来自[Call stack（调用栈） - 术语表 | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Glossary/Call_stack)的描述：

- 每调用一个函数，解释器就会把该函数添加进调用栈并开始执行。
- 正在调用栈中执行的函数还调用了其它函数，那么新函数也将会被添加进调用栈，一旦这个函数被调用，便会立即执行。
- 当前函数执行完毕后，解释器将其清出调用栈，继续执行当前执行环境下的剩余的代码。
- 当分配的调用栈空间被占满时，会引发“堆栈溢出”错误。

上述对递归调用栈简单的描述也是同理，这也说明了为什么使用递归来计算斐波那契数列过大时会发生“堆栈溢出”的错误。

### 递归

这种传统使用递归来计算斐波那契数列的方法非常常见，因为调用栈，它有个致命的缺点，太慢。

```js
function fibonacci(n) {
  if (n < 2) {
    return n;
  }
  return fibonacci(n - 1) + fibonacci(n - 2);
}

console.time('a');
console.log('Calculate first 40 fibonacci numbers: ', fibonacci(40));
console.timeEnd('a');
```

因为它每次返回值时都需要等待栈内递归的函数体计算完毕，然后一层一层直到返回给最外层的函数，最终返回出结果。

这种一层一层的顺着栈返回的计算方式不仅难以理解，而且有时还会有不必要的栈调用。

### 不必要的递归

先来看一个简单的例子，先不考虑这段函数的意义以及问题，它的存在是为了帮助我们理解不必要的递归：

```js
function testN(n) {
  if (n === 0) return n;
  return testN(--n);
}
```

这段递归非常简单，当参数 n 为 0 时，返回它；如果不为 0 则调用函数自身递减。这是一段普通的递归函数，因此它也按照上述的调用栈来递归。

假设 n 为 1：

1. 执行到`testN`函数，第一个栈帧被推到栈上；
2. 执行`testN`函数体，直到 return 语句。计算返回值必须先计算`testN(n - 1)`；
3. 执行`testN(n - 1)`，这时第二个栈帧被推到栈上；
4. 执行`testN(n - 1)`函数体，通过判断，直接返回 n；
5. 由于递归的栈调用，`testN(n - 1)`返回的值会被返回到外层`testN`，这时的`testN(n - 1)`才被弹出栈；
6. `testN`等到了递归的返回值后，将其返回出去；
7. 将栈帧弹出栈外。

这段递归只递归了一次，但已经很容易看出这样工作的问题所在了。那就是在执行到第四步的时候，函数所返回的 n 就已经是我们需要的结果了。但是它还是需要顺着调用栈一直返回到最外层，然后由它返回出去。于上述斐波那契不同的是，在返回的期间，n 的值没有经过任何计算，也就是说，这段路程根本没有必要。

## 尾调用优化

了解了递归的调用栈运作方式后，就可以来一探 ES6 的尾调用优化的究竟了。

```js
function fibonacci(n, a = 1, b = 1) {
  if (n === 0) {
    return a;
  }
  return fibonacci(--n, b, a + b);
}
console.time('a');
console.log('Calculate first 40 fibonacci numbers: ', fibonacci(100));
console.timeEnd('a');
```

