<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Vue3中的响应数据</title>
    <link href="/defect/response-data-in-Vue3.html"/>
    <url>/defect/response-data-in-Vue3.html</url>
    
    <content type="html"><![CDATA[<h2 id="实时渲染"><a href="#实时渲染" class="headerlink" title="实时渲染"></a>实时渲染</h2><p>在学习Vue2.x的过程中，做过一个更改数据从而触发实时渲染DOM的小实例。期间很顺利，而后在同样方法测试Vue3的时候发现遇到了一些不同的行为。根据查阅了一些文档以及源码，做出了一些推测。</p><h2 id="数据与方法"><a href="#数据与方法" class="headerlink" title="数据与方法"></a>数据与方法</h2><p>当一个 Vue 实例被创建时，它将 data 对象中的所有的 property 加入到 Vue 的响应式系统中。当这些 property 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。</p><p>在Vue2.x中，可以创建一个数据对象，为实例提供数据。虽然这样的写法和直接在实例中为<code>data</code>添加属性没有多少差别：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>        &#123;&#123; message &#125;&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    <span class="hljs-keyword">let</span> data = &#123;</span><span class="javascript">        message: <span class="hljs-string">&#x27;Hello World!&#x27;</span></span>    &#125;<span class="javascript">    <span class="hljs-keyword">let</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="javascript">        el: <span class="hljs-string">&#x27;#app&#x27;</span>,</span>        data: data    &#125;);<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>这时我们单独创建的<code>data</code>对象与实例中的<code>data</code>成立了引用关系：</p><pre><code class="hljs js">app.$data.message === data.message<span class="hljs-comment">// true</span></code></pre><p>并且他们三者是互等的：</p><pre><code class="hljs js">app.message === app.$data.messageapp.$data.message === data.message</code></pre><p>并且我们单独创建的<code>data</code>对象也被转换成了检测数据变化的Observer对象</p><p><img src="../images/Vue3%E4%B8%AD%E7%9A%84%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE/2020-10-20-14-23-58.webp"></p><p>因此，我们在修改<code>data</code>对象的内容时，app实例的属性也会被改变，从而实时渲染到DOM上。</p><p><img src="../images/Vue3%E4%B8%AD%E7%9A%84%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE/2020-10-20-14-25-25.webp"></p><p>但在Vue3上发生了一些小小的改变。在Vue3上，我们将实例的<code>data</code>函数直接return为我们在父作用域中创建的对象，这个对象不会被修改为检测属性数据变化的对象。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>        &#123;&#123; message &#125;&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    <span class="hljs-keyword">let</span> data = &#123;</span><span class="javascript">        message: <span class="hljs-string">&#x27;Hello World!&#x27;</span></span>    &#125;;<span class="javascript">    <span class="hljs-keyword">let</span> app = Vue.createApp(&#123;</span><span class="javascript">        <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><span class="javascript">            <span class="hljs-keyword">return</span> data;</span>        &#125;    &#125;);<span class="javascript">    <span class="hljs-keyword">let</span> vm = app.mount(<span class="hljs-string">&#x27;#app&#x27;</span>);</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>这里的app是我们创建的实例，但最终挂载DOM后返回的实例为vm。不同于2.x的地方是，这里我们在父作用域中创建的对象并没用任何的变化，它还是一个普通的对象。</p><p><img src="../images/Vue3%E4%B8%AD%E7%9A%84%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE/2020-10-20-14-31-01.webp"></p><p>并且，他们也互相建立了引用的关系；</p><pre><code class="hljs js">vm.message === data.message<span class="hljs-comment">// true</span></code></pre><p>虽然他们已经是互相引用，但是<code>data</code>还是一个普通的对象。这里就会发现一个有意思的现象，只更新<code>data.message</code>的值，<code>vm.message</code>或者说<code>vm.$data.message</code>的值会同样更新，保持和<code>data</code>对象一样。但是DOM却没用被实时渲染。</p><p><img src="../images/Vue3%E4%B8%AD%E7%9A%84%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE/2020-10-20-15-42-32.webp"></p><p>这一点2和3有着很大的差距，在vue2中，我们是可以通过<code>data</code>对象来实时更新DOM的。而在3中就不行了。</p><p>据我的猜测，主要是Vue3没有对父作用域的<code>data</code>对象设置Proxy代理的原因。虽然二者已经是互相引用，修改一个对象值，另一个对象也会被修改。<strong>但是通过修改<code>data</code>的属性，并不会触发<code>vm.$data</code>对象的<code>set()</code>方法。</strong></p><h2 id="模仿行为"><a href="#模仿行为" class="headerlink" title="模仿行为"></a>模仿行为</h2><p>我使用了一个小例子，模仿了一下Vue3的行为：</p><pre><code class="hljs js"><span class="hljs-comment">// 这是在父作用域中的data对象，它是一个普通对象</span><span class="hljs-keyword">let</span> data = &#123;    message: <span class="hljs-string">&#x27;xfy&#x27;</span>&#125;<span class="hljs-comment">// 这是模拟set方法，成功set时会打印一条信息</span><span class="hljs-keyword">let</span> handler = &#123;    set: <span class="hljs-function">(<span class="hljs-params">obj, prop, value</span>) =&gt;</span> &#123;        obj[prop] = value;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;set success: &#x27;</span> + value);    &#125;&#125;<span class="hljs-comment">// 通过proxy创建一个继承自data属性的实例</span><span class="hljs-keyword">let</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(data, handler);</code></pre><p>这是一个很简单的例子，我们为<code>vm</code>对象设置了一个来自<code>data</code>对象的代理。现在二者就是互相引用的关系了，就和Vue3一样。</p><pre><code class="hljs js">data.message === vm.message<span class="hljs-comment">// true</span></code></pre><p>我在代理的拦截中配置了一个setter，当<code>vm</code>对象成功设置了值后，就会触发这个setter，并在控制台打印一则信息。用来模拟更新DOM。也就是说，现在的<code>vm</code>实例就相当于Vue实例，当我更新其属性时，会在控制台动态的打印信息，就相当于实时更新了DOM。就和Vue实例一样。</p><p>现在我们直接对<code>vm.message</code>赋值，则会成功触发预先设置的setter函数，成功的更新了值并且在控制打印了消息。</p><pre><code class="hljs js">vm.message<span class="hljs-comment">// &quot;xfy&quot;</span>vm.message = <span class="hljs-string">&#x27;hello xfy&#x27;</span>;<span class="hljs-comment">// set success: hello xfy</span><span class="hljs-comment">// &quot;hello xfy&quot;</span></code></pre><p>并且<code>data</code>对象也同样的被修改了。</p><pre><code class="hljs js">data.message<span class="hljs-comment">// &quot;hello xfy&quot;</span></code></pre><p>直接设置<code>data.message</code>可以成功修改<code>vm.message</code>的值，但是却不会触发<code>vm</code>对象的setter方法。</p><pre><code class="hljs js">data.message = <span class="hljs-string">&#x27;嘤嘤嘤&#x27;</span>;<span class="hljs-comment">// &quot;嘤嘤嘤&quot;</span>vm.message<span class="hljs-comment">// 属性被修改，但是没有触发setter</span><span class="hljs-comment">// &quot;嘤嘤嘤&quot;</span></code></pre><p>这里的小例子最简化的模拟了Vue3的实例行为，在真正的Vue3的实例上，我们也可以很清晰的看到其Proxy属性</p><p><img src="../images/Vue3%E4%B8%AD%E7%9A%84%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE/2020-10-20-16-28-03.webp"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说就是因为data对象修改时不会触发实例的set方法，但数据依然会改变，只是DOM不会实时更新。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript-可迭代对象与for-of</title>
    <link href="/defect/javascript-iterable-object-and-for-of.html"/>
    <url>/defect/javascript-iterable-object-and-for-of.html</url>
    
    <content type="html"><![CDATA[<h2 id="Iterable-object（可迭代对象）"><a href="#Iterable-object（可迭代对象）" class="headerlink" title="Iterable object（可迭代对象）"></a>Iterable object（可迭代对象）</h2><p>可迭代（Iterable） 对象是数组的泛化。这个概念是说任何对象都可以被定制为可在<code>for...of</code>循环中使用的对象。数组是可迭代的。但不仅仅是数组，很多其他的内建对象也是可迭代的。例如字符串就是可迭代的。</p><h2 id="总最早开始"><a href="#总最早开始" class="headerlink" title="总最早开始"></a>总最早开始</h2><p>可能十年前或者更加久远的年代，我们遍历一个数组需要这样：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;    <span class="hljs-built_in">console</span>.log(arr[i]);&#125;</code></pre><p>或许也不是很久，在我最初学习js的时候就是这样去尝试理解for循环的。</p><p>后来我们发现这样写或许太复杂了，于是有了<code>for...in</code>。我们遍历一个数组就变成了这样：</p><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> arr) &#123;    <span class="hljs-built_in">console</span>.log(arr[i]);&#125;</code></pre><p>是不是和for循环有点类似，<code>for...in</code>便是循环遍历对象的一个方式。</p><p>ES6也给了我们一个专门操作遍历数组的方法：<code>forEach()</code></p><pre><code class="hljs js">arr.forEach(<span class="hljs-function"><span class="hljs-params">element</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(element);&#125;);</code></pre><p>与其他的方法不同的是，<code>forEach()</code>同数组的<code>push()</code>、<code>pop()</code>等方法一样，是在Array对象的原型上的，也就是<code>Array.prototype.forEach()</code>。并且它除了抛出异常以外，没有办法中止或跳出<code>forEach()</code>循环。如果我们需要中止或跳出循环<code>forEach()</code>方法不是应当使用的工具。</p><h3 id="弥补不足"><a href="#弥补不足" class="headerlink" title="弥补不足"></a>弥补不足</h3><p>我们有多种可以轻松遍历数组的方法，不过他们各有各的不足之处。<code>for...of</code>便是代替<code>for...in</code>来循环数组而诞生的。</p><p>首先来看看<code>for...in</code>对数组的小问题：</p><ol><li><code>for...in</code>是为对象设计的，它遍历的是key，而不是value。</li><li><code>for...in</code>会一直查找可枚举的属性，直至原型链顶端。</li></ol><p>先看第一条，<code>for...in</code>和直接for循环遍历数组类似，他们循环的是数组的key，需要使用数组的标准访问写法才能得到值。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> arr) &#123;    <span class="hljs-built_in">console</span>.log(arr[i]);    <span class="hljs-comment">// 1, 2, 3, ,4, 5</span>&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> arr) &#123;    <span class="hljs-built_in">console</span>.log(i);    <span class="hljs-comment">// 0, 1, 2, 3, ,4</span>&#125;</code></pre><p>不过这看上去无伤大雅，第二条的问题就不像这么温柔了。在当前数组的原型链上的所有的可枚举的属性都会被遍历出来。</p><pre><code class="hljs js"><span class="hljs-built_in">Array</span>.prototype.arrTest = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;<span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">Array</span>.prototype, <span class="hljs-string">&#x27;push&#x27;</span>, &#123;    enumerable: <span class="hljs-literal">true</span>&#125;)<span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> arr) &#123;    <span class="hljs-built_in">console</span>.log(arr[i]);&#125;</code></pre><p>无论是我们自定义的函数，还是修改属性为可枚举，<code>for...in</code>一条都不会放过。</p><p><img src="../images/JavaScript-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E4%B8%8Efor-of/2020-10-27-15-01-39.webp"></p><h2 id="迭代协议"><a href="#迭代协议" class="headerlink" title="迭代协议"></a>迭代协议</h2><p>通常的对象是不可迭代的，它不是数组。通过自己创建一个不可迭代的对象，我们就可以轻松地掌握可迭代的概念。</p><p>首先来看一个最基本的对象，我们尝试使用<code>for...of</code>去遍历它，会得到一个其不是可迭代对象的是错误：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;    start: <span class="hljs-number">1</span>,    end: <span class="hljs-number">5</span>&#125;;<span class="hljs-keyword">for</span> (num <span class="hljs-keyword">of</span> obj) &#123;    <span class="hljs-built_in">console</span>.log(num);&#125;</code></pre><pre><code class="hljs angelscript">VM155:<span class="hljs-number">6</span> Uncaught TypeError: obj <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> iterable</code></pre><p>这是因为我们的Object对象不是可迭代的对象。而迭代协议可以使其成为一个可迭代的对象。</p><p>迭代协议作为 ECMAScript 2015 的一组补充规范，迭代协议并不是新的内置实现或语法，而是协议。这些协议可以被任何遵循某些约定的对象来实现。</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>为了让<code>obj</code>对象可迭代（也就让<code>for..of</code>可以运行）我们需要为对象添加一个名为<code>Symbol.iterator</code>的方法（一个专门用于使对象可迭代的内置symbol）。</p><ol><li>当 <code>for..of</code> 循环启动时，它会调用这个方法（如果没找到，就会报错）。这个方法必须返回一个 <strong>迭代器（iterator）</strong> —— 一个有 <code>next</code> 方法的对象。</li><li>从此开始，<code>for..of</code> <strong>仅适用于这个被返回的对象</strong>。</li><li>当 <code>for..of</code> 循环希望取得下一个数值，它就调用这个对象的 <code>next()</code> 方法。</li><li><code>next()</code> 方法返回的结果的格式必须是 <code>&#123;done: Boolean, value: any&#125;</code>，当 <code>done=true</code> 时，表示迭代结束，否则 <code>value</code> 是下一个值。</li></ol><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;    start: <span class="hljs-number">1</span>,    end: <span class="hljs-number">5</span>&#125;;<span class="hljs-comment">// for..of 调用首先会调用这个：</span>obj[<span class="hljs-built_in">Symbol</span>.iterator] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> &#123;           <span class="hljs-comment">// 这个function还是属于obj，所以this指向obj。</span>        <span class="hljs-comment">//接下来，for..of 仅与此迭代器一起工作，要求它提供下一个值</span>        current: <span class="hljs-built_in">this</span>.start,        last: <span class="hljs-built_in">this</span>.end,        <span class="hljs-comment">// next() 在 for..of 的每一轮循环迭代中被调用</span>        <span class="hljs-comment">// 所以通常next都带有一个判断语句</span>        <span class="hljs-function"><span class="hljs-title">next</span>(<span class="hljs-params"></span>)</span> &#123;            <span class="hljs-comment">// Symbol.iterator返回的是一个对象，this不会多级指向，所以这里用到了刚刚定义的属性</span>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.current &lt;= <span class="hljs-built_in">this</span>.last) &#123;                <span class="hljs-keyword">return</span> &#123;                    value: <span class="hljs-built_in">this</span>.current++,                    done: <span class="hljs-literal">false</span>                &#125;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">return</span> &#123;                    done: <span class="hljs-literal">true</span>                &#125;            &#125;        &#125;           &#125;&#125;;<span class="hljs-comment">// 可以迭代啦</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> obj) &#123;    <span class="hljs-built_in">console</span>.log(num);&#125;;</code></pre><p>第一次见到迭代器的时候感觉它还是挺复杂的，但仔细研究过后就会发现，其实它大部分还都是固定搭配的。不过这里的this还是比较容易浑人的。</p><p>仔细观察下其核心的功能，发现迭代器是通过一个名为<code>Symbol.iterator</code>的方法返回的对象中的：</p><ol><li><code>obj</code> 自身没有 <code>next()</code> 方法。</li><li>相反，是通过调用 <code>obj[Symbol.iterator]()</code> 创建了另一个对象，即所谓的“迭代器”对象，并且它的 <code>next</code> 会为迭代生成值</li></ol><p>那么，既然都是对象，所以迭代器应该是可以放在<code>obj</code>自身的。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;    start: <span class="hljs-number">1</span>,    end: <span class="hljs-number">5</span>,    <span class="hljs-comment">// Symbol.iterator负责返回一个对象，其对象中包含next方法，这里直接返回this，在obj中定义一个next方法</span>    <span class="hljs-comment">// this.count用于计数</span>    [<span class="hljs-built_in">Symbol</span>.iterator]() &#123;        <span class="hljs-built_in">this</span>.count = <span class="hljs-built_in">this</span>.start;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;    &#125;,    <span class="hljs-function"><span class="hljs-title">next</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.count &lt;= <span class="hljs-built_in">this</span>.end) &#123;            <span class="hljs-keyword">return</span> &#123;                value: <span class="hljs-built_in">this</span>.count++,                done: <span class="hljs-literal">false</span>            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> &#123;                done: <span class="hljs-literal">true</span>            &#125;        &#125;    &#125;&#125;;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> num <span class="hljs-keyword">of</span> obj) &#123;    <span class="hljs-built_in">console</span>.log(num);&#125;;</code></pre><p>这里的<code>[Symbol.iterator]()</code>定义为<code>obj</code>的一个属性，同时<code>[Symbol.iterator]()</code>需要返回一个带有<code>next()</code>方法的对象。所以直接将<code>next()</code>方法定义在<code>obj</code>身上，<code>[Symbol.iterator]()</code>通过返回this来返回这个对象。</p><p>这样的写法会比在外部定义<code>[Symbol.iterator]()</code>方法更加简洁，this指向也更加清晰。但是在<code>[Symbol.iterator]()</code>方法中定义的属性会被添加到<code>obj</code>上。</p><pre><code class="hljs js">obj.count <span class="hljs-comment">// 6</span></code></pre><p>并且迭代器只用一个，现在不能在该对象上同时运行多个<code>for...of</code>循环了，它们将共享迭代状态，因为只有一个迭代器，即对象本身。但是两个并行的 for..of 是很罕见的，即使在异步情况下。</p><blockquote><p>无穷迭代器<br>无穷迭代器也是可能的。例如，将<code>obj</code>设置为<code>obj.to = Infinity</code>，这时<code>obj</code>则成为了无穷迭代器。或者我们可以创建一个可迭代对象，它生成一个无穷伪随机数序列。也是可能的。<br><code>next</code>没有什么限制，它可以返回越来越多的值，这是正常的。<br>当然，迭代这种对象的<code>for..of</code>循环将不会停止。但是我们可以通过使用<code>break</code>来停止它。</p></blockquote><h3 id="展开语法"><a href="#展开语法" class="headerlink" title="展开语法"></a>展开语法</h3><p>展开语法(Spread syntax), 可以在函数调用/数组构造时, 将数组表达式或者string在语法层面展开；还可以在构造字面量对象时, 将对象表达式按key-value的方式展开。</p><p>字面量也就是常见的<code>[1, 2, 3]</code>或者<code>&#123;name: &quot;mdn&quot;&#125;</code>这种简洁的构造方式。</p><p>展开语法与<code>for...of</code>及其相似，无法迭代的对象也无法使用展开语法。错误信息也是一样：</p><p><img src="../images/JavaScript-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E4%B8%8Efor-of/2020-10-29-10-17-49.webp"></p><p>展开语法不仅仅只是和<code>for...of</code>行为比较像，它还有更多的用法。不过在此赘述也是没有多少意义了。</p><h2 id="可迭代的字符串"><a href="#可迭代的字符串" class="headerlink" title="可迭代的字符串"></a>可迭代的字符串</h2><p>在我最早学习js的基本类型的时候，就被告知字符串可以被循环处理。类似于这样：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;xfy&#x27;</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; str.length; i++) &#123;    <span class="hljs-built_in">console</span>.log(str[i]);&#125;<span class="hljs-comment">// x, f, y;</span></code></pre><p>虽然无法理解是什么一回事，但当时就感觉字符串和数组很相似，非常神奇。</p><p>根据包装对象的原理，很容易就联想到字符串可迭代是因为其构造函数<code>String</code>可迭代（当然也有length属性）。要验证这非常简单，只需要找下<code>String</code>上有没有迭代器必备的<code>[Symbol.iterator]()</code>方法就可以了。</p><p>虽然包装对象的过程我们无法看到，但是我们可以对一个字符串的原型链向上寻找就ok了。直接调用其原型链上的方法便会触发包装对象，就像调用<code>toString()</code>一样，</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;xfy&#x27;</span>;str.__proto__[<span class="hljs-built_in">Symbol</span>.iterator];</code></pre><p>直接访问原型链上的<code>[Symbol.iterator]()</code>方法，就会发现有这个方法存在，正是有它的存在，字符串才是可迭代的。</p><h3 id="显式调用迭代器"><a href="#显式调用迭代器" class="headerlink" title="显式调用迭代器"></a>显式调用迭代器</h3><p>为了能够更加深入的了解迭代器的工作，我们可以不使用<code>for...of</code>，反而使用显式的去操作迭代器：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;xfy&#x27;</span>;<span class="hljs-comment">// 接收迭代器</span><span class="hljs-keyword">let</span> iterator = str[<span class="hljs-built_in">Symbol</span>.iterator]();<span class="hljs-keyword">let</span> res;<span class="hljs-function"><span class="hljs-title">while</span>(<span class="hljs-params"><span class="hljs-literal">true</span></span>)</span> &#123;    res = iterator.next();    <span class="hljs-keyword">if</span> (res.done) <span class="hljs-keyword">break</span>;    <span class="hljs-built_in">console</span>.log(res.value);&#125;</code></pre><p>只要弄弄清楚了迭代器的工作方式，就能很轻松的理解显式调用。最终我们根据<code>next()</code>方法返回的固定格式的值来判断什么适合需要跳出循环以及取值。</p><p>正常情况下我们不需要显式的去迭代一个对象，但是这样做比<code>for...of</code>给了我们更多的控制权。我们可以拆分迭代的步骤，并在中途做一些其他的事情。</p><h2 id="可迭代与类数组"><a href="#可迭代与类数组" class="headerlink" title="可迭代与类数组"></a>可迭代与类数组</h2><p>可迭代对象与类数组很相似，但他们是两种不同的对象，有着不同的正式术语：</p><ul><li><strong>Iterable</strong> 如上所述，是实现了 <code>Symbol.iterator</code> 方法的对象。</li><li><strong>Array-like</strong> 是有索引和 <code>length</code> 属性的对象，所以它们看起来很像数组。</li></ul><p>当然也有两种特性都有的对象，例如字符串就是可迭代同时也是类数组（有数值索引和 <code>length</code> 属性）。</p><p>当光是类数组的对象是无法迭代的</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;    <span class="hljs-number">0</span>: <span class="hljs-string">&#x27;x&#x27;</span>,    <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;f&#x27;</span>,    <span class="hljs-number">2</span>: <span class="hljs-string">&#x27;y&#x27;</span>,    length: <span class="hljs-number">3</span>&#125;<span class="hljs-comment">// Uncaught TypeError: object is not iterable</span>[...obj];</code></pre><p>可迭代对象和类数组对象通常都<strong>不是数组</strong>，他们也没有数组的一些方法。不过出了字符串以外，我们手动创建的类数组可以使用<code>call</code>来改变数组方法的指向，从而使其能够使用一些数组的方法：</p><pre><code class="hljs js"><span class="hljs-built_in">Array</span>.prototype.push.call(obj, <span class="hljs-number">1</span>);obj[<span class="hljs-number">3</span>];<span class="hljs-comment">// 1</span></code></pre><p>而包装后的字符串其<code>length</code>属性是只读的，所以我们无法通过数组的方法去操作它：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;xfy&#x27;</span>;<span class="hljs-comment">// Uncaught TypeError: Cannot assign to read only</span><span class="hljs-built_in">Array</span>.prototype.push.call(str, <span class="hljs-number">1</span>);</code></pre><h3 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from"></a>Array.from</h3><p><code>Array.from</code>可以从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。通过创建一个浅拷贝的数组，就可以对其使用数组的方法了。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;    <span class="hljs-number">0</span>: <span class="hljs-string">&#x27;x&#x27;</span>,    <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;f&#x27;</span>,    <span class="hljs-number">2</span>: <span class="hljs-string">&#x27;y&#x27;</span>,    length: <span class="hljs-number">3</span>&#125;;<span class="hljs-keyword">let</span> arr = <span class="hljs-built_in">Array</span>.from(obj);arr.push(<span class="hljs-string">&#x27;嘤嘤嘤&#x27;</span>);</code></pre><p>Array.from 方法接受对象，检查它是一个可迭代对象或类数组对象，然后创建一个新数组，并将该对象的所有元素浅拷贝到这个新数组。可迭代的对象也是同理。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;    <span class="hljs-number">0</span>: <span class="hljs-string">&#x27;x&#x27;</span>,    <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;f&#x27;</span>,    [<span class="hljs-built_in">Symbol</span>.iterator]() &#123;        <span class="hljs-built_in">this</span>.sw = <span class="hljs-literal">true</span>;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;    &#125;,    <span class="hljs-function"><span class="hljs-title">next</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.sw) &#123;            <span class="hljs-built_in">this</span>.sw = <span class="hljs-literal">false</span>;            <span class="hljs-keyword">return</span> &#123;                value: <span class="hljs-built_in">Object</span>.keys(<span class="hljs-built_in">this</span>),                done: <span class="hljs-literal">false</span>            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> &#123;                done: <span class="hljs-literal">true</span>            &#125;        &#125;    &#125;&#125;<span class="hljs-keyword">let</span> arr = <span class="hljs-built_in">Array</span>.from(obj);</code></pre><p><code>Array.from</code>还有一个可选的参数，提供了类似于<code>forEach</code>的参数选项。</p><pre><code class="hljs js"><span class="hljs-built_in">Array</span>.from(obj[, mapFn, thisArg])</code></pre><p>可选的第二个参数 <code>mapFn</code> 可以是一个函数，该函数会在对象中的元素被添加到数组前，被应用于每个元素，此外 <code>thisArg</code> 允许我们为该函数设置 <code>this</code>。</p><pre><code class="hljs js"><span class="hljs-built_in">Array</span>.from([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x + x);<span class="hljs-comment">// [2, 4, 6]</span></code></pre><h3 id="可用于代理对"><a href="#可用于代理对" class="headerlink" title="可用于代理对"></a>可用于代理对</h3><p>对于代理对（surrogate pairs）（ UTF-16 的扩展字符），<code>Array.from</code>也可以正常识别并拷贝为数组。对于普通的字符串，虽然能够使用<code>slice()</code>方法，但是对于代理对的操作会导致乱码，两个不同 UTF-16 扩展字符碎片拼接的结果。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;𝒳😂𩷶&#x27;</span>;<span class="hljs-built_in">console</span>.log(str);<span class="hljs-comment">// &quot;𝒳😂𩷶&quot;</span>str.slice(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)<span class="hljs-comment">// &quot;��&quot;</span></code></pre><p>我们可以利用<code>Array.from</code>对代理对的正确操作特性来重写创建代理感知（surrogate-aware）的<code>slice</code>方法。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;𝒳😂𩷶&#x27;</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">aSlice</span>(<span class="hljs-params">arr, star, end</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>.from(arr).slice(star, end).join(<span class="hljs-string">&#x27;&#x27;</span>);&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以应用 <code>for..of</code> 的对象被称为 <strong>可迭代的</strong>。</p><ul><li>技术上来说，可迭代对象必须实现 <code>Symbol.iterator</code>方法。<ul><li><code>obj[Symbol.iterator]</code> 的结果被称为 <strong>迭代器（iterator）</strong>。由它处理进一步的迭代过程。</li><li>一个迭代器必须有 <code>next()</code> 方法，它返回一个 <code>&#123;done: Boolean, value: any&#125;</code> 对象，这里 <code>done:true</code> 表明迭代结束，否则 <code>value</code> 就是下一个值。</li></ul></li><li><code>Symbol.iterator</code> 方法会被 <code>for..of</code> 自动调用，但我们也可以直接调用它。</li><li>展开语法的操作结果与<code>for..of</code>类似。</li><li>内置的可迭代对象例如字符串和数组，都实现了 <code>Symbol.iterator</code>。</li><li>字符串迭代器能够识别代理对（surrogate pair）。</li></ul><p>有索引属性和 <code>length</code> 属性的对象被称为 <strong>类数组对象</strong>。这种对象可能还具有其他属性和方法，但是没有数组的内建方法。</p><h2 id="参考-amp-推荐"><a href="#参考-amp-推荐" class="headerlink" title="参考&amp;推荐"></a>参考&amp;推荐</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols">迭代协议</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Iterators_and_Generators">迭代器和生成器</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/yield*">yield*</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax">展开语法</a></li><li><a href="https://zh.javascript.info/iterable">Iterable object（可迭代对象）</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue.js-起步!</title>
    <link href="/defect/Vue-js-get-started.html"/>
    <url>/defect/Vue-js-get-started.html</url>
    
    <content type="html"><![CDATA[<p>在我打算学习vue的时候，正是其3.0版本发布不久的时候。很庆幸生活在这个时代，但困扰我的是是否应该由旧版本的2.x开始学习？一向选择困难的我最终打算两个版本一起学习，从2.x开始入门，顺便还能一睹其与3.0版本的变化。</p><h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><p>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>从最基础的开始，可以在单html文件中引入vue。</p><pre><code class="hljs js">&lt;script src=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;&lt;/script&gt;</code></pre><h3 id="声明式渲染"><a href="#声明式渲染" class="headerlink" title="声明式渲染"></a>声明式渲染</h3><p>Vue的核心是采用简介的模板语法来声明式地将数据渲染进DOM系统：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>    &#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><pre><code class="hljs js"><span class="hljs-keyword">let</span> app = <span class="hljs-keyword">new</span> Vue(&#123;    el: <span class="hljs-string">&#x27;.app&#x27;</span>,    data: &#123;        message: <span class="hljs-string">&#x27;Hello world!&#x27;</span>    &#125;&#125;)</code></pre><p>不得不说Vue的教程确实简单易懂，也可能是因为Vue本身的语法简洁，第一次看到教程里的这个实例时，大部分都是能够理解的。目前为止，已经成功的创建了第一个Vue应用。</p><p>现在数据和DOM已经被建立的关联，所有的东西都是响应式的，刚刚新建的<code>app</code>实例拥有一个<code>app.message</code>的值，在console中修改就能实时的看到相应的属性更新。</p><p>目前就不再和HTML直接进行交互了，一个Vue应用会将其挂在到一个DOM元素上：<code>el: &#39;.app&#39;</code>，然后对其进行完全控制。那个 HTML 是我们的入口，但其余都会发生在新创建的 Vue 实例内部。</p><p>除此之外，Vue还能直接对DOM元素attribute进行绑定</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">v-bind:src</span>=<span class="hljs-string">&#x27;src&#x27;</span> <span class="hljs-attr">v-bind:alt</span>=<span class="hljs-string">&#x27;alt&#x27;</span> <span class="hljs-attr">v-bind:title</span>=<span class="hljs-string">&#x27;message&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    <span class="hljs-keyword">let</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="javascript">        el: <span class="hljs-string">&#x27;.app&#x27;</span>,</span>        data: &#123;<span class="javascript">            src: <span class="hljs-string">&#x27;https://cdn.defectink.com/images/file_4963947.png&#x27;</span>,</span><span class="javascript">            alt: <span class="hljs-string">&#x27;ヽ(✿ﾟ▽ﾟ)ノ&#x27;</span>,</span><span class="javascript">            message: <span class="hljs-string">&#x27;ヽ(✿ﾟ▽ﾟ)ノ&#x27;</span></span>        &#125;    &#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>这样的操作方法被称之为<strong>指令</strong>。指令带有<code>v-</code>前缀，以表示他们是Vue提供的特殊attribute。它们会在渲染的 DOM 上应用特殊的响应式行为。</p><h3 id="条件与循环"><a href="#条件与循环" class="headerlink" title="条件与循环"></a>条件与循环</h3><p>Vue提供了一个类似于条件语句的指令，切换一个元素的显示也非常的简单，使用<code>v-if</code>语句。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&#x27;seen&#x27;</span> <span class="hljs-attr">v-bind:src</span>=<span class="hljs-string">&#x27;src&#x27;</span> <span class="hljs-attr">v-bind:alt</span>=<span class="hljs-string">&#x27;alt&#x27;</span> <span class="hljs-attr">v-bind:title</span>=<span class="hljs-string">&#x27;message&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    <span class="hljs-keyword">let</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="javascript">        el: <span class="hljs-string">&#x27;.app&#x27;</span>,</span>        data: &#123;<span class="javascript">            src: <span class="hljs-string">&#x27;https://cdn.defectink.com/images/file_4963947.png&#x27;</span>,</span><span class="javascript">            alt: <span class="hljs-string">&#x27;ヽ(✿ﾟ▽ﾟ)ノ&#x27;</span>,</span><span class="javascript">            message: <span class="hljs-string">&#x27;ヽ(✿ﾟ▽ﾟ)ノ&#x27;</span>,</span><span class="javascript">            seen: <span class="hljs-literal">true</span></span>        &#125;    &#125;);<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>继上一个例子，添加一个和绑定DOM attribute类似的指令：<code>v-if</code>。相应的，它也类似于常见的if语句，当值为<code>true</code>时，则显示这个DOM，反之亦然。当然，所有的内容还都是动态的，在console中继续使用<code>app.seen = false</code>时，DOM元素将会隐藏。</p><p>既然有了if语句，那自然是不能少了for循环的。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;todo in items&quot;</span>&gt;</span>        &#123;&#123; todo.txt &#125;&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    <span class="hljs-keyword">let</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="javascript">        el: <span class="hljs-string">&#x27;.app&#x27;</span>,</span>        data: &#123;            items: [<span class="javascript">                &#123; <span class="hljs-attr">txt</span>: <span class="hljs-string">&#x27;小&#x27;</span> &#125;,</span><span class="javascript">                &#123; <span class="hljs-attr">txt</span>: <span class="hljs-string">&#x27;小小&#x27;</span> &#125;,</span><span class="javascript">                &#123; <span class="hljs-attr">txt</span>: <span class="hljs-string">&#x27;小小小肥羊&#x27;</span> &#125;</span>            ]        &#125;    &#125;);<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>Vue里的for循环可以用来创建列表等，并且是以数组的方式对其DOM进行控制的。指令<code>v-for=&quot;todo in items&quot;</code>中的<code>items</code>就对应了<code>data</code>中的<code>items</code>数组，而DOM里的参数<code>&#123;&#123; todo.txt &#125;&#125;</code>就相当于<code>items[i].txt</code>。</p><p>并且后续可以使用数组方法对DOM进行直接的操作：</p><pre><code class="hljs js">app.items.push(&#123;<span class="hljs-attr">txt</span>: <span class="hljs-string">&#x27;test&#x27;</span>&#125;);<span class="hljs-comment">// 4</span>app.items.shift();<span class="hljs-comment">// &#123;__ob__: Observer&#125;</span></code></pre><h3 id="处理用户输入"><a href="#处理用户输入" class="headerlink" title="处理用户输入"></a>处理用户输入</h3><p>Vue可以使用指令<code>v-on</code>来对DOM绑定一个事件监听器，通过它来调用在实例中定义的方法</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;disableImage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;切换！&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">v-bind:src</span>=<span class="hljs-string">&quot;src&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    <span class="hljs-keyword">let</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="javascript">        el: <span class="hljs-string">&#x27;.app&#x27;</span>,</span>        data: &#123;<span class="javascript">            src: <span class="hljs-string">&#x27;https://cdn.defectink.com/images/file_4963947.png&#x27;</span></span>        &#125;,        methods: &#123;<span class="javascript">            disableImage: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.src) &#123;</span><span class="javascript">                    <span class="hljs-built_in">this</span>.src = <span class="hljs-string">&#x27;&#x27;</span>;</span><span class="javascript">                &#125; <span class="hljs-keyword">else</span> &#123;</span><span class="javascript">                    <span class="hljs-built_in">this</span>.src = <span class="hljs-string">&#x27;https://cdn.defectink.com/images/file_4963947.png&#x27;</span>;</span>                &#125;            &#125;        &#125;    &#125;);<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>这是对事件监听器的一个实例，通过在<code>input</code>上绑定一个事件监听器来触发对实例中定义的方法。在实例中的方法中的<code>this</code>指向于当前实例。</p><p>在实例方法中，我们更新了应用状态，但没有触碰DOM——所有的 DOM 操作都由 Vue 来处理，我们编写的代码只需要关注逻辑层面即可。</p><p>Vue还提供了<code>v-model</code>指令，它能够轻松实现对表单的双向绑定</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>        &#123;&#123; message &#125;&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    <span class="hljs-keyword">let</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="javascript">        el: <span class="hljs-string">&#x27;#app&#x27;</span>,</span>        data: &#123;<span class="javascript">            message: <span class="hljs-string">&#x27;Input something...&#x27;</span></span>        &#125;    &#125;);<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><h2 id="组件化应用构建"><a href="#组件化应用构建" class="headerlink" title="组件化应用构建"></a>组件化应用构建</h2><p>组件系统是Vue的另一个重要概念，它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。一个大型的页面应用将由几个可重复利用的组件构成。</p><p><img src="../images/Vue.js-%E8%B5%B7%E6%AD%A5!/2020-10-16-10-25-35.webp"></p><p>在 Vue 里，一个组件本质上是一个拥有预定义选项的一个 Vue 实例。在 Vue 中注册组件很简单：</p><pre><code class="hljs js">Vue.component(<span class="hljs-string">&#x27;todo-item&#x27;</span>, &#123;    template: <span class="hljs-string">&#x27;&lt;li&gt;这是一个测试&lt;/li&gt;&#x27;</span>&#125;);<span class="hljs-keyword">let</span> app = <span class="hljs-keyword">new</span> Vue(...)</code></pre><p>注册完成后就可以使用使用它来构建一个模板：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">todo-item</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">todo-item</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    Vue.component(<span class="hljs-string">&#x27;todo-item&#x27;</span>, &#123;</span><span class="handlebars"><span class="xml">        template: &#x27;<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>这是一个测试<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>&#x27;</span></span>    &#125;);<span class="javascript">    <span class="hljs-keyword">let</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="javascript">        el: <span class="hljs-string">&#x27;#app&#x27;</span></span>    &#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>这样一个组件简而易懂，定义一个特定内容的组件，然后在html中渲染出来其内容。但这样还不够，内容都是特定的，每次渲染的都是同样的文本。我们应该能从父作用域将数据传到子组件才对。</p><p>稍微修改一下定义的组件，使其能够接收一个prop。这类似于一个自定义的attribute。</p><pre><code class="hljs js">Vue.component(<span class="hljs-string">&#x27;todo-item&#x27;</span>, &#123;  <span class="hljs-comment">// 这个 prop 名为 todo。</span>  props: [<span class="hljs-string">&#x27;todo&#x27;</span>],  template: <span class="hljs-string">&#x27;&lt;li&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt;&#x27;</span>&#125;)</code></pre><p>现在，我们可以使用 v-bind 指令将待办项传到循环输出的每个组件中：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">todo-item</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in list&quot;</span> <span class="hljs-attr">v-bind:todo</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">v-bind:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">todo-item</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    Vue.component(<span class="hljs-string">&#x27;todo-item&#x27;</span>, &#123;</span><span class="javascript">        props: [<span class="hljs-string">&#x27;todo&#x27;</span>],</span><span class="handlebars"><span class="xml">        template: &#x27;<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">todo.text</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>&#x27;</span></span>    &#125;);<span class="javascript">    <span class="hljs-keyword">let</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="javascript">        el: <span class="hljs-string">&#x27;#app&#x27;</span>,</span>        data: &#123;            list: [<span class="javascript">            &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;蔬菜&#x27;</span> &#125;,</span><span class="javascript">            &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;奶酪&#x27;</span> &#125;,</span><span class="javascript">            &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;随便其它什么人吃的东西&#x27;</span> &#125;</span>            ]        &#125;    &#125;);<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>这个实例中，父作用域中的数据通过组件的<code>prop</code>接口进行了良好的解耦。在一个大型应用中，有必要将整个应用程序划分为组件，以使开发更易管理。类似于这样：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">app-nav</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-nav</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">app-view</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">app-sidebar</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-sidebar</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">app-content</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-content</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">app-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><h3 id="与自定义元素的关系"><a href="#与自定义元素的关系" class="headerlink" title="与自定义元素的关系"></a>与自定义元素的关系</h3><p>Vue组件非常类似于<strong>自定义元素</strong>——它是 Web 组件规范的一部分，这是因为 Vue 的组件语法部分参考了该规范。例如 Vue 组件实现了 Slot API 与 is attribute。但是，还是有几个关键差别：</p><ol><li><p>Web Components 规范已经完成并通过，但未被所有浏览器原生实现。目前 Safari 10.1+、Chrome 54+ 和 Firefox 63+ 原生支持 Web Components。相比之下，Vue 组件不需要任何 polyfill，并且在所有支持的浏览器 (IE9 及更高版本) 之下表现一致。必要时，Vue 组件也可以包装于原生自定义元素之内。</p></li><li><p>Vue 组件提供了纯自定义元素所不具备的一些重要功能，最突出的是跨组件数据流、自定义事件通信以及构建工具集成。</p></li></ol><p>虽然 Vue 内部没有使用自定义元素，不过在应用使用自定义元素、或以自定义元素形式发布时，依然有很好的互操作性。Vue CLI 也支持将 Vue 组件构建成为原生的自定义元素。</p><h2 id="Vue-3"><a href="#Vue-3" class="headerlink" title="Vue 3!"></a>Vue 3!</h2><p>对于一个初学者来说，同时学习两个版本可能有些吃力。但我依然想从最基本的开始时就了解了它的变化，并且还发现了一些有意思的收获。</p><h3 id="更简洁的声明"><a href="#更简洁的声明" class="headerlink" title="更简洁的声明"></a>更简洁的声明</h3><p>第一次学习2.x版本时，发现确实如其介绍的那样：</p><blockquote><p>Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统</p></blockquote><p>用最直白的方式来看，2.x使用的方式是类似于构造函数来声明一个实例，并且有着固定的搭配：<code>el</code>为DOM的element，<code>data</code>为数据，后续还能继续添加方法：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> app = <span class="hljs-keyword">new</span> Vue(&#123;    el: <span class="hljs-string">&#x27;.app&#x27;</span>,    data: &#123;        message: <span class="hljs-string">&#x27;Hello world!&#x27;</span>    &#125;&#125;)</code></pre><p>而Vue3使用了另一种方法：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>        &#123;&#123; message &#125;&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    <span class="hljs-keyword">let</span> count = &#123;</span><span class="javascript">        <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><span class="javascript">            <span class="hljs-keyword">return</span> &#123;</span><span class="javascript">                message: <span class="hljs-string">&#x27;Hello world!&#x27;</span></span>            &#125;        &#125;    &#125;<span class="javascript">    Vue.createApp(count).mount(<span class="hljs-string">&#x27;#test&#x27;</span>);</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>Vue3首先使用一个对象字面量创建一个带有<code>data()</code>函数的变量，该函数使用的是一种更简短的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Method_definitions">定义方法的方法</a>。<code>data()</code>函数的返回值就是实例的数据。</p><p>当变量声明完成后，使用Vue的一个<code>createApp()</code>方法传入，并接着使用<code>mount()</code>方法传入DOM。这样一个Vue的实例就创建挂载完成了，相比较之下，我觉得这种方式对其生命周期有着更清晰的显示。</p><p>当然，也可以跳过创建变量这一步，直接传参，这样看上去更像Vue2。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>        &#123;&#123; message &#125;&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    <span class="hljs-keyword">let</span> app = Vue.createApp(&#123;</span><span class="javascript">        <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><span class="javascript">            <span class="hljs-keyword">return</span> &#123;</span><span class="javascript">                message: <span class="hljs-string">&#x27;xfy!&#x27;</span></span>            &#125;        &#125;,<span class="javascript">        <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;</span><span class="javascript">            <span class="hljs-keyword">let</span> id = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="javascript">                <span class="hljs-built_in">this</span>.message = <span class="hljs-string">&#x27;x&#x27;</span> + <span class="hljs-built_in">this</span>.message;</span>            &#125;, 1000);<span class="javascript">            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="javascript">                <span class="hljs-built_in">clearInterval</span>(id);</span>            &#125;, 10000)        &#125;<span class="javascript">    &#125;).mount(<span class="hljs-string">&#x27;#app&#x27;</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>就拿其官方文档的实例来看，再创建实例时还能方便的为其的添加其他方法，并且其方法名就是生命周期名。例如在挂载后执行<code>mounted()</code>。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>        &#123;&#123; message &#125;&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    <span class="hljs-keyword">let</span> count = &#123;</span><span class="javascript">        <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><span class="javascript">            <span class="hljs-keyword">return</span> &#123;</span><span class="javascript">                message: <span class="hljs-string">&#x27;Hello world!&#x27;</span></span>            &#125;        &#125;,<span class="javascript">        <span class="hljs-function"><span class="hljs-title">mounted</span>(<span class="hljs-params"></span>)</span> &#123;</span><span class="javascript">            <span class="hljs-keyword">let</span> id = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="javascript">                <span class="hljs-built_in">this</span>.message += <span class="hljs-built_in">this</span>.message;</span>            &#125;, 1000);<span class="javascript">            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><span class="javascript">                <span class="hljs-built_in">clearInterval</span>(id);</span>            &#125;,9000)        &#125;    &#125;<span class="javascript">    Vue.createApp(count).mount(<span class="hljs-string">&#x27;#test&#x27;</span>);</span></code></pre><blockquote><p>入门到这里时，2和3目前接触到的只是写法不同。后续以3为基础学习，并和2做比较。</p></blockquote><h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><p>所有的 Vue 组件都是实例，并且接受相同的选项对象。</p><h3 id="创建一个实例"><a href="#创建一个实例" class="headerlink" title="创建一个实例"></a>创建一个实例</h3><p>每个 Vue 应用都是通过用<code>createApp</code>函数创建一个新的应用实例开始的，而2.x则是以一个构造函数开始的。</p><pre><code class="hljs js">Vue.createApp(...);</code></pre><p>创建实例后，我们可以挂载它，将容器传递给<code>mount</code>方法。<code>mount</code>方法接收DOM的选择器（class、ID等）。</p><pre><code class="hljs js">Vue.createApp(...).mount(<span class="hljs-string">&#x27;#id&#x27;</span>);</code></pre><h3 id="根组件"><a href="#根组件" class="headerlink" title="根组件"></a>根组件</h3><p><code>Vue.createApp()</code>方法用于创建一个根组件，当我们挂载一个应用程序时，该组件将为渲染起点。</p><p>一个应用需要被挂载到一个DOM节点上。例如我们需要挂载实例到<code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>上，通常的步骤如下：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> rootComponent = &#123; <span class="hljs-comment">/* some data */</span> &#125;;<span class="hljs-keyword">let</span> app = Vue.createApp(rootComponent);<span class="hljs-keyword">let</span> vm = app.mount(<span class="hljs-string">&#x27;#app&#x27;</span>);</code></pre><p>不像大多数的应用程序方法，<code>mount</code>不会返回应用。相反，它会返回根节点实例。也就说变量<code>vm</code>是根节点的实例。</p><p>Vue2和3虽然都没有完全遵循MVVM模型，但是 Vue 的设计也受到了它的启发。</p><p>一个 Vue 应用由一个通过 createApp 创建的根实例，以及可选的嵌套的、可复用的组件树组成。举个例子，一个 todo 应用的组件树可以是这样的：</p><pre><code class="hljs plain">根实例└─ TodoList   ├─ TodoItem   │  ├─ DeleteTodoButton   │  └─ EditTodoButton   └─ TodoListFooter      ├─ ClearTodosButton      └─ TodoListStatistics</code></pre><h3 id="节点实例属性"><a href="#节点实例属性" class="headerlink" title="节点实例属性"></a>节点实例属性</h3><p>前面我们遇到了<code>data</code>属性，<code>data</code>中定义的属性通过节点实例暴露出来：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> app = Vue.createApp(&#123;    <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">return</span> &#123;            meg: <span class="hljs-string">&#x27;greeting something...&#x27;</span>        &#125;    &#125;&#125;);<span class="hljs-keyword">let</span> vm = app.mount(<span class="hljs-string">&#x27;#app&#x27;</span>);<span class="hljs-built_in">console</span>.log(vm.meg) <span class="hljs-comment">// &#x27;greeting something...&#x27;</span></code></pre><p><code>data</code>中暴露出的属性都会加如其响应式系统，整个实例会被设置一个Proxy代理拦截其行为，从而监听数据的变化并实时渲染到DOM上。</p><p>还有其他各种用户自定义属性的组件选项能够添加到实例，例如<code>methods</code>, <code>props</code>, <code>computed</code>, <code>inject</code>和<code>setup</code>。</p><p>Vue同样也暴露了一些内建的属性，例如<code>$attrs</code>和<code>$emit</code>。他们都有<code>$</code>前缀与用户自定义的属性区分开来。</p><h2 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h2><p>每个组件在创建后都要经历一系列初始化的步骤，例如，它需要设置数据监控，编译模板，挂载实例到DOM节点和当数据变化时更新DOM。这一系列操作也被称之为生命周期钩子。</p><p>简单来说，就是一个实例在从最初始的声明到最后的卸载期间不同阶段对其操作的API。</p><p>例如，调用<code>create()</code>钩子，在实例被创建后运行的操作：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> app = Vue.createApp(&#123;    <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-keyword">return</span> &#123;            meg: <span class="hljs-string">&#x27;test&#x27;</span>        &#125;    &#125;,    <span class="hljs-function"><span class="hljs-title">created</span>(<span class="hljs-params"></span>)</span> &#123;        <span class="hljs-comment">// `this`指向当前实例</span>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;instance created!&#x27;</span> + <span class="hljs-built_in">this</span>.meg);    &#125;&#125;);<span class="hljs-keyword">let</span> vm = app.mount(<span class="hljs-string">&#x27;#app&#x27;</span>);</code></pre><p>所有的一系列钩子，他们的<code>this</code>都指向当前调用的活动实例。</p><blockquote><p>注意，不要在一个组件属性或回调中使用箭头函数。例如：<code>created: () =&gt; &#123;console.log(this.a);&#125;;</code>或者<code>vm.$watch(&#39;a&#39;, newValue =&gt; this.myMethod());</code>。箭头函数没有自己的<code>this</code>，<code>this</code>会和其他变量一样，向上层作用域中查找，直到找到为止。通常会遇到这样的报错：<code>Uncaught TypeError: Cannot read property of undefined</code>或<code>Uncaught TypeError: this.myMethod is not a function.</code></p></blockquote><h2 id="生命周期图"><a href="#生命周期图" class="headerlink" title="生命周期图"></a>生命周期图</h2><p>下图可以很清晰的看到Vue3的实例的一个生命周期。</p><p><img src="../images/Vue.js-%E8%B5%B7%E6%AD%A5!/2020-10-22-11-03-33.webp"></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node.js之旅</title>
    <link href="/defect/get-starting-for-node-js.html"/>
    <url>/defect/get-starting-for-node-js.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine.</p></blockquote><p>Node.js不仅仅是服务器上的JavaScript。</p><p><img src="../images/Node.js%E4%B9%8B%E6%97%85/2020-09-03-14-54-53.webp"></p><h2 id="并不熟悉的JavaScript"><a href="#并不熟悉的JavaScript" class="headerlink" title="并不熟悉的JavaScript"></a>并不熟悉的JavaScript</h2><p>虽然说Node直接般来了个V8来运行JavaScript，但它毕竟不运行在浏览器上，并且是由事件驱动的异步程序，它的本来的目的就是用来搭建高性能的Web服务器。在极少情况下，编写的 JavaScript 代码没有按期望的方式运行。</p><p>在客户端的运行环境下，只要是在同一个浏览器窗口运行的JS环境就属于同一个全局环境。无论是在哪里引入的JS文件，都属于同一个运行环境，全局变量能够正常工作，例如有两个js被引入：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;a.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;b.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>他们分别有一段代码：</p><pre><code class="hljs js"><span class="hljs-comment">// a.js</span><span class="hljs-keyword">let</span> a = <span class="hljs-string">&#x27;xxxxxfy!&#x27;</span>;<span class="hljs-comment">// b.js</span>alert(a);</code></pre><p>正常情况下全局变量<code>a</code>是可以被正常访问的，而在node中，a.js和b.js分别是两个文件，不做其他操作的情况下，他们分别是两个全局变量。</p><h2 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h2><p>Node 运行时的基础架构由两大组件构成：</p><ul><li>JavaScript 引擎</li><li>非阻塞 I/O 库</li></ul><h3 id="JavaScript引擎"><a href="#JavaScript引擎" class="headerlink" title="JavaScript引擎"></a>JavaScript引擎</h3><p>众所周知，node使用的是Chrome大排自吸V8，它可以运行任何JS代码。启动时，它会启动一个V8的引擎实例，且node可以充分的利用这个引擎实例。</p><p>V8可嵌入（/绑定）到任何C++程序中，。这意味着，除了纯 JavaScript 库外，还可以扩展 V8 来创建全新的函数（或函数模板），方法是将其与 V8 绑定在一起。并且node还支持使用编译好的二进制的C++程序。</p><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>JavaScript是一门单线程的语言，无论换到什么地方运行，它也是单线程语言。单线程语言面临的最大的问题就是阻塞，在前面的代码没有被执行完，后面的代码都将处于等待状态。</p><p>node使用<a href="http://libuv.org/">libuv</a>来实现事件循环。要使用事件循环可以使用异步API，可将回调函数作为参数传递到该 API 函数，在事件循环期间会执行该回调函数。node异步编程的直接体现就是回调函数。异步编程基于回调函数来实现，但不能说是使用了回调后程序就异步化了。Node 所有 API 都支持回调函数。</p><pre><code class="hljs smali">   ┌───────────────────────────┐┌─&gt;│           timers          ││  └─────────────┬─────────────┘│  ┌─────────────┴─────────────┐│  │     pending callbacks     ││  └─────────────┬─────────────┘│  ┌─────────────┴─────────────┐│  │       idle, prepare       ││  └─────────────┬─────────────┘      ┌───────────────┐│  ┌─────────────┴─────────────┐      │   incoming:   ││  │           poll            │&lt;─────┤  connections, ││  └─────────────┬─────────────┘      │   data, etc.  ││  ┌─────────────┴─────────────┐      └───────────────┘│  │          <span class="hljs-built_in"> check </span>          ││  └─────────────┬─────────────┘│  ┌─────────────┴─────────────┐└──┤      close callbacks      │   └───────────────────────────┘</code></pre><p>例如，我们可以一边读取文件，一边执行其他命令，在文件读取完成后，我们将文件内容作为回调函数的参数返回。这样在执行代码时就没有阻塞或等待文件 I/O 操作。这就大大提高了 Node.js 的性能，可以处理大量的并发请求。</p><p>事件循环包含多个调用回调函数的阶段：</p><ul><li>计时器阶段：将运行 setInterval() 和 setTimeout() 过期计时器回调函数</li><li>轮询阶段：将轮询操作系统以查看是否完成了所有 I/O 操作，如果已完成，将运行回调函数</li><li>检查阶段：将运行 setImmediate() 回调函数</li></ul><p>一个常见的误区是，认为 V8 和事件循环回调函数在不同线程上运行。但事实并非如此。V8 在同一个线程上运行所有 JavaScript 代码。</p><h2 id="非阻塞I-O"><a href="#非阻塞I-O" class="headerlink" title="非阻塞I/O"></a>非阻塞I/O</h2><p>已经简单的了解过node基于v8的单线程来使用回调函数实现异步编程，从而达到高性能与高并发。</p><h3 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h3><p>异步I/O能够大大的提升程序的工作效率，且不会影响剩下的代码执行。</p><h4 id="同步读取文件"><a href="#同步读取文件" class="headerlink" title="同步读取文件"></a>同步读取文件</h4><p>首先来看下同步读取文件</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;starting process...&#x27;</span>);<span class="hljs-keyword">let</span> data = fs.readFileSync(<span class="hljs-string">&#x27;test.txt&#x27;</span>);<span class="hljs-built_in">console</span>.log(data);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;the end&#x27;</span>);</code></pre><p>同步读取文件会按照从上到下的顺序来执行代码，到遇到读取I/O时，剩下的代码将处于等待状态。并且在读取I/O时遇到错误（例如文件不存在），将会直接返回错误，剩下的代码将不执行完。</p><h4 id="异步读取文件"><a href="#异步读取文件" class="headerlink" title="异步读取文件"></a>异步读取文件</h4><pre><code class="hljs js"><span class="hljs-keyword">let</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;starting process...&#x27;</span>);fs.readFile(<span class="hljs-string">&#x27;test.txt&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (err) &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;something was wrong: &#x27;</span> + err);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">console</span>.log(data);    &#125;&#125;)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;the end&#x27;</span>);</code></pre><p>异步读取文件调用了回调函数，它设置了一个事件循环，在等待读取I/O的同时，将继续执行剩下的代码。当文件读取完成之后，将会返回回调函数，并输出结果。并且当读取文件遇到错误时，在等待读取期间执行的代码将正常执行。</p><p>异步的结果看起来像是这样的：</p><pre><code class="hljs angelscript">starting process...the end&lt;Buffer <span class="hljs-number">64</span> <span class="hljs-number">66</span> <span class="hljs-number">6</span>a <span class="hljs-number">61</span> <span class="hljs-number">73</span>&gt;</code></pre><p>在等待其读取<code>test.txt</code>的期间，JS将剩下的<code>console.log</code>语句先执行了。</p><h3 id="同步I-O"><a href="#同步I-O" class="headerlink" title="同步I/O"></a>同步I/O</h3><p>node的设计理念就是使用异步编程，使用阻塞编程可无法写出一个高性能的web服务器。</p><p>但这不代表着同步I/O就一无是处，在某些情况下，同步 I/O 通常比异步 I/O 更快，原因在于设置和使用回调函数、轮询操作系统来获取 I/O 状态等操作都涉及到一定的开销。</p><p>如果需要写一个一次性的使用程序，仅用于处理一个文件，从命令行中启动 Node，并向其传递 JavaScript 实用程序的文件名。此时，该实用程序是唯一运行的程序，因此，即使它阻塞了 V8 线程，也没有任何影响。在此情况下，适合使用同步 I/O。</p><p>只要是谨慎使用同步 Node API 调用，就不会出现什么问题。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>V8是有八个气缸的V型发动机.</li><li>JavaScript是单线程语言，它通过V8 引擎提供的异步执行回调接口实现了异步编程。</li></ul><p>全文均是笔记</p><ul><li><a href="https://developer.ibm.com/zh/tutorials/learn-nodejs-tour-node/">Node.js 之旅</a></li><li><a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/">The Node.js Event Loop</a></li><li><a href="https://www.runoob.com/nodejs/nodejs-callback.html">Node.js 回调函数</a></li><li><a href="https://zh.wikipedia.org/wiki/V8%E5%8F%91%E5%8A%A8%E6%9C%BA">V8发动机</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>入坑IRC</title>
    <link href="/defect/irc-getting-started.html"/>
    <url>/defect/irc-getting-started.html</url>
    
    <content type="html"><![CDATA[<h2 id="IRC"><a href="#IRC" class="headerlink" title="IRC"></a>IRC</h2><p>IRC的全称为Internet Relay Chat，是一种应用层的协议。主要用于聊天，是早期互联网中主流的聊天工具，在今天依然也有不少人活跃。要使用它需要使用客户端来连接到服务器。</p><h2 id="IRC的组成"><a href="#IRC的组成" class="headerlink" title="IRC的组成"></a>IRC的组成</h2><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><p>IRC是一个分布式的C/S架构。通过连接到一个服务器，就可以访问其连接的其他服务器上的频道。目前常见的有<code>irc.freenode.net</code>。</p><h3 id="频道"><a href="#频道" class="headerlink" title="频道"></a>频道</h3><p>频道存在于一个IRC服务器上。一个频道类似于一个聊天室，频道名称必须以#符号开始，例如#irchelp。</p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>客户端用于连接至服务器，目前有很多种基于字符/GUI的跨平台软件。我用的是HexChat，一款基于GUI的软件。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>简单的了解了IRC是一款用于聊天的应用协议之后，就是开始使用了。既然是基于C/S架构的，那么首先是准备好自己的客户端。我挑了一个常见的GUI客户端：HexChat。</p><h3 id="昵称注册"><a href="#昵称注册" class="headerlink" title="昵称注册"></a>昵称注册</h3><p>IRC并不像现代的聊天软件一样，需要先注册账号才能使用。它可以输入一个昵称后就进入服务器的频道内与人聊天。而昵称任然是需要唯一的，所以想要使用自己的昵称而不被别人占用，就需要注册昵称。类似于注册账号，基于邮箱与密码。</p><p>注册过程很简单，首先需要在聊天窗口中输入注册的命令：</p><pre><code class="hljs cpp">/msg nickserv <span class="hljs-keyword">register</span> password email</code></pre><p>因为是在聊天框里输入命令，所以一定要注意命令格式，否则一不小心可能就会将明文的密码发到频道里。在注册昵称时推荐不加入任何频道，这样就不会不小心发出去了。</p><p>输入注册命令后就会收到认证的邮件，邮件大概是这样的（freenode）：</p><p><img src="../images/%E5%85%A5%E5%9D%91IRC/2020-08-22-11-55-07.webp"></p><p>将邮件里的内容再输入一遍就注册完成了。</p><pre><code class="hljs markdown">/msg NickServ VERIFY REGISTER Defectink hr<span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-emphasis">*</span></code></pre><h3 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h3><p>当注册昵称过后，下次再使用这个昵称登录的时候就需要认证了。使用同样的<code>/msg</code>来进行认证：</p><pre><code class="hljs jboss-cli"><span class="hljs-string">/msg</span> nickserv identify password</code></pre><p>另一种说明身份的方法是设置服务器密码为您注册时提供的密码。</p><p>还可以对昵称设置进行保护，即在登录认证时，必须在30秒内向服务器表明身份，否则就强制改为其他昵称，并在一段时间内禁止此人使用此昵称（即便是在说明身份后）。在任意窗口中键入：<code>/msg nickserv set enforce on</code>。如果你登陆时在30秒内未能表明身份且被改为其他名字，请在改回原有名称前，输入<code>/msg nickserv release username password</code>以解除。</p><h3 id="SASL"><a href="#SASL" class="headerlink" title="SASL"></a>SASL</h3><p>不少 IRC 客户端都支持使用 SASL 自动登录。只需找到相应的选项，在 SASL 用户名密码部分分别填入自己的昵称和NickServ密码，就可以获得自动登录的效果。</p><p>不同的客户端有不同的设置方法，文档也很多。这是对于HexCaht的：</p><ol><li>Open the Network List (Ctrl + S)</li><li>The freenode network may already exist; find it in the list then click on Edit</li><li>In the <code>User name</code> field, enter your primary nick</li><li>Select <code>SASL (username + password)</code> for the <code>Login method</code> field</li><li>In the <code>Password</code> field, enter your NickServ password</li></ol><p><img src="../images/%E5%85%A5%E5%9D%91IRC/2020-08-22-15-28-26.webp"></p><h2 id="频道-1"><a href="#频道-1" class="headerlink" title="频道"></a>频道</h2><p>以#号开头的字符串就是频道名，可以使用命令<code>/join</code>来加入频道。</p><p><code>/join #archlinux-cn</code></p><h3 id="建立频道"><a href="#建立频道" class="headerlink" title="建立频道"></a>建立频道</h3><p>创建频道同样也是使用<code>/join</code>来创建，如果创建的频道已经存在，则直接进入。建立频道可用于与自己的小伙伴聊天，也可以用于熟悉频道命令。</p><p>如果频道成功建立，那么我们就会成为频道的管理员。因为频道名和昵称一样需要具有唯一性，所以频道也需要注册。</p><p><code>/msg ChanServ REGISTER &lt;#channel&gt; &lt;passwd&gt;</code></p><p>一般频道都通过ChanServ这个机器人管理. </p><p><code>/msg ChanServ SET &lt;频道名&gt; GUARD ON</code></p><p>在已注册的频道上委任管理员OP</p><p><code>/msg ChanServ op #xfy Defectink</code></p><p>设置频道简介</p><p><code>/topic &lt;your_topic&gt;</code></p><h3 id="频道模式"><a href="#频道模式" class="headerlink" title="频道模式"></a>频道模式</h3><p>频道的模式用于设置频道的一些功能与限制。通过<code>/mode #channel</code>来列出频道模式，通过<code>/msg chanserv info #channel</code>来列出有MLOCK的模式。</p><p>使用<code>/mode #channel +(mode)</code>或者<code>/mode #channel -(mode)</code>来增加或删除模式。带有MLOCK的模式需要使用<code>/msg ChanServ SET #foo MLOCK +c</code></p><p>一些常用的模式：</p><table><thead><tr><th align="left">Mode(name)</th><th>Description</th></tr></thead><tbody><tr><td align="left">b (channel ban)</td><td>Prevent users from joining or speaking. Sending /mode #channel +b alone will return the current ban list. While on the channel, banned users will be unable to send to the channel or change nick. The most common form for a ban is +b nick!user@host. The wildcards * and ? are allowed, matching zero-or-more and exactly-one characters, respectively. Bans set on IP addresses will apply even if the affected user joins with a resolved or cloaked hostname. CIDR notation is supported in bans. The second form can be used for bans based on user data. You can append $#channel to any ban to redirect banned users to another channel.</td></tr><tr><td align="left">q (quiet)</td><td>Works like +b (ban user), but allows matching users to join the channel.</td></tr><tr><td align="left">c (colour filter)</td><td>Strip colour and formatting codes from channel messages.</td></tr><tr><td align="left">C (block CTCPs)</td><td>Blocks CTCP commands (other than /me actions).</td></tr><tr><td align="left">i (invite only)</td><td>Users are unable to join invite-only channels unless they are invited or match a +I entry.</td></tr><tr><td align="left">k (password)</td><td>To enter the channel, you must specify the password on your /join command. Keep in mind that modes locked with ChanServ’s MLOCK command can be seen by anyone recreating the channel; this includes keys. Also keep in mind that users being on the channel when +k is set will see the key as well.</td></tr><tr><td align="left">n (prevent external send)</td><td>Users outside the channel may not send messages to it. Keep in mind that bans and quiets will not apply to external users.</td></tr><tr><td align="left">l (join limit)</td><td>Takes a positive integer parameter. Limits the number of users who can be in the channel at the same time.</td></tr><tr><td align="left">m (moderated)</td><td>Only opped and voiced users can send to the channel. This mode does not prevent users from changing nicks.</td></tr><tr><td align="left">t (ops topic)</td><td>Only channel operators may set the channel topic.</td></tr></tbody></table><h3 id="管理员"><a href="#管理员" class="headerlink" title="管理员"></a>管理员</h3><p>频道管理员称为operation channel。通常为：</p><ol><li>sop (super operator) 频道的註册者，拥有操作频道所有权限，包括踢人。</li><li>aop (auto operator) 频道註册者信任的共同管理者，拥有部分权限，和第三个的差异在於，离开频道后再进入还是能拥有管理权限。</li><li>op 普通管理者，可能一旦离开频道就失去op。</li></ol><h2 id="weechat"><a href="#weechat" class="headerlink" title="weechat"></a>weechat</h2><p>weechat是一款基于命令行的客户端。</p><h3 id="添加服务器"><a href="#添加服务器" class="headerlink" title="添加服务器"></a>添加服务器</h3><pre><code class="hljs routeros"><span class="hljs-built_in">/server </span><span class="hljs-builtin-name">add</span> freenode chat.freenode.net</code></pre><h3 id="服务器选项"><a href="#服务器选项" class="headerlink" title="服务器选项"></a>服务器选项</h3><p>weechat的一些选项加油默认值，昵称默认为终端用户名。</p><pre><code class="hljs stylus">/set irc<span class="hljs-selector-class">.server</span><span class="hljs-selector-class">.freenode</span><span class="hljs-selector-class">.nicks</span> <span class="hljs-string">&quot;mynick,mynick2,mynick3,mynick4,mynick5&quot;</span></code></pre><p>设置用户和真实姓名：</p><pre><code class="hljs stylus">/set irc<span class="hljs-selector-class">.server</span><span class="hljs-selector-class">.freenode</span><span class="hljs-selector-class">.username</span> <span class="hljs-string">&quot;My user name&quot;</span>/set irc<span class="hljs-selector-class">.server</span><span class="hljs-selector-class">.freenode</span><span class="hljs-selector-class">.realname</span> <span class="hljs-string">&quot;My real name&quot;</span></code></pre><p>在启动时启用自动连接到服务器：</p><pre><code class="hljs applescript">/<span class="hljs-keyword">set</span> irc.server.freenode.autoconnect <span class="hljs-keyword">on</span></code></pre><p>使用SSL连接：</p><pre><code class="hljs stylus">/set irc<span class="hljs-selector-class">.server</span><span class="hljs-selector-class">.freenode</span><span class="hljs-selector-class">.addresses</span> <span class="hljs-string">&quot;chat.freenode.net/7000&quot;</span>/set irc<span class="hljs-selector-class">.server</span><span class="hljs-selector-class">.freenode</span><span class="hljs-selector-class">.ssl</span> on</code></pre><p>SASL：</p><pre><code class="hljs stylus">/set irc<span class="hljs-selector-class">.server</span><span class="hljs-selector-class">.freenode</span><span class="hljs-selector-class">.sasl_username</span> <span class="hljs-string">&quot;mynick&quot;</span>/set irc<span class="hljs-selector-class">.server</span><span class="hljs-selector-class">.freenode</span><span class="hljs-selector-class">.sasl_password</span> <span class="hljs-string">&quot;xxxxxxx&quot;</span></code></pre><p>nickserv：</p><pre><code class="hljs stylus">/set irc<span class="hljs-selector-class">.server</span><span class="hljs-selector-class">.freenode</span><span class="hljs-selector-class">.command</span> <span class="hljs-string">&quot;/msg nickserv identify xxxxxxx&quot;</span></code></pre><p>autojoin：</p><pre><code class="hljs stylus">/set irc<span class="hljs-selector-class">.server</span><span class="hljs-selector-class">.freenode</span><span class="hljs-selector-class">.autojoin</span> <span class="hljs-string">&quot;#channel1,#channel2&quot;</span></code></pre><h3 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h3><pre><code class="hljs arduino">/<span class="hljs-built_in">connect</span> freenode</code></pre><pre><code class="hljs arduino">/<span class="hljs-built_in">disconnect</span> freenode</code></pre><h3 id="窗口-缓冲区管理"><a href="#窗口-缓冲区管理" class="headerlink" title="窗口/缓冲区管理"></a>窗口/缓冲区管理</h3><pre><code class="hljs jboss-cli"><span class="hljs-string">/buffer</span><span class="hljs-string">/window</span></code></pre><p>例如，将屏幕垂直分割为一个小窗口（1/3宽度）和一个大窗口（2/3），使用命令：</p><pre><code class="hljs angelscript">/window splitv <span class="hljs-number">33</span></code></pre><p>删除分割：</p><pre><code class="hljs sas">/<span class="hljs-meta">window</span> <span class="hljs-meta">merge</span></code></pre><h2 id="一些常用的命令"><a href="#一些常用的命令" class="headerlink" title="一些常用的命令"></a>一些常用的命令</h2><table><thead><tr><th align="left">示例命令</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left"><code>/server irc.freenode.net</code></td><td align="left">连接到 <code>freenode</code> 网络</td></tr><tr><td align="left"><code>/nick myName</code></td><td align="left">更换昵称为 myName</td></tr><tr><td align="left"><code>/msg nickserv register password me@163.com</code></td><td align="left">注册昵称, 密码为 password, 邮箱为 <a href="mailto:&#109;&#x65;&#64;&#x31;&#x36;&#x33;&#x2e;&#99;&#x6f;&#x6d;">&#109;&#x65;&#64;&#x31;&#x36;&#x33;&#x2e;&#99;&#x6f;&#x6d;</a></td></tr><tr><td align="left"><code>/join #java</code></td><td align="left">进入 #java 聊天室</td></tr><tr><td align="left"><code>/exit</code></td><td align="left">退出账户</td></tr><tr><td align="left"><code>/nick zhijia</code></td><td align="left">登陆或切换用户名</td></tr><tr><td align="left"><code>/msg NickServ identify &lt;password&gt;</code></td><td align="left">切换用户后登陆验证用户身份</td></tr><tr><td align="left"><code>/help</code></td><td align="left">帮助</td></tr><tr><td align="left"><code>/quit</code></td><td align="left">退出服务器</td></tr><tr><td align="left"><code>/whois 昵称</code></td><td align="left">查看某人的资料</td></tr><tr><td align="left"><code>/part</code></td><td align="left">离开频道</td></tr><tr><td align="left"><code>/query 昵称</code></td><td align="left">和某人开小窗口私聊</td></tr><tr><td align="left"><code>/away 原因</code></td><td align="left">离开</td></tr><tr><td align="left"><code>/away</code></td><td align="left">取消离开。当您不写原因时，就会取消离开状态</td></tr></tbody></table><h2 id="坑中"><a href="#坑中" class="headerlink" title="坑中"></a>坑中</h2><p>在今天日异月新的IM中，IRC肯定是较小众。虽然几乎就是上个世纪流行的沟通方式了，不过在今天回味一下也很棒，如果有人在一起聊天的话就更棒了。</p><p>freenode有个web版，入门体验很好。<a href="https://webchat.freenode.net/">webchat</a></p><p>另外，#xfy on freenode.</p>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>tools</tag>
      
      <tag>IRC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript的函数</title>
    <link href="/defect/function-of-javascript.html"/>
    <url>/defect/function-of-javascript.html</url>
    
    <content type="html"><![CDATA[<p>函数表达式是JavaScript中一个强大同时容易令人困惑的特性。</p><p>定义函数的方式有两种：函数声明和函数表达式。</p><p>函数声明首先是<code>function</code>关键字，其后是函数的名字，这就是指定函数名字的方式。</p><pre><code class="hljs js"><span class="hljs-comment">// 函数声明</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hi, there&#x27;</span>);&#125;</code></pre><p>关于函数声明，其一个重要特征就是<strong>函数声明体提升</strong>。它和用<code>var</code>声明提升类似，但他是整体提升，所以可以在声明前使用。</p><pre><code class="hljs js"><span class="hljs-comment">// 函数声明提升</span>test();<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hi, there&#x27;</span>);&#125;</code></pre><p>函数表达式创建函数有一点不同，它类似于声明一个变量，使用<code>var</code>或者<code>let</code>来声明一个函数体。</p><p><code>let</code>关键字后的变量名就是函数的名字，而函数后没有名称，这个函数称为匿名函数。可以理解为将这个匿名函数赋值给了这个变量。</p><pre><code class="hljs js"><span class="hljs-comment">// 函数表达式</span><span class="hljs-keyword">let</span> test = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Yo, there&#x27;</span>);&#125;</code></pre><p>函数表达式与其他表达式一样，需要先声明才能使用。尽管<code>var</code>创建的变量会声明提升，但是赋值并不会提升。</p><pre><code class="hljs js">test();<span class="hljs-comment">// 函数还未声明</span><span class="hljs-keyword">let</span> test = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;something...&#x27;</span>);&#125;</code></pre><p>在早期的环境里，函数声明和if语句可能还不能工作的和契合。不过现在多数浏览器与运行环境都能正常执行如下代码：</p><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>) &#123;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hi</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hi&#x27;</span>);    &#125;&#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hi</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;yo&#x27;</span>);    &#125;&#125;</code></pre><p>我的猜测可能是和函数声明提升有关，因为js没有块级作用域，所以在if语句里根据条件的函数声明都提升了，导致就算条件满足，最后声明的还是下面的函数声明。</p><p>如果真的有不能运行的环境，可以做这样的尝试。因为提前声明了变量，在将匿名函数赋值给变量，所以就不存在函数声明提升这个特性了。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> hi;<span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>) &#123;    hi = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hi&#x27;</span>);    &#125;&#125; <span class="hljs-keyword">else</span> &#123;    hi = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;yo&#x27;</span>);    &#125;&#125;</code></pre><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归函数是在一个函数通过名字调用自身的情况下构成的：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">num</span>) </span>&#123;    <span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> num + add(num - <span class="hljs-number">1</span>);&#125;</code></pre><p>这是一个经典的递归实例，但是如果将函数名更换一下。并将前一个函数名给解除引用，就会导致函数出错。这是因为函数内部的递归是通过函数名来引用这个函数的。如果更换了函数名，就会导致这种错误。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">num</span>) </span>&#123;    <span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> num + add(num - <span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">let</span> minus = add;add = <span class="hljs-literal">null</span>;<span class="hljs-built_in">console</span>.log(minus(<span class="hljs-number">5</span>));<span class="hljs-comment">// return num + add(num - 1);</span><span class="hljs-comment">//                ^</span><span class="hljs-comment">// TypeError: add is not a function</span></code></pre><p>但这并不影响递归，可以换种方式来继续引用函数自身。<code>arguments.callee</code>就是指向正在执行的函数的指针，因此可以用它来实现对函数递归的调用。从而与函数名拜托关系。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">num</span>) </span>&#123;    <span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> num + <span class="hljs-built_in">arguments</span>.callee(num - <span class="hljs-number">1</span>);&#125;<span class="hljs-keyword">let</span> minus = add;add = <span class="hljs-literal">null</span>;<span class="hljs-built_in">console</span>.log(minus(<span class="hljs-number">5</span>));</code></pre><p>但<code>arguments.callee</code>不能在strict下使用。不过可以通过命名函数表达式来达到相同的效果。</p><p>在使用函数表达式时，使用小括号可以为函数体添加一个任然有效的名称。再将这个函数赋值给这个变量，无论函数怎么更换引用，函数名任然有效。这种方式再严格模式和非严格模式都行得通。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> add = (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params">num</span>) </span>&#123;    <span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> num + a(num - <span class="hljs-number">1</span>);&#125;)</code></pre><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包就是在一个函数的内部返回另一个函数，返回的函数将还能访问外部函数的AO。</p><p>在compare这个函数里返回了另一个内部函数（一个匿名函数），这个匿名函数使用了compare函数的<code>prep</code>参数。即使这个函数被返回到了外部使用，依然能访问到prep变量。这涉及到作用域链的细节。</p><p>当一个函数运行时（被调用时），会创建一个执行环境（execution context）及相应的作用域链，然后使用arguments和其他参数的值来初始化函数的活动对象（Activation Object）。这个AO会随着作用域链，链给内部的函数，并使内部函数可以访问外部函数的变量。</p><p><a href="https://www.defectink.com/defect/javascript-scope-and-chain.html">JavaScript的作用域与链</a></p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compare</span>(<span class="hljs-params">prep</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj1, obj2</span>) </span>&#123;        <span class="hljs-keyword">let</span> o1 = obj1[prep];        <span class="hljs-keyword">let</span> o2 = obj2[prep];        <span class="hljs-keyword">if</span> (obj1[prep] &lt; obj2[prep]) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (obj1[prep] &gt; obj2[prep]) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        &#125;    &#125;&#125;</code></pre><p>当创建compare函数时，会创建一个包含全局对象的作用域链，这个作用域链被保存在内部的[[scope]]属性中。当调用<code>compare()</code>函数时，会为函数创建一个执行环境，然后赋值[[scope]]属性中的对象构建起执行环境的作用域链。</p><p>作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。</p><p>无论什么时候访问函数中的一个变量时，就会从作用域链中搜索具有相应名字的变量。一般来说，当函数执行完后，局部活动对象就会被销毁，内存中仅保留全局作用域（全局执行环境的活动对象GO）。</p><p>但闭包的情况有所不同，当外部函数执行完后，其活动对象也不会被销毁，内部函数依然引用着外部函数的作用域链，。在将内部函数返回后，其执行环境的作用域链会被销毁，但是它的活动对象依然会留在内存中，直到匿名函数被销毁。</p><blockquote><p>由于闭包会携带着包含它的函数的作用域，所以会占用更多的内存。虽然2020年不差内存，且像v8等js引擎会尝试回收闭包的内存，但还是推荐谨慎使用。</p></blockquote><h3 id="闭包与变量"><a href="#闭包与变量" class="headerlink" title="闭包与变量"></a>闭包与变量</h3><p>作用域链的机制以及没有块级作用域的特性引出了一个副作用，即闭包只能取得外部函数AO中变量任何最后一个值。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cycle</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> arr = [];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;        arr[i] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-built_in">console</span>.log(i);        &#125;    &#125;    <span class="hljs-keyword">return</span> arr;&#125;<span class="hljs-keyword">let</span> test = cycle();test[<span class="hljs-number">1</span>]();</code></pre><p>数组随着for循环将函数赋值到自身，变量i会随着循环的增加而增加。但是函数被赋值时并没有执行，等到函数被返回后在外部被执行时，访问到的i已经是AO里的10了。</p><p>可以使用立即执行函数，让i变量成为实参传入数组的函数内，因为<strong>参数是按值传递的</strong>，这样在外部执行时，每个匿名函数中的变量都有一个副本。</p><p>立即执行函数在执行后会被销毁，但是它的AO依然被内部的函数所引用。所以对应次数循环的函数内j就对应立即执行函数AO中的j，且每个立即执行函数AO中的j都对应i，因为每次的立即执行函数都不同。</p><p>可以使用立即执行函数来为内部的匿名函数再封装一个AO来解决此问题。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cycle</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> arr = [];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;        (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">o</span>) </span>&#123;            arr[o] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;                <span class="hljs-built_in">console</span>.log(o);            &#125;        &#125;)(i);    &#125;    <span class="hljs-keyword">return</span> arr;&#125;</code></pre><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cycle</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> arr = [];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;        arr[i] = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">o</span>) </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;                <span class="hljs-built_in">console</span>.log(o);            &#125;        &#125;)(i);    &#125;    <span class="hljs-keyword">return</span> arr;&#125;<span class="hljs-keyword">let</span> test = cycle();</code></pre><p>或者直接使用let来声明变量，产生块级作用域，在根本上解决问题。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cycle</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> arr = [];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;             arr[i] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;                <span class="hljs-built_in">console</span>.log(i);            &#125;    &#125;    <span class="hljs-keyword">return</span> arr;&#125;</code></pre><h3 id="关于this对象"><a href="#关于this对象" class="headerlink" title="关于this对象"></a>关于this对象</h3><p>在闭包中使用this对象可能会出现一些小问题。由于闭包返回的匿名函数是在外部执行的，所以匿名函数的执行环境具有全局性，因此它的this对象通常指向window。</p><pre><code class="hljs js"><span class="hljs-built_in">global</span>.name = <span class="hljs-string">&#x27;xfy&#x27;</span>;<span class="hljs-comment">// window.name = &#x27;xfy&#x27;;</span><span class="hljs-keyword">let</span> obj = &#123;    name: <span class="hljs-string">&#x27;xxxfy&#x27;</span>,    age: <span class="hljs-number">18</span>,    say: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);        &#125;    &#125;&#125;obj.say()();</code></pre><p>这个例子在非严格模式下返回的是全局对象的属性。那为什么匿名函数没有取得外部函数的this的值呢？</p><p>每个函数在被调用时都会自动取得两个特殊的变量：this和arguments。内部函数在搜索这两个变量时，只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量（在匿名函数没有定义形参时可以访问外部函数的实参）。</p><p>可以将this实体化，保持在外部函数的AO中，再由匿名函数去访问外部AO中的变量。即使在函数返回之后，that也任然引用着obj。</p><pre><code class="hljs js"><span class="hljs-built_in">global</span>.name = <span class="hljs-string">&#x27;xfy&#x27;</span>;<span class="hljs-comment">// window.name = &#x27;xfy&#x27;;</span><span class="hljs-keyword">let</span> obj = &#123;    name: <span class="hljs-string">&#x27;xxxfy&#x27;</span>,    age: <span class="hljs-number">18</span>,    say: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">let</span> that = <span class="hljs-built_in">this</span>;        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-built_in">console</span>.log(that.name);        &#125;    &#125;&#125;obj.say()();</code></pre><p>有几种特殊的情况，会导致this发生意外的变化。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;    name: <span class="hljs-string">&#x27;xfy&#x27;</span>,    feature: <span class="hljs-string">&#x27;handsome&#x27;</span>,    say: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);    &#125;&#125;<span class="hljs-built_in">global</span>.name = <span class="hljs-string">&#x27;dfy&#x27;</span>;<span class="hljs-comment">// 非严格模式下;</span><span class="hljs-comment">// let name = &#x27;dfy&#x27;;</span></code></pre><p>第一行就是平时最平常的调用了对象的方法，this得到正确的引用。第二行在方法执行前加上了括号，虽然加上了括号之后好像是在引用一个函数，但this的值得到了维持。而第三行代码先执行了一条赋值语句，然后再调用赋值后的结果。因为这个赋值表达式的值是函数本身，所以this的值不能得到维持，返回的就是全局对象里的属性了。</p><pre><code class="hljs js">obj.say();<span class="hljs-comment">// xfy;</span>(obj.say)();<span class="hljs-comment">// xfy;</span>(obj.say = obj.say)();<span class="hljs-comment">// &#x27;dfy&#x27;;</span></code></pre><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>在高贵的IE9之前的版本，JScript对象和COM对象使用不同的辣鸡收集程序例程。那么在这些版本中的ie使用闭包就会导致一些特殊的问题。如果闭包的作用域中保存着一个HTML元素，那么就意味着该元素无法被销毁。</p><p>这样的一个简单的示例为element元素事件创建了一个闭包，而这个闭包又创建了一个循环引用。由于匿名函数保存了对getid函数的活动对象（AO）的引用，因此就会导致无法减少element的引用数。只要匿名函数存在，element引用数至少为1。所以它占用的内存就不会被回收。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getid</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> element = docuemnt.getElementById(<span class="hljs-string">&#x27;test&#x27;</span>);    element.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        alert(element.id);    &#125;&#125;</code></pre><p>不过只需要稍微改下就能够解决这个问题。将<code>element.id</code>保存在一个变量中，并且在闭包中引用这个变量消除循环引用。但仅仅还不能解决内存泄漏的问题。闭包会引用包含函数的整个活动对象，而其中包含着element。即使闭不引用element，包含函数的活动对象中也仍然会保存一个引用。因此，有必要把element设置为null。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getid</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> element = docuemnt.getElementById(<span class="hljs-string">&#x27;test&#x27;</span>);    <span class="hljs-keyword">let</span> id = element.id;    element.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        alert(id);    &#125;    element = <span class="hljs-literal">null</span>;&#125;</code></pre><h2 id="模仿块级作用域"><a href="#模仿块级作用域" class="headerlink" title="模仿块级作用域"></a>模仿块级作用域</h2><p>JavaScript是没有块级作用域的（<code>let</code>与<code>const</code>声明的变量/常量是有的）。这就意味着块语句中定义的变量，实际上是在包含函数中而非语句中创建的。</p><p>在C艹、Java等语言中，变量i只会在for循环的语句块中有定义，一旦循环结束，变量i就会被销毁。而在JS中，变量i是由函数的活动对象所定义的，使用<code>var</code>声明的变量将会在函数的AO里。并且在函数的任何位置都能访问它，即使重新声明一次，它的值也不会变。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">num</span>) </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;        <span class="hljs-built_in">console</span>.log(i);    &#125;    <span class="hljs-keyword">var</span> i;    <span class="hljs-built_in">console</span>.log(i);<span class="hljs-comment">// 10</span>    <span class="hljs-built_in">console</span>.log(i);<span class="hljs-comment">// 10</span>&#125;test(<span class="hljs-number">10</span>);</code></pre><p>在现在看来，当然是推荐使用<code>let</code>来解决这个问题了。在for循环中使用<code>let</code>声明变量就会产生块级作用域。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">num</span>) </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;        <span class="hljs-built_in">console</span>.log(i);    &#125;    <span class="hljs-built_in">console</span>.log(i);     <span class="hljs-comment">// i is not defined</span>&#125;test(<span class="hljs-number">10</span>);</code></pre><p>不过在没有<code>let</code>关键字的时候，可以使用立即执行函数来模拟块级作用域（私有作用域）。与<code>let</code>的效果一样！</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">num</span>) </span>&#123;    (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;            <span class="hljs-built_in">console</span>.log(i);        &#125;    &#125;)()    <span class="hljs-built_in">console</span>.log(i);     <span class="hljs-comment">// i is not defined</span>&#125;test(<span class="hljs-number">10</span>);</code></pre><p>JS将<code>function</code>关键字当作一个函数声明的开始，而函数声明后面不能跟园括号。然而函数表达式后面可以跟圆括号，要将函数声明转换为函数表达式，只需要加一对括号即可。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-comment">// </span>&#125;();<span class="hljs-comment">// 语法错误;</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-comment">// </span>&#125;)();</code></pre><p>模仿的块级作用域通常作用于函数外部的全局作用域，从而向全局作用域添加变量和函数，而不污染全局作用域。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;xfy&#x27;</span>;(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;yyy&#x27;</span>;    <span class="hljs-built_in">console</span>.log(name);&#125;)()<span class="hljs-comment">// yyy</span></code></pre><blockquote><p>这种做法可以减少闭包占用内存的问题，没有匿名函数的引用，只要函数执行完毕，就可以立即销毁其作用域了。</p></blockquote><h2 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h2><p>严格来说，JS是没有私有成员的概念；所有对象属性都是公开的。不过可以使用函数来实现私有变量的概念。任何在函数中定义的变量，都可以认为是私有化变量，因为在函数外部无法访问这些变量。私有变量包含函数的参数、局部变量和在函数内定义的其他函数。</p><p>在这个函数内部，有两个参数和一个局部变量。在函数的内部可以访问这些变量，而在函数外部除了主动返回之外则不能访问他们。如果在这个函数内创建一个闭包，那么这个闭包可以通过作用域链来访问到这些变量。利用这一点，就可以创建访问私有变量的共有方法。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">num1, num2</span>) </span>&#123;    <span class="hljs-keyword">let</span> result = num1 + num2;    <span class="hljs-keyword">return</span> result;&#125;</code></pre><p>可以利用构造函数的模式来创建私有和公有属性。带有this的属性将因为构造函数被返回到外部，从而形成闭包。而构造函数内部其他的没有this的属性则不会被赋予到实例上。此时就只能通过定义的公有方法来访问私有的属性。</p><p>这种有权访问私有属性的公有方法称之为<strong>特权方法</strong>（privileged method）。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>) </span>&#123;    <span class="hljs-comment">// 私有变量</span>    <span class="hljs-keyword">let</span> age = <span class="hljs-number">18</span>;    <span class="hljs-comment">// 私有方法</span>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pv</span>(<span class="hljs-params"></span>) </span>&#123;        age++;        <span class="hljs-built_in">console</span>.log(age);    &#125;    <span class="hljs-comment">// 公有方法</span>    <span class="hljs-built_in">this</span>.say = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(name);        <span class="hljs-comment">// 通过公有方法执行私有方法</span>        pv();    &#125;&#125;<span class="hljs-keyword">let</span> xfy = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;xfy&#x27;</span>);<span class="hljs-built_in">console</span>.log(xfy.name);xfy.say();</code></pre><p>因为必须要使用构造函数，且还需要在构造函数内定义方法，所以这种方法一样有着和构造函数一样的缺点，每个实例都会创建一组同样的新方法。</p><h3 id="静态私有变量"><a href="#静态私有变量" class="headerlink" title="静态私有变量"></a>静态私有变量</h3><p>直接使用构造函数会导致方法被重新定义到每个实例。解决构造函数的这个问题的方法就是将方法定义在其原型上，而为了使原型上的方法能够访问到私有化的变量，可以通过在私有作用域中定义方法。</p><p>这个方法通过在私有作用域中创建一个全局的构造函数，并且将其方法定义在原型上。当构造函数在全局时，其原型的方法依然能访问私有作用域内的私有变量。</p><p>未经声明的创建变量可以提升到全局作用域，但是在严格模式下未经声明的变量则会报错。在目前的版本，可以在全局作用域中将变量先声明，再在私有作用域中赋值。可以到达同样的效果，其原型上的方法依然继承私有作用域的活动对象。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> Person;(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-meta">    &#x27;use strict&#x27;</span>    <span class="hljs-keyword">let</span> v = <span class="hljs-number">10</span>;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pv</span>(<span class="hljs-params"></span>) </span>&#123;        v++;        <span class="hljs-built_in">console</span>.log(v);    &#125;    Person = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;    Person.prototype.say = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(v);    &#125;    Person.prototype.cha = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        pv();    &#125;&#125;)();<span class="hljs-keyword">let</span> xfy = <span class="hljs-keyword">new</span> Person();xfy.say();</code></pre><p>除了上述的静态私有变量，还有一种写法就是在构造函数内为私有变量赋值。这样创建的实例就能够共享私有变量，并且在创建是就为其赋值。</p><p>这种方式创建静态私有变量会因为使用原型而增进代码复用，但每个实例都没有自己私有变量。要使用实例变量，还是静态私有变量。最终视需求而定。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> Person;(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> name;    Person = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;        name = value;    &#125;    Person.prototype.get = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(name);    &#125;    Person.prototype.set = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;        name = value;    &#125;&#125;)()<span class="hljs-keyword">let</span> xfy = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;xfy&#x27;</span>);xfy.get();xfy.set(<span class="hljs-string">&#x27;dfy&#x27;</span>);xfy.get();</code></pre><h3 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h3><p>前面所述的方法都是为自定义类型创建私有变量和特权方法的。而道格拉斯所说的模块模式（module pattern）是为单例创建私有变量和特权方法的。所谓单例（singleton），指的就是只有一个实例的对象。</p><p>通常，JS都是以对象字面量来创建单例对象的。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> singleton = &#123;    name: value,    method: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;&#125;</code></pre><p>模块模式通过为单例添加私有变量和特权方法能够让其得到增强。</p><p>这个模块模式使用了一个返回对象的匿名函数。在这个匿名函数内部定义了私有变量和函数。然后，将一个对象字面量作为函数的值返回。在返回的字面量中定义了公开的属性和方法。因为这个字面量是在匿名函数内定义的，所以它有权访问匿名的方法和属性。从本质上来讲，这个对象字面量定义的是单例的公共接口。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> singleton = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> pv = <span class="hljs-number">10</span>;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pf</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;    <span class="hljs-keyword">return</span> &#123;        pubp: <span class="hljs-literal">true</span>,        prip: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;            pv++;            <span class="hljs-keyword">return</span> pv;        &#125;    &#125;&#125;()<span class="hljs-built_in">console</span>.log(singleton);<span class="hljs-built_in">console</span>.log(singleton.prip());</code></pre><p>这种模式在需要对单例进行某些初始化，同时又需要维护其私有变量时时非常有用的。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> app = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-comment">// 私有变量和函数</span>    <span class="hljs-keyword">let</span> con = [];    <span class="hljs-comment">// 初始化</span>    con.push(<span class="hljs-keyword">new</span> BaseCon());    <span class="hljs-comment">// 公共方法</span>    <span class="hljs-keyword">return</span> &#123;        getCon: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-keyword">return</span> con;        &#125;,        regCon: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">con</span>) </span>&#123;            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> con == <span class="hljs-string">&#x27;obejct&#x27;</span>) &#123;                con.push(con)            &#125;        &#125;    &#125;;&#125;();</code></pre><h3 id="增强的模块模式"><a href="#增强的模块模式" class="headerlink" title="增强的模块模式"></a>增强的模块模式</h3><p>有人改进了模块模式，即在返回对象之前就加入对其增强的代码。这种增强的模块模式适合那些单例必须是某种类型的实例。同时还必须添加某些属性/方法对其加以增强的情况。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> app = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-comment">// 私有变量和函数</span>    <span class="hljs-keyword">let</span> con = [];    <span class="hljs-comment">// 初始化</span>    con.push(<span class="hljs-keyword">new</span> BaseCon());    <span class="hljs-comment">// 公共方法</span>    <span class="hljs-keyword">return</span> &#123;        getCon: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-keyword">return</span> con;        &#125;,        regCon: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">con</span>) </span>&#123;            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> con == <span class="hljs-string">&#x27;obejct&#x27;</span>) &#123;                con.push(con)            &#125;        &#125;    &#125;;&#125;();</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在JavaScript编程中，函数表达式是一种非常有用的技术。使用函数表达式可以无须对函数命名，从而实现动态编程。匿名函数，也称为拉姆达函数，是一种使用JavaScript函数的强大方式。以下总结了函数表达式的特点。</p><ul><li>函数表达式不同于函数声明。函数声明要求有名字，但函数表达式不需要。没有名字的函数表达式也叫匿名函数。</li><li>在无法确定如何引用函数的情况下，递归函数就会变得比较复杂；</li><li>递归函数应该始终使用<code>arguments.callee</code>来递归地调用自身，不要使用函数名———函数名可能会发生变化。</li></ul><p>当在函数内部定义了其他函数时，就创建了闭包。闭包有权访问包含函数内部的所有变量，原理如下。</p><ul><li>在后台执行环境中，闭包的作用域链包含着它自己的作用域、包含函数的作用域和全局作用域。</li><li>通常，当函数返回一个闭包时，这个函数的作用域将会一直在内存中保存到闭包不存在为止。</li></ul><p>使用闭包可以在JavaScript中模仿块级作用域（JavaScript本身没有块级作用域的概念），要点如下。</p><ul><li>创建并立即调用一个函数，这样既可以执行其中的代码，又不会在内存中留下对该函数的引用。</li><li>结果就是函数内部的所有变量都会被立即销毁——除非某些变量赋值给了包含作用域（即外部作用域）中的变量。</li></ul><p>闭包还可以用于在对象中创建私有变量，相关概念和要点如下。</p><ul><li>即使JavaScript中没有正式的私有对象属性的概念，但可以使用闭包来实现公有方法，而通过公有方法可以访问在包含作用域中定义的变量。</li><li>有权访问私有变量的公有方法叫做特权方法。</li><li>可以使用构造函数模式、原型模式来实现自定义类型的特权方法，也可以使用模块模式、增强的模块模式来实现单例的特权方法。</li></ul><p>JavaScript中的函数表达式和闭包都是极其有用的特性，利用它们可以实现很多功能。不过，因为创建闭包必须维护额外的作用域，所以过度使用它们可能会占用大量内存。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Can&#39;t install gifsicle</title>
    <link href="/defect/cant-install-gifsicle.html"/>
    <url>/defect/cant-install-gifsicle.html</url>
    
    <content type="html"><![CDATA[<h2 id="Hexo-all-minifier"><a href="#Hexo-all-minifier" class="headerlink" title="Hexo-all-minifier"></a>Hexo-all-minifier</h2><p>In a long time, i’m used to Hexo-all-minifier to optimization blog. But recently i can’t even install it.</p><p>The error logs with <code>npm install</code>:</p><pre><code class="hljs bash">  ‼ getaddrinfo ENOENT raw.githubusercontent.com  ‼ gifsicle pre-build <span class="hljs-built_in">test</span> failed  i compiling from <span class="hljs-built_in">source</span>  × Error: Command failed: C:\WINDOWS\system32\cmd.exe /s /c <span class="hljs-string">&quot;autoreconf -ivf&quot;</span><span class="hljs-string">&#x27;autoreconf&#x27;</span> �����ڲ����ⲿ���Ҳ���ǿ����еĳ������������ļ���</code></pre><p>In the beginning, i thought the problem is my windows can’t run autoconf. So, i tried installing cygwin, And that is difficult for me. I never tried to installed cygwin.</p><p>Anyway, i installed successfully. But the problem has not solved. There is still has the errors with npm install .</p><h2 id="imagemin-gifsicle"><a href="#imagemin-gifsicle" class="headerlink" title="imagemin-gifsicle"></a>imagemin-gifsicle</h2><p>The problem appeared when installing gifsicle, The Hexo-all-minifier used it too. So, the best way is go to the gifsicle issues. As predicted, there is someone got the same errors. </p><p>Be unexpected, It’s not a problem with windows or autoconf. That is network problem🌚. </p><pre><code class="hljs bash">‼ getaddrinfo ENOENT raw.githubusercontent.com‼ gifsicle pre-build <span class="hljs-built_in">test</span> failed</code></pre><p>As in above two lines, the problem is can’t connect with <code>githubusercontent.com</code>.</p><h2 id="Best-way"><a href="#Best-way" class="headerlink" title="Best way"></a>Best way</h2><p>Write domain with ip into the hosts. That is best way to connect with github and other domains.</p><pre><code class="hljs accesslog"><span class="hljs-number">52.74.223.119</span>     github.com<span class="hljs-number">192.30.253.119</span>    gist.github.com<span class="hljs-number">54.169.195.247</span>    api.github.com<span class="hljs-number">185.199.111.153</span>   assets-cdn.github.com<span class="hljs-number">151.101.76.133</span>    raw.githubusercontent.com<span class="hljs-number">151.101.76.133</span>    gist.githubusercontent.com<span class="hljs-number">151.101.76.133</span>    cloud.githubusercontent.com<span class="hljs-number">151.101.76.133</span>    camo.githubusercontent.com<span class="hljs-number">151.101.76.133</span>    avatars0.githubusercontent.com<span class="hljs-number">151.101.76.133</span>    avatars1.githubusercontent.com<span class="hljs-number">151.101.76.133</span>    avatars2.githubusercontent.com<span class="hljs-number">151.101.76.133</span>    avatars3.githubusercontent.com<span class="hljs-number">151.101.76.133</span>    avatars4.githubusercontent.com<span class="hljs-number">151.101.76.133</span>    avatars5.githubusercontent.com<span class="hljs-number">151.101.76.133</span>    avatars6.githubusercontent.com<span class="hljs-number">151.101.76.133</span>    avatars7.githubusercontent.com<span class="hljs-number">151.101.76.133</span>    avatars8.githubusercontent.com</code></pre><p>Then, try<code>npm cache clean -f</code>and<code>ipconfig/flushdns</code>.</p><p>As long as can ping with github domains, the problem will be solved.</p><p>The <code>Command failed</code> just write some ips for hosts, then <code>npm install</code> will be worked.</p><p>So, </p><p><img src="../images/Can't%20install%20gifsicle/%E6%89%B9%E6%B3%A8%202020-08-04%20135700.webp" alt="批注 2020-08-04 135700"></p><p>enjoy it.</p>]]></content>
    
    
    <categories>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript面向对象的程序设计</title>
    <link href="/defect/javascript-object-oriented-programming.html"/>
    <url>/defect/javascript-object-oriented-programming.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>Standing on Shoulders of Giants.</p><p>本篇参考与《JavaScript高级程序设计》第六章：面向对象的程序设计。</p></blockquote><p>面向对象（Object-Oriented，OO）的语言都有一个标志，那就是他们都有类的概念。通过类来创建任意多个具有相同属性和方法的对象。</p><p>ECMAScript中没有类的概念，所以它的对象也与基于类的语言中的对象有所不同。</p><p>ECMAScript-262的对象定义为：“无序属性的集合，其属性可以是基本值、对象和函数。”也就是说对象是一个没有属性的键值映射对，其值可以是数据和函数。</p><p><img src="../images/JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/logo.webp" alt="logo"></p><h2 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h2><p>虽然在JavaScript中不能直接访问属性类型，但是为了表示特性是内部值，ECMA-262将其放在了两对方括号中。</p><p><strong>ECMAScript中有两种属性：数据属性和访问器类型属性。</strong></p><ul><li>[[Configurable]]：表示能否通过delete删除属性从而定义属性，能否修改属性特性，或者能否把属性修改为访问器属性。默认为true</li><li>[[Enumerable]]：表示能否通过for-in循环返回属性。默认为true</li><li>[[Writable]]：表示能否修改属性的值。默认为true</li><li>[[Value]]：包含这个属性的数据值。读取属性的时候从这个位置读取，写入属性值的时候把新值保存在这个位置。默认值为undefined</li></ul><p>使用对象字面量创建一个对象时，上述四个特性都为true。value则为属性的值。</p><h3 id="修改属性的默认特性"><a href="#修改属性的默认特性" class="headerlink" title="修改属性的默认特性"></a>修改属性的默认特性</h3><p>要修改默认的特性必须要使用ECMAScritpt5的<code>Object.prototype.defineProperty()</code>方法。</p><p>Syntax：</p><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.defineProperty(obj, prop, descriptor)</code></pre><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;    name: <span class="hljs-string">&#x27;xfy&#x27;</span>,    age: <span class="hljs-number">18</span>,    saySomthing: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);    &#125;&#125;<span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;name&#x27;</span>, &#123;    writable: <span class="hljs-literal">false</span>,    value: <span class="hljs-string">&#x27;xxxxfy&#x27;</span>,    configurable: <span class="hljs-literal">false</span>&#125;)</code></pre><blockquote><p>将configurable修改为false之后就无法再进行配置了，也就说无法再修改回来了。其他特性都是可以再修改的。</p></blockquote><h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><p>为对象设置一个访问器的属性，这个属性不包含数据值，它包含一对setter和getter函数（不是必需的）。在读取这个访问器属性时，会调用getter函数。在写入这个访问器属性时，会调用setter函数。setter决定了如何处理数据。</p><p>访问器属性具有如下4个值：</p><ul><li>[[Configurable]]：表示能否通过delete删除属性从而定义属性，能否修改属性特性，或者能否把属性修改为访问器属性。默认为true</li><li>[[Enumerable]]：表示能否通过for-in循环返回属性。默认为true</li><li>[[Get]]：在读取属性时调用的函数。默认为undefined</li><li>[[Set]]：在写入属性时调用的函数。默认为undefined</li></ul><p>访问器属性不能直接定义，必须使用<code>Object.defineProperty()</code>方法来定义。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;zero&#x27;</span>, <span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-string">&#x27;three&#x27;</span>, <span class="hljs-string">&#x27;four&#x27;</span>, <span class="hljs-string">&#x27;five&#x27;</span>, <span class="hljs-string">&#x27;six&#x27;</span>, <span class="hljs-string">&#x27;seven&#x27;</span>, <span class="hljs-string">&#x27;eight&#x27;</span>, <span class="hljs-string">&#x27;nine&#x27;</span>, <span class="hljs-string">&#x27;ten&#x27;</span>];<span class="hljs-keyword">let</span> xbox = &#123;    _name: <span class="hljs-string">&#x27;xbox &#x27;</span>,    _year: <span class="hljs-number">2020</span>,    edition: arr[<span class="hljs-number">1</span>],    name: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._name + <span class="hljs-built_in">this</span>.edition;    &#125;&#125;<span class="hljs-built_in">console</span>.log(xbox.name());<span class="hljs-built_in">Object</span>.defineProperty(xbox, <span class="hljs-string">&#x27;year&#x27;</span>, &#123;    get: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-comment">// 返回对象方法访问的属性</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._year;    &#125;,    set: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;        <span class="hljs-comment">// 值不小于2020且不大于2030（因为数组就10个🤣）</span>        <span class="hljs-keyword">if</span> (!(value &lt; <span class="hljs-number">2020</span>) &amp;&amp; !(value &gt; <span class="hljs-number">2030</span>)) &#123;            <span class="hljs-comment">// 根据值判断版本，并在数组取值</span>            <span class="hljs-built_in">this</span>.edition = arr[value - <span class="hljs-built_in">this</span>._year + <span class="hljs-number">1</span>];            <span class="hljs-comment">// 将属性访问的方法同时也设置</span>            <span class="hljs-built_in">this</span>._year = value;        &#125;    &#125;&#125;)xbox.year = <span class="hljs-number">2021</span>;<span class="hljs-built_in">console</span>.log(xbox.year);<span class="hljs-built_in">console</span>.log(xbox.name());<span class="hljs-comment">// PlayStation？</span><span class="hljs-keyword">let</span> ps = &#123;    _name: <span class="hljs-string">&#x27;PlayStation &#x27;</span>,    _year: <span class="hljs-number">2020</span>,    edition: <span class="hljs-number">4</span>,    name: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._name + <span class="hljs-built_in">this</span>.edition;    &#125;&#125;<span class="hljs-built_in">Object</span>.defineProperty(ps, <span class="hljs-string">&#x27;year&#x27;</span>, &#123;    get: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-comment">// 返回对象方法访问的属性</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._year;    &#125;,    set: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;        <span class="hljs-comment">// 值不小于2020且不大于2030（xbox也10个🤣）</span>        <span class="hljs-keyword">if</span> (!(value &lt; <span class="hljs-number">2020</span>) &amp;&amp; !(value &gt; <span class="hljs-number">2030</span>)) &#123;            <span class="hljs-comment">// 根据值判断版本，并加上基础版本：4</span>            <span class="hljs-built_in">this</span>.edition = value - <span class="hljs-built_in">this</span>._year + <span class="hljs-number">4</span>;            <span class="hljs-comment">// 将属性访问的方法同时也设置</span>            <span class="hljs-built_in">this</span>._year = value;        &#125;    &#125;&#125;)ps.year = <span class="hljs-number">2021</span><span class="hljs-built_in">console</span>.log(ps.name());</code></pre><p>访问器属性还有一个能够同时定义多个属性的方法。与单个定义对象相同，唯一区别是这里的属性都是同一时间创建的。</p><pre><code class="hljs js"><span class="hljs-comment">// 同时定义多个属性</span><span class="hljs-keyword">let</span> ps = &#123;&#125;;<span class="hljs-built_in">Object</span>.defineProperties(ps, &#123;    _name: &#123;        value: <span class="hljs-string">&#x27;PlayStation&#x27;</span>,        writable: <span class="hljs-literal">true</span>,        configurable: <span class="hljs-literal">true</span>    &#125;,    _year: &#123;        value: <span class="hljs-number">2020</span>,        writable: <span class="hljs-literal">true</span>,        configurable: <span class="hljs-literal">true</span>    &#125;,    edition: &#123;        value: <span class="hljs-number">4</span>,        writable: <span class="hljs-literal">true</span>,        configurable: <span class="hljs-literal">true</span>    &#125;,    name: &#123;        value: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._name + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-built_in">this</span>.edition;        &#125;,        writable: <span class="hljs-literal">true</span>,        configurable: <span class="hljs-literal">true</span>    &#125;,    year: &#123;        get: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._year;        &#125;,        set: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;            <span class="hljs-keyword">if</span> (!(value &lt; <span class="hljs-number">2020</span>) &amp;&amp; !(value &gt; <span class="hljs-number">2030</span>)) &#123;                <span class="hljs-built_in">this</span>.edition = value - <span class="hljs-built_in">this</span>._year + <span class="hljs-number">4</span>;                <span class="hljs-built_in">this</span>._year = value;            &#125;        &#125;    &#125;&#125;)</code></pre><h3 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h3><p>属性的特性可以很方便的设置，当然也可以方便的读取。使用ECMAScript5的<code>Object.getOwnPropertyDescriptor()</code>方法就可以读取属性的特性。</p><p>继上述案例：</p><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(ps, <span class="hljs-string">&#x27;year&#x27;</span>);<span class="hljs-comment">// 输出：</span><span class="hljs-comment">// configurable: false</span><span class="hljs-comment">// enumerable: false</span><span class="hljs-comment">// get: function get()</span><span class="hljs-comment">// set: function set(value)</span><span class="hljs-comment">// &lt;prototype&gt;: Object &#123; … &#125;</span></code></pre><p>可以详细的看到属性的特性。</p><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(ps, <span class="hljs-string">&#x27;_year&#x27;</span>).value<span class="hljs-comment">// 2021</span></code></pre><blockquote><p>在JavaScript中可以针对任何对象–包括DOM和BOM对象使用<code>Object.getOwnPropertyDescriptor()</code>方法。</p></blockquote><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>使用Object构造函数和对象字面量可以用来创建单个对象。但是这些方法都不能使用同一个接口创建大量的对象。</p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>工厂模式应该是软件设计领域中一种广为人知的设计模式。但是在ECMAScript中无法创建类，早期的人们使用一种函数，来封装以特定接口创建对象的细节。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createOne</span>(<span class="hljs-params">name, age, sex</span>) </span>&#123;    <span class="hljs-keyword">let</span> o = &#123;&#125;;    o.name = name;    o.age = age;    o.sex = sex;    o.say = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);    &#125;    <span class="hljs-keyword">return</span> o;&#125;<span class="hljs-keyword">let</span> person1 = createOne(<span class="hljs-string">&#x27;xfy&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;male&#x27;</span>);<span class="hljs-keyword">let</span> person2 = createOne(<span class="hljs-string">&#x27;dfy&#x27;</span>, <span class="hljs-number">81</span>, <span class="hljs-string">&#x27;female&#x27;</span>);<span class="hljs-built_in">console</span>.log(person1);<span class="hljs-built_in">console</span>.log(person2);</code></pre><p>工厂模式在函数内显式的创建一个空对象，然后让函数的参数传为对象属性。最后返回函数。这样就可以多次调用这个函数来创建多个相似对象。但这样却无法解决对象试别的问题。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>像<code>Object()</code>和<code>Array()</code>都是原生的构造函数。在现在，可以创建自定义的构造函数，从而自定义对象类型的属性和方法。</p><p>重写上述工厂模式：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">One</span>(<span class="hljs-params">name, age, sex</span>) </span>&#123;    <span class="hljs-built_in">this</span>.name = name;    <span class="hljs-built_in">this</span>.age = age;    <span class="hljs-built_in">this</span>.sex = sex;&#125;<span class="hljs-keyword">let</span> person1 = <span class="hljs-keyword">new</span> One(<span class="hljs-string">&#x27;xfy&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;female&#x27;</span>);<span class="hljs-keyword">let</span> person2 = <span class="hljs-keyword">new</span> One(<span class="hljs-string">&#x27;dfy&#x27;</span>, <span class="hljs-number">81</span>, <span class="hljs-string">&#x27;male&#x27;</span>);<span class="hljs-built_in">console</span>.log(person1);<span class="hljs-built_in">console</span>.log(person2);</code></pre><p>使用构造函数创建对象必须使用new操作符。此外构造函数的函数名通常为首字母大写，非构造函数首字母小写。这个做法借鉴自其他OO语言。</p><p>使用构造函数创建的对象，constructor都指向这个构造函数。</p><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(person1.constructor);<span class="hljs-comment">// function One(name, age, sex) &#123; … &#125;</span></code></pre><p>这就是构造函数胜过工厂模式的一个地方，工厂模式无法将其实例标记为一种特定的类型。在工厂模式下创建的实例，constructor都将指向<code>Object()</code>这个构造函数，因为工厂模式返回的对象是显式创建的，它继承自Object。</p><h4 id="内部原理"><a href="#内部原理" class="headerlink" title="内部原理"></a>内部原理</h4><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Make</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;xfy&#x27;</span>;&#125;</code></pre><p>一个构造函数在生成时使用<code>new</code>操作符，此时的函数内部隐式的声明了一个对象：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Make</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-comment">// this = &#123;&#125;;</span>    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;xfy&#x27;</span>;&#125;</code></pre><p>有了this这个对象之后，函数的作用域赋给新对象（所以this指向了这个对象）：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Make</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-comment">// this = &#123;</span>    <span class="hljs-comment">// name : &#x27;xfy&#x27;</span><span class="hljs-comment">// &#125;;</span>    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;xfy&#x27;</span>;&#125;</code></pre><p>最后再隐式的return this：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Make</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-comment">// this = &#123;</span>    <span class="hljs-comment">// name : &#x27;xfy&#x27;</span><span class="hljs-comment">// &#125;;</span>    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;xfy&#x27;</span>;    <span class="hljs-comment">// return this;</span>&#125;</code></pre><p>总结四步：</p><ol><li>隐式的创建一个新对象；</li><li>将构造函数的作用域赋值给新对象（this指向）；</li><li>执行构造函数内的代码（添加属性）；</li><li>返回新对象；</li></ol><p>也就是说可以不使用<code>new</code>来使用一个构造函数（工厂模式）：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Xfy</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> that = &#123;&#125;;    that.name = <span class="hljs-string">&#x27;xfy&#x27;</span>;    that.age = <span class="hljs-number">18</span>;    <span class="hljs-keyword">return</span> that;&#125;<span class="hljs-keyword">let</span> xfy = Xfy();</code></pre><p>不赋值给一个对象，直接返回执行的结果：</p><pre><code class="hljs js"><span class="hljs-keyword">new</span> Person().say();</code></pre><p>若给构造函数显示的返回了一个空对象，则显示的返回优先级高于隐式的返回结果：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Make</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;xfy&#x27;</span>;    <span class="hljs-keyword">return</span> &#123;&#125;;&#125;</code></pre><p>但是如果显示的返回不是对象值，而是一个基本值，则构造函数不会收到影响：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Make</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;xfy&#x27;</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">123</span>;  <span class="hljs-comment">// 不受影响</span>&#125;</code></pre><h4 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h4><p>构造函数也是函数，它也能当作普通函数来使用。在全局作用域下，直接使用构造函数将会使其this指向全局对象。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">One</span>(<span class="hljs-params">name, age, sex</span>) </span>&#123;    <span class="hljs-built_in">this</span>.name = name;    <span class="hljs-built_in">this</span>.age = age;    <span class="hljs-built_in">this</span>.sex = sex;&#125;One(<span class="hljs-string">&#x27;xfy&#x27;</span>);<span class="hljs-built_in">window</span>.name<span class="hljs-comment">// &quot;xfy&quot;</span></code></pre><p>所以可以将构造函数使用call/apply来调用：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123;&#125;;One.call(obj, <span class="hljs-string">&#x27;xfy&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;female&#x27;</span>);<span class="hljs-built_in">console</span>.log(obj);</code></pre><p>那么自然多个构造函数也可以互相利用，使用call/apply来改变调用函数的this为当前构造函数的this就可以利用上已经写过的代码。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Two</span>(<span class="hljs-params">name, age, sex, say</span>) </span>&#123;    One.call(<span class="hljs-built_in">this</span>, name, age, sex);    <span class="hljs-built_in">this</span>.say = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(say);    &#125;&#125;<span class="hljs-keyword">let</span> two = <span class="hljs-keyword">new</span> Two(<span class="hljs-string">&#x27;xfy&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;female&#x27;</span>, <span class="hljs-string">&#x27;嘤嘤嘤&#x27;</span>);<span class="hljs-built_in">console</span>.log(two.say());</code></pre><h3 id="构造函数的问题"><a href="#构造函数的问题" class="headerlink" title="构造函数的问题"></a>构造函数的问题</h3><p>构造函数虽然好用，但也并非没有缺点。构造函数的主要问题就是每个方法都要在实例上重新创建一遍。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Two</span>(<span class="hljs-params">name, age, sex, say</span>) </span>&#123;    One.call(<span class="hljs-built_in">this</span>, name, age, sex);    <span class="hljs-built_in">this</span>.say = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(say);    &#125;    <span class="hljs-comment">// this.say = new Function(&#x27;console.log(say)&#x27;)</span>&#125;<span class="hljs-keyword">let</span> two = <span class="hljs-keyword">new</span> Two(<span class="hljs-string">&#x27;xfy&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;female&#x27;</span>, <span class="hljs-string">&#x27;嘤嘤嘤&#x27;</span>);<span class="hljs-keyword">let</span> two1 = <span class="hljs-keyword">new</span> Two(<span class="hljs-string">&#x27;xfy&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;female&#x27;</span>, <span class="hljs-string">&#x27;咕咕咕&#x27;</span>);<span class="hljs-built_in">console</span>.log(two.say === two1.say);</code></pre><p>继上述例子中，每个构造函数内都包含一个不同的Function实例。以这种方式创建函数，会导致不同的作用域链和标识解析符。但创建Function新实例的机制任然是相同的。所以导致由构造函数创建的实例的方法只是同名而不相等。</p><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(two.say === two1.say);<span class="hljs-comment">// false</span></code></pre><p>创建这样两个完成相同任务的Function实例根本没有必要；况且有this对象存在，根本不用在执行代码前就把函数绑定到特定的对象上面。</p><p>所以可以考虑将特定的方法转移出构造函数内部来解决这个问题</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Two</span>(<span class="hljs-params">name, age, sex, say</span>) </span>&#123;    One.call(<span class="hljs-built_in">this</span>, name, age, sex);    <span class="hljs-built_in">this</span>.say = say;    <span class="hljs-built_in">this</span>.saySome = saySome;&#125;<span class="hljs-keyword">let</span> two = <span class="hljs-keyword">new</span> Two(<span class="hljs-string">&#x27;xfy&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;female&#x27;</span>, <span class="hljs-string">&#x27;嘤嘤嘤&#x27;</span>);<span class="hljs-keyword">let</span> two1 = <span class="hljs-keyword">new</span> Two(<span class="hljs-string">&#x27;xfy&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&#x27;female&#x27;</span>, <span class="hljs-string">&#x27;咕咕咕&#x27;</span>);<span class="hljs-built_in">console</span>.log(two.saySome);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">saySome</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.say);&#125;</code></pre><p>在构造函数的内部将方法指定为外部的全局函数，这样saySome包含的是一个函数的指针，因此创建出的对象的方法就共享了在全局作用域中定义的同一个函数。这样就能解决两个函数做同一件事的问题。当然这样还无法解决所有问题，如果对象需要很多的方法，那么就需要在全局作用域定义很多的函数，于是这个自定义的引用类型就毫无封装性可言了。</p><p>好在，原型模式可以帮我们解决这些问题。</p><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>每创建一个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象。这个对象的好处就在于可以包含特定类型的所有实例共享的方法和属性。也就是说，构造函数的prototype（原型）这个对象的属性，可以包含到所有由这个构造函数创建的实例上。</p><p>这样，上述出现的全局函数不需要去污染全局环境，可以定义在原型上。另外，一些固有的属性也可以直接放在原型上。</p><pre><code class="hljs js">Two.prototype.name = <span class="hljs-string">&#x27;xfy&#x27;</span>;Two.prototype.age = <span class="hljs-number">18</span>;Two.prototype.saySome = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.say);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Two</span>(<span class="hljs-params">sex, say</span>) </span>&#123;    <span class="hljs-built_in">this</span>.sex = sex;    <span class="hljs-built_in">this</span>.say = say;&#125;<span class="hljs-keyword">let</span> two = <span class="hljs-keyword">new</span> Two(<span class="hljs-string">&#x27;female&#x27;</span>, <span class="hljs-string">&#x27;嘤嘤嘤&#x27;</span>);<span class="hljs-keyword">let</span> two1 = <span class="hljs-keyword">new</span> Two(<span class="hljs-string">&#x27;male&#x27;</span>, <span class="hljs-string">&#x27;咕咕咕&#x27;</span>);<span class="hljs-built_in">console</span>.log(two.saySome);</code></pre><h3 id="理解原型对象"><a href="#理解原型对象" class="headerlink" title="理解原型对象"></a>理解原型对象</h3><p>无论在何时，只要创建了一个新的函数，就会根据一组特定规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。在默认情况下，原型对象会自动获得一个constructor属性。这个属性指向prototype属性所在函数的指针。也就是说指向构造函数本身<code>Two.prototype.constructor = Two</code>。</p><p>创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性。其他的方法都是由Object继承而来。当使用构造函数创建新实例后，这个实例会包含一个指针（内部属性），指向构造函数的原型。ECMA-262第5版管这个指针叫做[[Prototype]]。虽然在js中没有标准访问[[Prototype]]的方法。但在多数浏览器中都支持一个属性：<code>__proto__</code>。</p><p>不过真正要明确的是，这个连接只存在与实例与构造函数的原型对象之间，而不存在与实例与构造函数之间。</p><pre><code class="hljs js">(Two Prototype)Two.prototype --&gt; Two.prototypetwo1.__proto__ --&gt; Two.prototype</code></pre><p>所有在原型上的属性与方法都能被创建的实例所调用。这是通过查找对象属性的过程来实现的。就和作用域链类似，在实例上没有找到的属性会继续向上至原型链查找。</p><p>有两种方法来检测/访问到实例的原型对象：<code>isPrototypeOf()</code>和<code>Object.getPrototypeOf()</code>。</p><ul><li><code>isPrototypeOf()</code>用来检测函数是否是实例的原型；</li><li><code>Object.getPrototypeOf()</code>返回的就是实例的原型；</li></ul><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(Two.prototype.isPrototypeOf(two));<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getPrototypeOf(two) == Two.prototype);</code></pre><blockquote><p>constructor属性也是共享的，可以通过实例对象访问。</p></blockquote><h3 id="无法重写"><a href="#无法重写" class="headerlink" title="无法重写"></a>无法重写</h3><p>实例无法重写原型上的属性。虽然对象实例可以访问原型，但是对于原型上的属性的增、删操作都是不可以的。如果对象实例上设置了一个和原型属性同名的属性，那么就会优先访问实例本身的属性。</p><pre><code class="hljs js">Two.prototype.name = <span class="hljs-string">&#x27;xfy&#x27;</span>;Two.prototype.age = <span class="hljs-number">18</span>;Two.prototype.saySome = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.say);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Two</span>(<span class="hljs-params">sex, say</span>) </span>&#123;    <span class="hljs-built_in">this</span>.sex = sex;    <span class="hljs-built_in">this</span>.say = say;&#125;<span class="hljs-keyword">let</span> two = <span class="hljs-keyword">new</span> Two(<span class="hljs-string">&#x27;female&#x27;</span>, <span class="hljs-string">&#x27;嘤嘤嘤&#x27;</span>);<span class="hljs-keyword">let</span> two1 = <span class="hljs-keyword">new</span> Two(<span class="hljs-string">&#x27;male&#x27;</span>, <span class="hljs-string">&#x27;咕咕咕&#x27;</span>);two.name = <span class="hljs-string">&#x27;dfy&#x27;</span>;<span class="hljs-built_in">console</span>.log(two.name);<span class="hljs-comment">// dfy</span><span class="hljs-built_in">console</span>.log(two1.name);<span class="hljs-comment">// xfy</span></code></pre><p>就相当于屏蔽了实例去访问原型上的同名属性，即使将实例本身的属性设置为null也不会恢复其指向原型的连接。不过使用delete操作符删除这个属性后，就能重新访问原型上的属性。</p><pre><code class="hljs js">two.name = <span class="hljs-string">&#x27;dfy&#x27;</span>;<span class="hljs-built_in">console</span>.log(two.name);<span class="hljs-comment">// dfy</span><span class="hljs-keyword">delete</span> two.name;<span class="hljs-built_in">console</span>.log(two.name);<span class="hljs-comment">// xfy</span></code></pre><p>当然它也有检测的方法：<code>hasOwnProperty()</code>。</p><pre><code class="hljs js">two.name = <span class="hljs-string">&#x27;dfy&#x27;</span>;<span class="hljs-built_in">console</span>.log(two.hasOwnProperty(<span class="hljs-string">&#x27;name&#x27;</span>));<span class="hljs-comment">// true</span><span class="hljs-keyword">delete</span> two.name;<span class="hljs-built_in">console</span>.log(two.hasOwnProperty(<span class="hljs-string">&#x27;name&#x27;</span>));<span class="hljs-comment">// false</span></code></pre><h3 id="in操作符"><a href="#in操作符" class="headerlink" title="in操作符"></a>in操作符</h3><p>in操作符可以单独使用和在for-in循环中使用。在单独使用时，in用于检测给定的属性通过对象能否访问，无论是继承还是自有属性。</p><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;saySome&#x27;</span> <span class="hljs-keyword">in</span> two);</code></pre><p>配合<code>hasOwnProperty()</code>来使用就能检测属性是否是继承来的。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inheritProperty</span>(<span class="hljs-params">target, prep</span>) </span>&#123;    <span class="hljs-keyword">return</span> !target.hasOwnProperty(prep) &amp;&amp; (prep <span class="hljs-keyword">in</span> target);<span class="hljs-comment">// 不是自有属性，同时能够访问</span>&#125;</code></pre><p>for-in循环会便利所有能访问、可枚举(enumerated)的属性。无论是否是继承来的属性。另外，屏蔽了原型中不能枚举的实例属性也能在for-in循环中返回。因为根据规定，所有开发人员定义的属性都是可枚举的。（只有IE8及更早的版本除外）</p><p>这里的two实例重写了<code>toString()</code>方法，可以被for-in循环遍历出来。</p><p><img src="../images/JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/image-20200726171729248.webp" alt="image-20200726171729248"></p><p>若要更方便的取出实例的自有属性，可以使用<code>Object.keys()</code>方法。它会返回所有自有的可枚举的属性。返回结果为一个数组，出现顺序与for-in循环相同。</p><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.keys(two)<span class="hljs-comment">// Array(3) [ &quot;sex&quot;, &quot;say&quot;, &quot;toString&quot; ]</span></code></pre><p>可以使用<code>Object.getOwnPropertyNames()</code>来访问所有属性，包括不可枚举的属性</p><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.getOwnPropertyNames(Two.prototype)<span class="hljs-comment">// vArray(4) [ &quot;constructor&quot;, &quot;name&quot;, &quot;age&quot;, &quot;saySome&quot; ]</span></code></pre><h3 id="更简单的原型语法"><a href="#更简单的原型语法" class="headerlink" title="更简单的原型语法"></a>更简单的原型语法</h3><p>前面给原型添加属性都是一行一行的写的，每添加一个属性都要<code>Two.prototype</code>一遍。为了减少输入，常见的做法是使用对象字面量来重写整个原型对象。</p><pre><code class="hljs js">Two.prototype = &#123;    name: <span class="hljs-string">&#x27;xfy&#x27;</span>,    age: <span class="hljs-number">18</span>,    saySome: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.say);    &#125;&#125;</code></pre><p>将构造函数的prototype以对象字面量形式重新创建一个对象。最终结果没有任何变化，除了constructor不在指向这个构造函数以外。因为重写了prototype，所有constructor也就不存在了。</p><p>可以手动将constructor设置为正确是值，但此时的constructor就会变为可枚举的属性。在支持ECMAScript5的环境下，可以再手动设置为不可枚举的属性。</p><pre><code class="hljs js">Two.prototype = &#123;    name: <span class="hljs-string">&#x27;xfy&#x27;</span>,    age: <span class="hljs-number">18</span>,    saySome: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.say);    &#125;&#125;<span class="hljs-built_in">Object</span>.defineProperty(Two.prototype, <span class="hljs-string">&#x27;constructor&#x27;</span>, &#123;    enumerable: <span class="hljs-literal">false</span>,    value: Two&#125;)</code></pre><h3 id="原型的动态性"><a href="#原型的动态性" class="headerlink" title="原型的动态性"></a>原型的动态性</h3><p>由于在原型中查找值的过程是一次搜索，所以可以随时的修改原型的属性，并立即的在实例上反应出来。即使是先创建了实例再修改的原型也是如此。</p><p>实例与原型之间的连接不过是一个指针，而非一个副本。因此在后面的语句中可以找到新的属性。</p><pre><code class="hljs js">Two.prototype = &#123;    name: <span class="hljs-string">&#x27;xfy&#x27;</span>,    age: <span class="hljs-number">18</span>,    saySome: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.say);    &#125;&#125;<span class="hljs-built_in">Object</span>.defineProperty(Two.prototype, <span class="hljs-string">&#x27;constructor&#x27;</span>, &#123;    enumerable: <span class="hljs-literal">false</span>,    value: Two&#125;)<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Two</span>(<span class="hljs-params">sex, say</span>) </span>&#123;    <span class="hljs-built_in">this</span>.sex = sex;    <span class="hljs-built_in">this</span>.say = say;&#125;<span class="hljs-keyword">let</span> two = <span class="hljs-keyword">new</span> Two(<span class="hljs-string">&#x27;female&#x27;</span>, <span class="hljs-string">&#x27;嘤嘤嘤&#x27;</span>);<span class="hljs-keyword">let</span> two1 = <span class="hljs-keyword">new</span> Two(<span class="hljs-string">&#x27;male&#x27;</span>, <span class="hljs-string">&#x27;咕咕咕&#x27;</span>);<span class="hljs-built_in">console</span>.log(two.name);Two.prototype.name = <span class="hljs-string">&#x27;xxxfy&#x27;</span>;<span class="hljs-built_in">console</span>.log(two.name);</code></pre><p>尽管原型可以随时的修改属性和方法，并且能够在所有对象实例中立即反应出来。但是如果重写整个原型对象，那么情况就不一样了。</p><p>在调用构造函数时会为实例添加一个<strong>指向最初原型</strong>的[[prototype]]指针，而重写整个原型对象之后，就相当于切断了构造函数与最初原型之间的联系。实例中的指向仅指向原型，而不指向构造函数。</p><p>所以在实例之后重写整个原型并不会生效，且<strong>实例的指针还是指向最初的原型</strong>。</p><pre><code class="hljs js">Two.prototype.name = <span class="hljs-string">&#x27;xxxfy&#x27;</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Two</span>(<span class="hljs-params">sex, say</span>) </span>&#123;    <span class="hljs-built_in">this</span>.sex = sex;    <span class="hljs-built_in">this</span>.say = say;&#125;<span class="hljs-keyword">let</span> two = <span class="hljs-keyword">new</span> Two(<span class="hljs-string">&#x27;female&#x27;</span>, <span class="hljs-string">&#x27;嘤嘤嘤&#x27;</span>);<span class="hljs-keyword">let</span> two1 = <span class="hljs-keyword">new</span> Two(<span class="hljs-string">&#x27;male&#x27;</span>, <span class="hljs-string">&#x27;咕咕咕&#x27;</span>);<span class="hljs-built_in">console</span>.log(two.name);<span class="hljs-comment">// xxxfy</span><span class="hljs-built_in">console</span>.log(two.constructor);Two.prototype = &#123;    name: <span class="hljs-string">&#x27;xfy&#x27;</span>,    age: <span class="hljs-number">18</span>,    saySome: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.say);    &#125;&#125;<span class="hljs-built_in">Object</span>.defineProperty(Two.prototype, <span class="hljs-string">&#x27;constructor&#x27;</span>, &#123;    enumerable: <span class="hljs-literal">false</span>,    value: Two&#125;)</code></pre><h3 id="原生对象的原型"><a href="#原生对象的原型" class="headerlink" title="原生对象的原型"></a>原生对象的原型</h3><p>毫不意外的，原生的引用类似也是采用这种模式。可以像修改自定义对象的原型一样修改原生对象的原型。</p><p>由于声明了一个字符串变量，那么后台就会自动调用String来基本包装这个字符串，因此str这个变量可以直接调用String原型上的方法。</p><pre><code class="hljs js"><span class="hljs-built_in">String</span>.prototype.yyy = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;嘤嘤嘤&#x27;</span>;&#125;<span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;xfy&#x27;</span>;<span class="hljs-built_in">console</span>.log(str.yyy());</code></pre><p>原生对象的原型是可以被重写的。</p><h3 id="原型对象的问题"><a href="#原型对象的问题" class="headerlink" title="原型对象的问题"></a>原型对象的问题</h3><p>原型虽然很大程度上解决了很多问题，但它也是有缺点的。首先它省略了为构造函数传递初始化参数这一环节，导致了所有实例再默认情况下都将取得相同的属性值。但这并不是主要问题，主要问题还是其共享性的特征导致的。</p><p>对于函数来说，这种共享性特别合适。对于包含基本值的属性也还行。但是对于引用值来说，就有很大的问题了。</p><p>通过该构造函数创建的两个实例，当一个实例修改了原型上的引用值时，另一个实例也被一起更改。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;&#125;Person.prototype = &#123;    name: <span class="hljs-string">&#x27;xfy&#x27;</span>,    age: <span class="hljs-number">18</span>,    job: <span class="hljs-literal">null</span>,    consoles: [<span class="hljs-string">&#x27;xbox&#x27;</span>, <span class="hljs-string">&#x27;playstation&#x27;</span>],    sayName: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);    &#125;&#125;<span class="hljs-built_in">Object</span>.defineProperty(Person.prototype, <span class="hljs-string">&#x27;constructor&#x27;</span>, &#123;    enumerable: <span class="hljs-literal">false</span>,    value: Person&#125;)<span class="hljs-keyword">let</span> xfy = <span class="hljs-keyword">new</span> Person();<span class="hljs-keyword">let</span> dfy = <span class="hljs-keyword">new</span> Person();xfy.consoles.push(<span class="hljs-string">&#x27;nintendo&#x27;</span>);<span class="hljs-built_in">console</span>.log(xfy.consoles);<span class="hljs-built_in">console</span>.log(dfy.consoles);</code></pre><h3 id="组合使用构造函数与原型"><a href="#组合使用构造函数与原型" class="headerlink" title="组合使用构造函数与原型"></a>组合使用构造函数与原型</h3><p>在了解构造函数的时候，了解到一个问题所在就是构造函数的每个属性/方法对于每个实例都是重新创建的。而原型则有着共享性。所以将二者组合使用就能互补其缺点。</p><p>这种方法的使用，每个实例就有自己的一份实例属性副本，但是同时又共享着对方法的引用，最大限度的节省了内存。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age, job</span>) </span>&#123;    <span class="hljs-built_in">this</span>.name = name;    <span class="hljs-built_in">this</span>.age = age;    <span class="hljs-built_in">this</span>.job = job;    <span class="hljs-built_in">this</span>.consoles = [<span class="hljs-string">&#x27;xbox&#x27;</span>, <span class="hljs-string">&#x27;playstation&#x27;</span>];&#125;Person.prototype = &#123;    sayName: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);    &#125;&#125;<span class="hljs-built_in">Object</span>.defineProperty(Person.prototype, <span class="hljs-string">&#x27;constructor&#x27;</span>, &#123;    enumerable: <span class="hljs-literal">false</span>,    value: Person&#125;)<span class="hljs-keyword">let</span> xfy = <span class="hljs-keyword">new</span> Person();<span class="hljs-keyword">let</span> dfy = <span class="hljs-keyword">new</span> Person();xfy.consoles.push(<span class="hljs-string">&#x27;nintendo&#x27;</span>);<span class="hljs-built_in">console</span>.log(xfy.consoles);<span class="hljs-comment">// [ &quot;xbox&quot;, &quot;playstation&quot;, &quot;nintendo&quot; ]</span><span class="hljs-built_in">console</span>.log(dfy.consoles);<span class="hljs-comment">// [ &quot;xbox&quot;, &quot;playstation&quot; ]</span></code></pre><h3 id="动添原型模式"><a href="#动添原型模式" class="headerlink" title="动添原型模式"></a>动添原型模式</h3><p>原型的动态性把所有信息都封装在了构造函数中。这样可以在构造函数中初始化原型（必要情况下），又保持了原型和构造函数的优点。也就是说，可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。</p><p>对于这种模式创建的对象，还可以是使用<code>instanceof</code>来确定它的类型。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age, job</span>) </span>&#123;    <span class="hljs-built_in">this</span>.name = name;    <span class="hljs-built_in">this</span>.age = age;    <span class="hljs-built_in">this</span>.job = job;    <span class="hljs-built_in">this</span>.consoles = [<span class="hljs-string">&#x27;xbox&#x27;</span>, <span class="hljs-string">&#x27;playstation&#x27;</span>];    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span>(sayName) != <span class="hljs-string">&#x27;function&#x27;</span>) &#123;        Person.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);        &#125;    &#125;&#125;<span class="hljs-keyword">let</span> xfy = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;xfy&#x27;</span>, <span class="hljs-number">18</span>, <span class="hljs-literal">null</span>);<span class="hljs-keyword">let</span> dfy = <span class="hljs-keyword">new</span> Person();xfy.consoles.push(<span class="hljs-string">&#x27;nintendo&#x27;</span>);xfy.sayName();</code></pre><blockquote><p>如果在已经创建了实例的情况下重写原型，则会切断实例与新原型的联系。</p></blockquote><h3 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h3><p>在前面几种模式都不适用的情况下，可以适用寄生(parasitic)构造函数模式。在这个模式下会新建一个对象，并以相应的属性和方法初始化该对象，最后返回该对象。除了使用new操作符之外，这个模式与工厂模式一模一样。</p><p>构造函数在不返回值的情况下，默认会返回新对象实例。而在构造函数末尾添加一个return语句，可以重写调用构造函数时返回的语句。</p><p>这个模式可以用在特殊的情况下为对象创建构造函数。如果需要一个具有额外方法的特殊数组，而且不能直接Array构造函数，可以使用这个模式。</p><p>在这个模式下返回的对象与构造函数的原型直接没有任何关系。构造函数返回的对象与外部创建的对象没有任何的不同。无法用instanceof来确定对象类型。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myArray</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-comment">// 创建一个数组</span>    <span class="hljs-keyword">let</span> val = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();    <span class="hljs-comment">// 将参数全部传递进去</span>    val.push.apply(val, <span class="hljs-built_in">arguments</span>);    <span class="hljs-comment">// 自定义一个方法</span>    val.pid = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">return</span> val.join(<span class="hljs-string">&#x27;|&#x27;</span>);    &#125;    <span class="hljs-keyword">return</span> val&#125;<span class="hljs-keyword">let</span> arr = <span class="hljs-keyword">new</span> myArray(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>);<span class="hljs-built_in">console</span>.log(arr.pid());</code></pre><h3 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h3><p>所谓稳妥对象，指的是没有公共属性，而且其方法也不能引用this的对象。稳妥对象最时候在一些安全的环境中（禁用this和new的环境）使用。</p><p>稳妥与寄生构造函数类似，但有两点不同：</p><ol><li>创建新对象的实例方法不引用this；</li><li>不适用new操作符调用构造函数；</li></ol><p>除了调用定义的方法外，没有其他方法去访问传递的参数。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age</span>) </span>&#123;    <span class="hljs-keyword">let</span> o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();    o.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(name);    &#125;    o.sayAge = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(age);    &#125;    <span class="hljs-keyword">return</span> o;&#125;<span class="hljs-keyword">let</span> xfy = Person(<span class="hljs-string">&#x27;yyy&#x27;</span>, <span class="hljs-number">18</span>);<span class="hljs-built_in">console</span>.log(xfy.name);xfy.sayName();</code></pre><p>它和私有化变量也很相似，同样的也是不引用this和不使用new操作符。</p><blockquote><p>它也和寄生构造函数一样，与构造函数的原型没有多大关系，也无法通过instanceof来确定类型。</p></blockquote><h2 id="私有化变量"><a href="#私有化变量" class="headerlink" title="私有化变量"></a>私有化变量</h2><p>闭包的另一种应用，在构造函数上的应用。</p><p>在使用构造函数构造对象时，属性中的函数会向闭包一样返回为对象的功能，因为闭包的特征，所以构造函数中AO中的变量能被属性内的函数保存和读取。</p><p>而构造函数中创建的变量不能使用通常的方法被对象直接访问，只有对象调用指定的方法才能访问。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Xfy</span>(<span class="hljs-params">name, consoled</span>) </span>&#123;    <span class="hljs-keyword">let</span> anotherConsole = <span class="hljs-string">&#x27;ps4&#x27;</span>;    <span class="hljs-built_in">this</span>.name = name;    <span class="hljs-built_in">this</span>.consoled = consoled;    <span class="hljs-built_in">this</span>.changeConsole = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">this</span>.console = anotherConsole;    &#125;    <span class="hljs-built_in">this</span>.buyConsole = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target</span>) </span>&#123;        anotherConsole = target;    &#125;    <span class="hljs-built_in">this</span>.sayTrueth = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(anotherConsole);    &#125;&#125;<span class="hljs-keyword">let</span> xfy = <span class="hljs-keyword">new</span> Xfy(<span class="hljs-string">&#x27;xfy&#x27;</span>, <span class="hljs-string">&#x27;xbox&#x27;</span>);</code></pre><blockquote><p>console.log中的console也是关键字，和变量等不能重名……</p></blockquote><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承是OO语言中的一个最为人津津乐道的概念。许多OO语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。由于JS的函数没有签名，所有无法实现接口继承，只有实现继承。而实现继承主要依靠的是原型链。</p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>ECMAScript中描述的原型链的概念，并将原型链作为实现继承的主要方法。其基本思想就是让一个引用类型继承另一个引用类型的属性和方法。</p><p>构造函数和原型与实例的关系：每个构造函数都一个原型对象，原型对象都包含一个指向构造函数的指针。而实例都包含一个指向原型对象的内部指针。</p><p>如果让构造函数的原型对象等于另一个类型的实例，另一个原型也包含另一个构造函数的指针，如果另一个原型又是另一个类型的实例，那么原型的关系就会层层递进，呈链式结构。这就是原型链的基本概念。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperType</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-comment">// 为实例设置属性</span>    <span class="hljs-built_in">this</span>.property = <span class="hljs-literal">true</span>;&#125;<span class="hljs-comment">// 在原型上添加一个方法，通过该构造函数创建的实例就会有该方法。</span>SuperType.prototype.getProperty = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.property);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<span class="hljs-comment">// 将次级构造函数的原型对象设置为上级构造函数的实例。上级构造函数的实例包含其原型对象，将其设置到该构造函数的原型对象上。</span>SubType.prototype = <span class="hljs-keyword">new</span> SuperType();<span class="hljs-comment">// 通过该构造函数创建的实例就会继承最高级构造函数的原型对象。</span><span class="hljs-keyword">let</span> xfy = <span class="hljs-keyword">new</span> SubType();xfy.getProperty();  <span class="hljs-comment">// true</span></code></pre><p>由于SubType的原型对象是SuperType的实例，相当于重写了SubType的原型对象，所以通过SubType创建的实例对象的constructor指向的是SuperType。</p><pre><code class="hljs js">xfy <span class="hljs-keyword">instanceof</span> SubType;<span class="hljs-comment">// true</span>xfy <span class="hljs-keyword">instanceof</span> SuperType;<span class="hljs-comment">// true</span>xfy.constructor;<span class="hljs-comment">// function SuperType()</span></code></pre><h3 id="默认原型"><a href="#默认原型" class="headerlink" title="默认原型"></a>默认原型</h3><p>所有引用类型都继承了Object，这个继承也是通过原型链来实现的。<strong>所有函数的默认原型都是Object的实例</strong>，因此默认原型都会包含一个内部指针，指向Object.prototype。这也就是所有自定义类型都会继承<code>toString()</code>、<code>valueOf()</code>等方法的根本原因。</p><pre><code class="hljs js"><span class="hljs-built_in">String</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>;<span class="hljs-comment">// true</span></code></pre><h3 id="确定原型与实例的关系"><a href="#确定原型与实例的关系" class="headerlink" title="确定原型与实例的关系"></a>确定原型与实例的关系</h3><p>可以使用instanceof，instanceof用于检测该对象的原型链中有没有该函数的原型。</p><pre><code class="hljs js"><span class="hljs-built_in">String</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>;<span class="hljs-comment">// true</span>SuperType <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>;<span class="hljs-comment">// true</span>xfy <span class="hljs-keyword">instanceof</span> SubType;<span class="hljs-comment">// true</span>xfy <span class="hljs-keyword">instanceof</span> SuperType;<span class="hljs-comment">// true</span>xfy <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>;<span class="hljs-comment">// true</span></code></pre><p><code>isPrototypeOf()</code>方法与instanceof类似，只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型。</p><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.prototype.isPrototypeOf(xfy);<span class="hljs-comment">// true</span>SuperType.prototype.isPrototypeOf(xfy);<span class="hljs-comment">// true</span>SubType.prototype.isPrototypeOf(xfy);<span class="hljs-comment">// true</span></code></pre><h3 id="谨慎的定义方法"><a href="#谨慎的定义方法" class="headerlink" title="谨慎的定义方法"></a>谨慎的定义方法</h3><p>在原型链中，如果给子类型添加一个与超类型的同名的方法，那么子类型的实例就会继承覆盖超类型的方法。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperType</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">this</span>.property = <span class="hljs-literal">true</span>;&#125;SuperType.prototype.getProperty = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.property);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span>(<span class="hljs-params"></span>) </span>&#123;&#125;SubType.prototype = <span class="hljs-keyword">new</span> SuperType();SubType.prototype.getProperty = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;<span class="hljs-keyword">let</span> xfy = <span class="hljs-keyword">new</span> SubType();xfy.getProperty();  <span class="hljs-comment">// false</span></code></pre><p>此外，重写原型链的方法时，不能使用对象字面量的方法来创建方法。这样会切断刚刚创建的原型链的联系。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperType</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">this</span>.property = <span class="hljs-literal">true</span>;&#125;SuperType.prototype.getProperty = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.property);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span>(<span class="hljs-params"></span>) </span>&#123;&#125;SubType.prototype = <span class="hljs-keyword">new</span> SuperType();SubType.prototype = &#123;    getProperty: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;<span class="hljs-keyword">let</span> xfy = <span class="hljs-keyword">new</span> SubType();xfy.property <span class="hljs-comment">// undefined</span></code></pre><h3 id="原型链的问题"><a href="#原型链的问题" class="headerlink" title="原型链的问题"></a>原型链的问题</h3><p>原型链和原型一样非常的强大，但是它也有和原型一样的问题。那就是对引用值的问题。</p><p>修改子类型任何一个实例原型上的值，都是对<code>SubType.prototype</code>这个原型对象的修改。并且会实时的反应到SubType创建的实例上去。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperType</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">this</span>.arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];    <span class="hljs-built_in">this</span>.property = <span class="hljs-literal">true</span>;&#125;SuperType.prototype.getProperty = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.property);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span>(<span class="hljs-params"></span>) </span>&#123;&#125;SubType.prototype = <span class="hljs-keyword">new</span> SuperType();<span class="hljs-keyword">let</span> xfy = <span class="hljs-keyword">new</span> SubType();<span class="hljs-keyword">let</span> dfy = <span class="hljs-keyword">new</span> SubType();<span class="hljs-built_in">console</span>.log(xfy.arr);<span class="hljs-comment">// [1, 2, 3, 4, 5]</span><span class="hljs-built_in">console</span>.log(dfy.arr);<span class="hljs-comment">// [1, 2, 3, 4, 5]</span><span class="hljs-comment">// 修改子类型任何一个实例原型上的值</span>dfy.arr.push(<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>)<span class="hljs-built_in">console</span>.log(xfy.arr);<span class="hljs-comment">// [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]</span><span class="hljs-built_in">console</span>.log(dfy.arr);<span class="hljs-comment">// [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]</span><span class="hljs-built_in">console</span>.log(SubType.prototype.arr);<span class="hljs-comment">// [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]</span></code></pre><p>除此之外，原型链创建实例还有另外一个问题。在子类创建实例时无法向超类传递参数。实际上，无法在布影响所有对象实例的情况下，给超类的构造函数传递参数。</p><h3 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><p>原型链中所出现的问题可以配合构造函数使用来解决。这种方法称之为（constructor stealing）有时候也称为伪造对象或经典继承。</p><p>这种思想非常简单，即在子类型构造函数的内部调用超类型的构造函数。函数只不过是在特定环境中执行代码的对象，通过使用apply/call来调用另个构造函数也可以创建实例。</p><p>当然为了确保没有重写子类型的属性，可以先调用超类型的构造函数，在其后添加自定义属性。</p><p>这样创建出的实例就会有自己的属性副本了，而不是从原型链上继承得来的。所以修改其他实例的属性就不会影响到原型链，也就不会影响到其他实例了。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperType</span>(<span class="hljs-params">name, age</span>) </span>&#123;    <span class="hljs-built_in">this</span>.name = name;    <span class="hljs-built_in">this</span>.age = age;    <span class="hljs-built_in">this</span>.arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span>(<span class="hljs-params">name, age</span>) </span>&#123;    <span class="hljs-comment">// 可以称之为继承自SuperType</span>    <span class="hljs-comment">// 同时还能传递参数</span>    SuperType.call(<span class="hljs-built_in">this</span>, name, age);&#125;<span class="hljs-keyword">let</span> xfy = <span class="hljs-keyword">new</span> SubType(<span class="hljs-string">&#x27;xfy&#x27;</span>, <span class="hljs-number">18</span>);<span class="hljs-keyword">let</span> dfy = <span class="hljs-keyword">new</span> SubType(<span class="hljs-string">&#x27;dfy&#x27;</span>, <span class="hljs-number">188</span>);<span class="hljs-built_in">console</span>.log(xfy);xfy.arr.push(<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<span class="hljs-built_in">console</span>.log(xfy.arr);<span class="hljs-comment">// [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]</span><span class="hljs-built_in">console</span>.log(dfy.arr);<span class="hljs-comment">// [ 1, 2, 3, 4, 5 ]</span></code></pre><p>不过借用构造函数也有问题，就和构造函数本身的问题一样，无法解决函数复用的问题。</p><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合继承，有时候也称之为伪继承。指的是将原型链和构造函数的技术结合使用，从而发挥二者之长的一种模式。</p><p>这种方法将实例的属性通过借用构造函数来实现继承，让实例都有自己的属性副本，而不是在原型链上。为了解决方法能够复用的问题，将方法定义在原型链上，并通过原型链来继承。</p><p>组合继承避免了原型链和构造函数的缺点，融合了它们的优点。而且<code>instanceof</code>和<code>isPrototypeOf()</code>也能够识别基于组合继承创建的对象。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperType</span>(<span class="hljs-params">name, age</span>) </span>&#123;    <span class="hljs-built_in">this</span>.name = name;    <span class="hljs-built_in">this</span>.age = age;    <span class="hljs-built_in">this</span>.arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];&#125;SuperType.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span>(<span class="hljs-params">name, age</span>) </span>&#123;    <span class="hljs-comment">// 借用构造函数继承属性</span>    SuperType.call(<span class="hljs-built_in">this</span>, name, age);&#125;<span class="hljs-comment">// 原型链继承方法</span>SubType.prototype = <span class="hljs-keyword">new</span> SuperType;<span class="hljs-keyword">let</span> xfy = <span class="hljs-keyword">new</span> SubType(<span class="hljs-string">&#x27;xfy&#x27;</span>, <span class="hljs-number">18</span>);<span class="hljs-keyword">let</span> dfy = <span class="hljs-keyword">new</span> SubType(<span class="hljs-string">&#x27;dfy&#x27;</span>, <span class="hljs-number">188</span>);<span class="hljs-built_in">console</span>.log(xfy.sayName());xfy.arr.push(<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<span class="hljs-built_in">console</span>.log(xfy.arr);<span class="hljs-built_in">console</span>.log(dfy.arr);</code></pre><h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>道格拉斯·克罗克在06年写了一篇题为Prototypal Inheritance in JavaScript（JavaScript中的原型式继承）的文章。他介绍了一种实现继承的方法。这种方法没有使用严格意义上的构造函数，他的想法是借助原型可以基于<strong>已有的对象创建对象</strong>，同时还不必因此创建自定义类型。</p><p>在object函数内部先创建一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时构造函数的一个新实例。从本质上来说，对传入的构造函数进行了一次浅复制。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">object</span>(<span class="hljs-params">o</span>) </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;    F.prototype = o;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> F();&#125;</code></pre><p>ECMAScript5通过新增<code>Object.create()</code>规范化了原型式继承。并且它接受两个参数：</p><ol><li>作为新对象原型的对象；</li><li>为新对象定义额外属性的对象；</li></ol><p>第二个参数与<code>Object.defineProperties()</code>方法的第二个参数格式相同：每个属性都是通过自己的描述符定义了。以这种方式指定的属性都会覆盖原型对象上的同名属性。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> one = &#123;    name: <span class="hljs-string">&#x27;xfy&#x27;</span>,    age: <span class="hljs-number">18</span>&#125;<span class="hljs-keyword">let</span> two = <span class="hljs-built_in">Object</span>.create(one, &#123;    name: &#123;        configurable: <span class="hljs-literal">false</span>,        value: <span class="hljs-string">&#x27;dfy&#x27;</span>    &#125;&#125;)two.name = <span class="hljs-number">123</span>;<span class="hljs-built_in">console</span>.log(two.name);<span class="hljs-built_in">console</span>.log(two.age);<span class="hljs-comment">// 18</span></code></pre><h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>寄生式继承式与原型式继承紧密相关的一种思路。它也是用克罗克福德推广而之的。寄生式继承的思路和寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后在真的像它做了所有工作一样返回对象。</p><p>基于寄生式继承的对象，不仅仅有了继承的对象属性方法，而且还有自己自定义的方法。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = &#123;    name: <span class="hljs-string">&#x27;xfy&#x27;</span>,    age: <span class="hljs-number">18</span>&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">target</span>) </span>&#123;    <span class="hljs-keyword">let</span> clone = <span class="hljs-built_in">Object</span>.create(target);    clone.hello = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hi(｡･∀･)ﾉﾞ&#x27;</span>);    &#125;    <span class="hljs-keyword">return</span> clone;&#125;<span class="hljs-keyword">let</span> xfy = <span class="hljs-keyword">new</span> test(person);<span class="hljs-built_in">console</span>.log(xfy.name);<span class="hljs-built_in">console</span>.log(xfy.hello());</code></pre><blockquote><p>这种方法同样不能做到复用函数。</p></blockquote><h3 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h3><p>组合继承式一个常用的继承模式，不过它也有自己的不足。那就是无论在什么情况下，它都需要调用两次超类型的构造函数。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span>(<span class="hljs-params">name, age</span>) </span>&#123;    <span class="hljs-comment">// 借用构造函数继承属性</span>    SuperType.call(<span class="hljs-built_in">this</span>, name, age);&#125;<span class="hljs-comment">// 原型链继承方法</span>SubType.prototype = <span class="hljs-keyword">new</span> SuperType;</code></pre><p>调用两次超类型构造函数就会导致同样的属性和方法会分别出现在子类型的prototype上和子类型创建的实例上。</p><p>寄生组合继承便可以解决这个问题：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inherit</span>(<span class="hljs-params">subtype, supertype</span>) </span>&#123;    <span class="hljs-keyword">let</span> prototype = <span class="hljs-built_in">Object</span>.create(supertype.prototype);    prototype.constructor = subtype;    subtype.prototype = prototype;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">One</span>(<span class="hljs-params">name</span>) </span>&#123;    <span class="hljs-built_in">this</span>.name = name;&#125;One.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Two</span>(<span class="hljs-params">name, age</span>) </span>&#123;    One.call(<span class="hljs-built_in">this</span>, name);    <span class="hljs-built_in">this</span>.age = age;&#125;Two.prototype.sayAge = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.age);&#125;inherit(Two, One);<span class="hljs-keyword">let</span> xfy = <span class="hljs-keyword">new</span> Two(<span class="hljs-string">&#x27;xfy&#x27;</span>, <span class="hljs-number">18</span>);<span class="hljs-built_in">console</span>.log(xfy.name);</code></pre><p>这种方法解决了多次调用超类型函数，已经在子类型原型上创建多余不必要的属性。同时原型链还能保持不变。</p><p>同样，所谓的圣杯模式也是同样的道理。这里直接就使用<code>Object.create()</code>方法来代替寄生式继承的详细写法。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inherit</span>(<span class="hljs-params">target, origin</span>) </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;    F.prototype = origin.prototype;    target.prototype = <span class="hljs-keyword">new</span> F();    target.prototype.constructor = target;    target.prototype.uber = origin;&#125;</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>​    ECMAScript支持面向对象（OO）编程，但不使用类或者接口。对象可以在代码执行过程中创建和增强，因此具有动态性而非严格定义的实体。在没有类的情况下，可以采用下列模式创建对象：</p><ul><li>工厂模式，使用简单的函数传教对象，为对象添加属性和方法，然后返回对象。这个模式后来被构造函数模式所取代。</li><li>构造函数模式，可以创建自定义引用类型，可以像创建内置对象实例一样使用new操作符。不过，构造函数模式也有缺点，即它的每个成员都无法得到复用，包括函数。由于函数不局限于任何对象（即与对象具有松散耦合的特点），因此没有理由不在多个对象间共享函数。</li><li>原型模式，使用构造函数的prototype属性来指定那些应该共享的属性和方法。组合使用构造函数模式和原型模式时，使用构造函数定义实例属性，而使用原型定义共享的属性和方法。</li></ul><p>​    JavaScript主要通过原型链实现继承。原型链的构建时通过将一个类的实例赋值给另一个构造函数的原型实现的。这样，子类型就能够访问超类型的所有属性和方法，这一点与基于类的继承很相似。原型链的问题是对象实例共享所有继承的属性和方法，因此不宜单独使用。解决这个问题的技术是借用构造函数，即在子类型构造函数的内部调用超类型构造函数。这样就可以做到每个实例都具有自己的属性，同时还能保证只使用构造函数模式来定义类型。使用最多的继承模式是组合继承，这种模式使用原型链继承共享的属性和方法，而通过构造函数继承实例属性。</p><p>​    此外，还存在下列可供选择的继承模式：</p><ul><li>原型式继承，可以在不必预先定义构造函数的情况下实现继承，其本质式执行对给定对象的浅复制。而复制得到的副本还可以得到进一步改造。</li><li>寄生式继承，与原型式继承非常相似，也是基于某个对象或某些信息创建一个对象，然后增强对象，最后返回对象。为了解决组合继承模式由于多次调用超类型构造函数而导致的低效率问题，可以将这个模式与组合继承一起使用。</li><li>寄生组合式继承，集寄生式继承和组合继承的优点于一身，是实现基于类型继承的最有效方式。</li></ul><blockquote><p>我更加喜欢寄生组合式继承，也就是常说的“圣杯模式”。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript的作用域与链</title>
    <link href="/defect/javascript-scope-and-chain.html"/>
    <url>/defect/javascript-scope-and-chain.html</url>
    
    <content type="html"><![CDATA[<p>JavaScript是一门动态语言，也常称呼为弱类型/解释型的语言。除了不需要明确写出数据类型外，JavaScript的作用域也和其他类型的语言不同。并且作用域还以链的方式互相连接。</p><h2 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h2><p>要想彻底的了解作用域与变量提升，就得先了解js语言的执行过程。 </p><p>JavaScript语言会分为三步来解释执行代码，分别是：</p><ol><li>语法分析</li><li>预编译</li><li>解释执行</li></ol><p>语法分析主要是检查整体代码中有没有明显的会导致程序无法执行的语法错误，在解释执行之前找出并提示错误。语法分析只是餐前甜点，真正发生变化的还是在预编译阶段。</p><p>由于预编译的阶段，存在了函数以及变量的提升。所谓的预编译就是在代码真正执行之前做好一些准备，例如声明变量，声明函数等。</p><p>函数的预编译需要经过几个阶段：</p><ol><li><p>创建AO（执行期上下文，Activation Object）</p><pre><code class="hljs js"><span class="hljs-comment">// 创建AO对象</span>AO &#123;   &#125;</code></pre></li><li><p>寻找形参和变量声明，将变量和形参名作为AO的属性名，值为undefined。（<strong>变量声明提升</strong>）</p><pre><code class="hljs js"><span class="hljs-comment">// 创建AO对象</span>AO &#123;   a: <span class="hljs-literal">undefined</span>,    b: <span class="hljs-literal">undefined</span>&#125;</code></pre></li><li><p>寻找函数声明，赋值为函数体（<strong>函数整体提升</strong>）</p><pre><code class="hljs js"><span class="hljs-comment">// 创建AO对象</span>AO &#123;    a : <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;&#125;,    b : <span class="hljs-literal">undefined</span>&#125;</code></pre></li></ol><blockquote><p>预编译阶段不会为变量赋值。</p></blockquote><p>预编译阶段结束后就会进入解释执行阶段，此时函数就会真正准备执行了。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">a</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(a);    <span class="hljs-comment">// 结果：function a() &#123;&#125;,</span>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">123</span>;    <span class="hljs-comment">// let a = 123;变量不会提升</span>    <span class="hljs-built_in">console</span>.log(a);    <span class="hljs-comment">// AO对象中的a被变量赋值，结果：123</span>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;&#125;    <span class="hljs-built_in">console</span>.log(a);    <span class="hljs-comment">// 函数声明已经被提升，结果：123</span>    <span class="hljs-keyword">let</span> b = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;    <span class="hljs-built_in">console</span>.log(b);    <span class="hljs-comment">// b是函数表达式，刚刚被赋值为函数体。结果：function() &#123;&#125;</span>&#125;test(<span class="hljs-number">1</span>);</code></pre><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>JavaScript也有作用域。不过和其他强类型语言相比，JavaScript并不是以花括号<code>&#123;&#125;</code>来产生作用域的。</p><p>作用域可以直接的理解为一块独立的区域，在该区域内声明的函数、变量等都属于这个区域。使得在不同区域内的同重名变量和函数等不会冲突。在通常情况下作用域内的变量等不会被外部所访问到。</p><p>在预编译环境中，函数会创建一个执行期上下文的内部对象，这个AO就定义了一个函数执行时的环境。AO就可以理解为函数的作用域。</p><p>全局环境下也有一个执行环境：GO（Global Object），它存储了全局环境下的变量和函数等。也就是全局作用域。</p><p>执行期上下文：当函数运行时，会创建一个执行期上下文的内部对象（AO，Activation Object）。一个执行期上下文定义了一个函数执行时的环境。函数每次执行时对应的执行上下文是独一无二的，所以多次调用一个函数会导致创建多个执行期上下文。当函数执行完毕，它所产生的执行期上下文会被销毁。</p><p>在函数的AO中保存的<strong>经过声明的变量</strong>等，除了特意保存到外部，否则无论函数执行与否，在AO外部是无法被访问的：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> a = <span class="hljs-number">123</span>;    <span class="hljs-keyword">let</span> b = <span class="hljs-number">333</span>;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;xfy&#x27;</span>);    &#125;&#125;<span class="hljs-built_in">console</span>.log(a);<span class="hljs-comment">// a is not defined.</span>c(); <span class="hljs-comment">// c is not defined.</span></code></pre><blockquote><p>未经声明而直接赋值的变量将会转化为全局变量。</p></blockquote><h3 id="变量声明提升"><a href="#变量声明提升" class="headerlink" title="变量声明提升"></a>变量声明提升</h3><p>除了新的关键字<code>let</code>，<code>cont</code>之外，JavaScript只在函数中产生作用域。并且和全局作用域一样，在函数作用域内使用<code>var</code>声明和函数声明也会提升。</p><pre><code class="hljs js">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    a = <span class="hljs-number">123</span>; <span class="hljs-comment">// 未经声明前使用</span>    <span class="hljs-built_in">console</span>.log(a);    <span class="hljs-keyword">var</span> a;  <span class="hljs-comment">// 声明提升</span>&#125;())</code></pre><p>变量仅仅只是声明会提升到作用域顶部，变量的赋值还是在原有的位置被赋值。因为预编译环境不会为变量赋值。</p><h3 id="函数声明提升"><a href="#函数声明提升" class="headerlink" title="函数声明提升"></a>函数声明提升</h3><p>函数的声明提升与变量提升类似，都是经过预编译阶段将函数的声明提升到作用域的顶端。所以和使用<code>var</code>声明的变量一样，可以将调用写在函数声明之前。</p><pre><code class="hljs js">someFun()<span class="hljs-comment">//声明前调用</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">someFun</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;xfy&#x27;</span>);&#125;</code></pre><p>但必须是声明函数体才会在预编译中提升，将函数赋值给变量并不属于函数声明。此时在声明前调用函数就会得到<code>ReferenceError: Cannot access &#39;foo&#39; before initialization</code>的提示。</p><pre><code class="hljs js">foo();<span class="hljs-keyword">let</span> foo = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;xfy&#x27;</span>);&#125;</code></pre><h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>最外层的作用域，在代码的任何地方都能访问到的作用域。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">123</span>;<span class="hljs-comment">// 全局作用域内的变量</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> b = <span class="hljs-number">333</span>;<span class="hljs-comment">// 函数作用域内的变量</span>    <span class="hljs-keyword">return</span> b;&#125;</code></pre><p>在window/global的属性也是全局作用域。</p><p>如果变量没有使用关键字声明，那么将会创建出一个全局变量。并且值得注意的是在连等赋值时，容易产生没有被声明的变量，因为关键字只能声明第一个变量，等号后的变量将不会被关键字声明。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;    a = <span class="hljs-number">123</span>;    <span class="hljs-comment">// 全局变量</span>    <span class="hljs-keyword">let</span> b = c = <span class="hljs-number">100</span>;    <span class="hljs-comment">// c没有被声明</span>&#125;foo();<span class="hljs-built_in">console</span>.log(a);  <span class="hljs-comment">// 123</span><span class="hljs-comment">// console.log(b);</span><span class="hljs-built_in">console</span>.log(c);  <span class="hljs-comment">// 100</span></code></pre><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>新增的<code>let</code>和<code>const</code>关键字可以产生块级作用域。在其他的强类型语言中可能会经常容易见到块级作用域，常见的就是在大括号<code>&#123;&#125;</code>中的代码为一个作用域。</p><p>js的大括号<code>&#123;&#125;</code>是不会产生作用域的，也就是在没有这两个新增的关键字之前，js的块级作用域并不是那么容易产生。</p><p>块级作用域在日常的代码中也有很多方便的用途，例如最常见的<code>for</code>循环就很容易因为没有块级作用域而导致在循环中调用的是同一个计数器的值。</p><p>在下面这段代码中，计数器<code>i</code>使用<code>var</code>来声明的，并不会产生块级作用域。也就是说：<strong>无论循环多少次，最后作用域里保存的<code>i</code>只有一个值，那就是最后一次循环的值<code>10</code>。</strong>所以在这个数组内保存的十个函数在执行时，读取的到作用域里的<code>i</code>都是10</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;    arr[i] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(i);    &#125;&#125;arr[<span class="hljs-number">2</span>]();  <span class="hljs-comment">// 10</span></code></pre><p>而将<code>var</code>换成<code>let</code>之后，由于块级作用域的存在，每次循环，都能将<code>i</code>的值保存在作用域里。等到数组内的函数执行时，它所访问的<code>i</code>就是那一次循环所保存在作用域里的值。所以使用了<code>let</code>就不会出现所有的<code>i</code>都是10的情况了。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;    arr[i] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(i);    &#125;&#125;arr[<span class="hljs-number">2</span>]();  <span class="hljs-comment">// 2</span></code></pre><p>因为js中的函数是可以产生作用域的，所以除了使用<code>let</code>来生成块级作用域，还能使用函数来模拟块级作用域。上述的例子中，可以使用立即执行函数来模拟出一个块级作用域。</p><p>由于立即执行函数是立即执行的，所以每次循环它都会执行一次，并产生一个AO（作用域）来保存参数。将<code>i</code>作为参数传递给立即执行函数，就能把每次循环<code>i</code>的值给保存下来。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;    (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">j</span>) </span>&#123;        arr[j] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-built_in">console</span>.log(j);        &#125;    &#125;(i))&#125;arr[<span class="hljs-number">2</span>]()<span class="hljs-comment">// 2</span></code></pre><blockquote><p>目前官方也是推荐使用<code>let</code>替换<code>var</code>。</p></blockquote><h2 id="链"><a href="#链" class="headerlink" title="链"></a>链</h2><p>[[scope]]：每个js函数都是一个对象，对象中有些属性可以访问，但有些不可以。这些属性仅供JavaScript引擎存取，[[scope]]就是其中一个。</p><p>[[scope]]中所存储的<strong>执行期上下文对象的集合</strong>，这个集合呈链式链接，我们把这种链式链接叫做作用域链。</p><p>通俗的来说，作用域链就是将多个函数的AO包括GO呈链式的保存起来，并按照一定的顺序来访问。</p><p>作用域链将函数与其内部的函数和全局作用域串接在一起，呈一条链式的连接。在需要访问其变量或其他属性时，函数会顺着作用域依次向上查找，直到找到顶部GO。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">123</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">x</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> b = <span class="hljs-number">333</span>;    <span class="hljs-built_in">console</span>.log(a, b);    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">y</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">let</span> c = <span class="hljs-number">321</span>;        <span class="hljs-built_in">console</span>.log(a, b, c);        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">z</span>(<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-keyword">let</span> d = <span class="hljs-string">&#x27;xfy&#x27;</span>;            <span class="hljs-built_in">console</span>.log(a, b, c, d);        &#125;        z();    &#125;    y();&#125;x();</code></pre><p><img src="../images/JavaScript%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%93%BE/scope.png" alt="scope"></p><p>在作用域链内部的函数可以向上方位外部函数作用域内的变量，直至全局作用域。而作用域外的函数不能访问内部函数的变量。</p><h3 id="父级作用域中的变量"><a href="#父级作用域中的变量" class="headerlink" title="父级作用域中的变量"></a>父级作用域中的变量</h3><p>由于作用域链的特性，子作用域内可以任意访问外部作用域，也就是父级作用域内的变量。但它也有一些值得注意的地方。</p><p>与<code>this</code>的指向不同的是，它并不是谁调用就会去访问谁的作用域。下述代码，虽然<strong>fun调用了foo</strong>，但是foo并不在fun作用域链内，也就是说foo并不能访问fun内的变量。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">123</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(a);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> a = <span class="hljs-string">&#x27;xfy&#x27;</span>;    foo();&#125;fun();<span class="hljs-comment">// 123</span></code></pre><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">123</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(b);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> b = <span class="hljs-string">&#x27;xfy&#x27;</span>;    foo();&#125;fun();<span class="hljs-comment">// b is not defined.</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>写作与协作</title>
    <link href="/defect/write-and-cooperation.html"/>
    <url>/defect/write-and-cooperation.html</url>
    
    <content type="html"><![CDATA[<p>出于对速度无理的追求，最终还是放弃了使用动态内容。转战静态blog。以前也稍微尝试过hexo，所以决定还是主要为hexo为主了。</p><p>在之前试过的typecho、wordpress之中，越是臃肿复杂的程序，1M的带宽越是不够。再详细的折腾了hexo之后，发现了最佳的解决方案。</p><p>在早期的一些常识之后，我也学会了很多。在刚入坑hexo的时候是盯上了阿里云的ECS+OSS和CDN的。虽然部署还是比较麻烦，但起码已经有了一套比较完善的流程了。</p><h2 id="从前的写作流程✍"><a href="#从前的写作流程✍" class="headerlink" title="从前的写作流程✍"></a>从前的写作流程✍</h2><p>Typora + OneDrive + VScode</p><p>以前买过软软的365，于是就用Onedrive来同步写的东西了。Onedrive对windows用起来还好，虽然有时会出些莫名其的问题，但基本上的备份与同步都是正常的。</p><p>但对于这套流程的问题不只是Onedrive它卡，这三个软件的契合度并不是很高。写一段代码要切到VScode，写完了再切回来复制到Typora。Onedrive在后台的实时同步还占用一定的性能。</p><p>相比较而下，我的部署流程就更为复杂了。因为我的Markdown文件都是放在Onedrive里的，而Hxeo因为<code>node_modules</code>的原因并不在Onedrive里，我需要写完了之后再将图片和MD放到Hexo的目录。之后再手动执行生成文章的命令。随后再将生成好的文章手动上传到ECS里挂载的OSS目录。</p><p>为什么要通过ECS再传到OSS呢？因为ECS和OSS再同一个区域是不会产生流量费用的。😅</p><p>Hexo –&gt; ECS –&gt; OSS</p><h2 id="现在的流程"><a href="#现在的流程" class="headerlink" title="现在的流程"></a>现在的流程</h2><p>VScode + git</p><p>将步骤的简化带来的不只是效率，从之前的两个编辑器来回切换到现在的只需要一个编辑器，在文字多的情况下也能保证一定的性能。此外，整体流程的步骤也更加契合，写完了之后可以直接在VScode里打开Terminal进行push。</p><p>配上CI持续集成，只需要写完push，之后就可以等着全新的文章上线。</p><p>Hexo –&gt; CI –&gt; COS</p><p>Hexo的仓库直接push，之后CI持续集成就会按照预设好的步骤来进行部署，除了可以部署到几个仓库的Pages外，还可以直接部署到云存储。</p><h3 id="VS-Code-不只是代码"><a href="#VS-Code-不只是代码" class="headerlink" title="VS Code - 不只是代码"></a>VS Code - 不只是代码</h3><p>软软的Visual Studio Code是一款很棒的编辑器。很早之前我就用它来尝试写一些东西，但只是用作于编辑器，主要功能就是代码补全和着色。</p><p>在早期的时候我比较喜欢用Typora来写作，它的风格我很喜欢，还能换主题，整体看上去很漂亮。但最近发现了一些比较难以容忍的毛病；就是当它的一篇文章字符超过10K的时候，性能略差一点的电脑就会很卡，打字都不出来的那种。我猜想可能和它是electron写的有关系。</p><p>就在我还没放弃它的时候，我无意中找到了VScode的Markdown插件。反正装插件也不是很麻烦是事情，于是就是尝试了一下。</p><p>没想到一时间我便爱上了它，虽然整体界面没有以前那么整洁、那么清新脱俗。但整体给人给感觉没有非常杂乱，反而看上去倒有点像剪辑软件？</p><p>除了外观从清新脱俗到繁重了一点，余下就只剩方便了。对于我这种才转到hexo的写作半吊子，一直很想找个与hexo契合度高的写作姿势。之前需要在Typora中写完，然后再将文章和单独的图片文件夹复制到hexo的<code>souce/_post</code>目录。像我这种半年产出一篇文章的还好，要是天天写，那样会被麻烦死。况且，如果有某一篇文章出了点小差错需要改。那就要同时动两个md文件和两组图片文件夹，对着资源管理翻来覆去的找，极为麻烦！🌚</p><p><img src="../images/%E5%86%99%E4%BD%9C%E4%B8%8E%E5%8D%8F%E4%BD%9C/vscode.webp" alt="vscode"></p><h4 id="粘贴图片🖼"><a href="#粘贴图片🖼" class="headerlink" title="粘贴图片🖼"></a>粘贴图片🖼</h4><p>之前在使用Typora写作的时候，最为方便的莫非是粘贴图片了。目前Windows上的Typora也支持将粘贴的图片复制到指定的路径或者是云存储。我的图片存放路径都是相对于文章的目录下的<code>images</code>目录：</p><pre><code class="hljs bash">../images/postName/</code></pre><p>Typora可以设置将图片复制到指定文件夹，还能创建文件夹。不过好在在VScode里也有插件能够实现同样的操作。使得插图剩下了一大笔麻烦的操作。</p><p>我用的是开源的<a href="https://marketplace.visualstudio.com/items?itemName=mushan.vscode-paste-image">Paste Images</a>。</p><p>只需要将插件稍微改下设置，将path修改下就能达到想要的效果。</p><pre><code class="hljs bash">../images/<span class="hljs-variable">$&#123;currentFileNameWithoutExt&#125;</span>/</code></pre><h4 id="一些小设置"><a href="#一些小设置" class="headerlink" title="一些小设置"></a>一些小设置</h4><p><strong>Quick Suggestions</strong></p><p>Editor &gt; Suggest: Snippets Prevent Quick Suggestions</p><p>在代码段中依然显示建议。</p><p><strong>自定义Suggestions</strong></p><pre><code class="hljs js">&#123;<span class="hljs-comment">// Place your snippets for javascript here. Each snippet is defined under a snippet name and has a prefix, body and </span><span class="hljs-comment">// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:</span><span class="hljs-comment">// $1, $2 for tab stops, $0 for the final cursor position, and $&#123;1:label&#125;, $&#123;2:another&#125; for placeholders. Placeholders with the </span><span class="hljs-comment">// same ids are connected.</span><span class="hljs-comment">// Example:</span><span class="hljs-string">&quot;Print to console&quot;</span>: &#123;<span class="hljs-string">&quot;prefix&quot;</span>: <span class="hljs-string">&quot;cl&quot;</span>,<span class="hljs-string">&quot;body&quot;</span>: [<span class="hljs-string">&quot;console.log($1);&quot;</span>,],<span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;Log output to console&quot;</span>&#125;&#125;</code></pre><h3 id="Coding-持续构建⏰"><a href="#Coding-持续构建⏰" class="headerlink" title="Coding - 持续构建⏰"></a>Coding - 持续构建⏰</h3><p>之前最大的问题还是手动部署hexo的繁琐操作，每新增一篇文章都是几个重复的机械性操作。对于我这种半年才写一篇文章的咸鱼来说都感觉到烦了。</p><p>使用CI持续部署的好处就是，可以完全专心与创作，而不用再去管部署之类的问题。只需要第一次写好流程，剩下的就全部交给自动化吧。</p><p><img src="../images/%E5%86%99%E4%BD%9C%E4%B8%8E%E5%8D%8F%E4%BD%9C/2020-08-07-09-30-54.webp" alt="coding"></p><p>之前的我从来没有用过Coding，对CI/CD也没有什么了解，从来没考虑过自动化部署这类操作。后来在研究静态化网站时发现了新大陆，完全可以将复杂重复的工作交给机器。并且随着后面文章的增加，渲染markdown文件肯定会越来越慢，于其手动繁琐的操作，不如完全交给CI。</p><h3 id="Github-Action"><a href="#Github-Action" class="headerlink" title="Github Action"></a>Github Action</h3><p>在我研究CI姿势的这段时间里，Github也推出了自己的CI（钞能力）。无论是谁家的CI，除了部署步骤不一样，其结果肯定是相同的。Github action也是能达到同样的效果，对于各个厂家的云存储，action也有同样的解决方法，甚至是比coding的jenkins还要灵活一点。</p><p><img src="../images/%E5%86%99%E4%BD%9C%E4%B8%8E%E5%8D%8F%E4%BD%9C/2020-08-27-16-32-48.webp"></p><h2 id="Hexo插件📥"><a href="#Hexo插件📥" class="headerlink" title="Hexo插件📥"></a>Hexo插件📥</h2><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p>我用的是<a href="https://github.com/chenzhutian/hexo-all-minifier">Hexo-all-minifier</a>，可以静态文件以及图片。还可以分别设置压缩等级来权衡质量与大小。</p><pre><code class="hljs bash">npm install hexo-all-minifier --save``` 不过它使用到了已经编译好的二进制包gifsicle等，在安装时需要走个脚本编译一下，在网络不好的情况下大概率会安装失败。为此我还特地水过一次：[Can<span class="hljs-string">&#x27;t install gifsicle](https://www.defectink.com/defect/cant-install-gifsicle.html)</span><span class="hljs-string"></span><span class="hljs-string">Hexo-all-minifier用到的也是gulp和一些图片压缩的工具，相对于gulp来说，它的配置更简单，更适合像我这种比较懒的咸鱼。</span><span class="hljs-string"></span><span class="hljs-string">只需要在站点配置文件添加一段聚合好的配置文件就好了，像这样：</span><span class="hljs-string"></span><span class="hljs-string">```yml</span><span class="hljs-string"># minifier</span><span class="hljs-string">all_minifier: ture</span><span class="hljs-string"></span><span class="hljs-string">html_minifier:</span><span class="hljs-string">  enable: true</span><span class="hljs-string">  ignore_error: false</span><span class="hljs-string">  silent: false</span><span class="hljs-string">  exclude:</span><span class="hljs-string"></span><span class="hljs-string">css_minifier:</span><span class="hljs-string">  enable: true</span><span class="hljs-string">  silent: false</span><span class="hljs-string">  exclude: </span><span class="hljs-string">    - &#x27;</span>*.min.css<span class="hljs-string">&#x27;</span><span class="hljs-string"></span><span class="hljs-string">js_minifier:</span><span class="hljs-string">  enable: true</span><span class="hljs-string">  mangle: true</span><span class="hljs-string">  silent: false</span><span class="hljs-string">  output:</span><span class="hljs-string">  compress:</span><span class="hljs-string">  exclude: </span><span class="hljs-string">    - &#x27;</span>*.min.js<span class="hljs-string">&#x27;</span><span class="hljs-string"></span><span class="hljs-string">image_minifier:</span><span class="hljs-string">  enable: true</span><span class="hljs-string">  interlaced: false</span><span class="hljs-string">  multipass: false</span><span class="hljs-string">  optimizationLevel: 2</span><span class="hljs-string">  webpquant: false</span><span class="hljs-string">  progressive: false</span><span class="hljs-string">  silent: false</span></code></pre><h3 id="Sitemap与RSS"><a href="#Sitemap与RSS" class="headerlink" title="Sitemap与RSS"></a>Sitemap与RSS</h3><p>两个小功能吧，虽然也不会有人来订阅我的小破站🤣。</p><pre><code class="hljs bash">npm install hexo-generator-sitemap --savenpm install hexo-generator-feed --save</code></pre><p>和压缩插件一样，都是在站点的<code>_config.yml</code>里添上相应的配置文件就好了。</p><pre><code class="hljs yml"><span class="hljs-comment"># feed</span><span class="hljs-attr">feed:</span>  <span class="hljs-attr">type:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">atom</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">rss2</span>  <span class="hljs-attr">path:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">/xml/atom.xml</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">/xml/rss.xml</span>  <span class="hljs-attr">limit:</span> <span class="hljs-number">20</span>  <span class="hljs-attr">hub:</span>  <span class="hljs-attr">content:</span>  <span class="hljs-attr">content_limit:</span> <span class="hljs-number">140</span>  <span class="hljs-attr">content_limit_delim:</span> <span class="hljs-string">&#x27; &#x27;</span>  <span class="hljs-attr">order_by:</span> <span class="hljs-string">-date</span>  <span class="hljs-attr">icon:</span> <span class="hljs-string">icon.webp</span>  <span class="hljs-attr">autodiscovery:</span> <span class="hljs-literal">true</span>  <span class="hljs-attr">template:</span><span class="hljs-comment"># sitemap</span><span class="hljs-attr">sitemap:</span>  <span class="hljs-attr">path:</span> <span class="hljs-string">/xml/sitemap.xml</span>  <span class="hljs-attr">template:</span> <span class="hljs-string">./source/_data/sitemap_template.xml</span>  <span class="hljs-attr">rel:</span> <span class="hljs-literal">false</span>  <span class="hljs-attr">tags:</span> <span class="hljs-literal">true</span>  <span class="hljs-attr">categories:</span> <span class="hljs-literal">true</span></code></pre><p>另外，可以来试一下：</p><ul><li><a href="/xml/atom.xml">Atom</a></li><li><a href="/xml/rss.xml">RSS</a></li><li><a href="/xml/sitemap.xml">Sitemap</a></li></ul><h2 id="Git加速"><a href="#Git加速" class="headerlink" title="Git加速"></a>Git加速</h2><p>使用Linux主机或者在Windows中使用git bash时，修改（新建）在用户目录下的<code>~/.ssh/config</code>文件，新加如下内容。</p><pre><code class="hljs bash">host github.comHostName github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaProxyCommand connect -S 127.0.0.1:1080 %h %p</code></pre><p>macos的connect可以用brew安装，而windows的git bash中已有：</p><pre><code class="hljs bash">brew install connect</code></pre><p>对于Ubuntu：</p><pre><code class="hljs bash">apt-get install connect-proxy</code></pre><p>某些发行版可能没有connect软件包，这个地址下载源码编译一下就好了。</p><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>bitbucket.org<span class="hljs-regexp">/gotoh/</span>connect<span class="hljs-regexp">/src/</span>default/</code></pre><p>对于http：</p><pre><code class="hljs bash">git config --global http.proxy <span class="hljs-string">&quot;socks5://127.0.0.1:1080&quot;</span>git config --global https.proxy <span class="hljs-string">&quot;socks5://127.0.0.1:1080&quot;</span></code></pre><p>node的淘宝源</p><pre><code class="hljs bash">npm config <span class="hljs-built_in">set</span> registry https://registry.npm.taobao.org</code></pre><pre><code class="hljs bash">npm config <span class="hljs-built_in">set</span> registry https://registry.npmjs.org</code></pre><h2 id="早期计划"><a href="#早期计划" class="headerlink" title="早期计划"></a>早期计划</h2><h3 id="内容分发网络"><a href="#内容分发网络" class="headerlink" title="内容分发网络"></a>内容分发网络</h3><p>之前就有在使用cdn来加速图片的访问，效果也还是不错的。但是整体blog的内容还都是有1M服务器上的php生成的。所以就算异地图片加载速度再快，终端也需要连接到身在华南的服务器。无论是人多还是人少，速度总是不理想。</p><p>最后打算使用纯静态的blog，直接部署到cdn上，速度肯定是无可比拟的。但是还是有一点弊端的，例如cdn节点可能更新不及时等问题。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>正好手头有个1M出口的ECS，嫌它太慢。而它的真正作用在于和阿里云的oss进行通信，因为走的是阿里云的内网，所以通过ECS上传文件到oss是不需要收流量费用的。而ECS仅仅只是出口1M而已，入口是不限速的。如果需要最大化节约的上传文件到oss，可以通过ECS传。</p><p>阿里云的oss在linux上有个可以连接oss的软件，但是那个操作并不是我想需要的。好在阿里云还有一款<a href="https://help.aliyun.com/document_detail/32196.html?spm=a2c4g.11186623.6.749.72b73adfsKCqTT">ossfs</a>软件。它可以将对象存储OSS的存储空间（Bucket）挂载到本地文件系统中，能够像操作本地文件一样操作OSS的对象（Object），实现数据的共享。</p><p>这对于写静态blog来说实在是太方便了，只需要将Bucket挂载到本地文件夹，就像挂载磁盘那样操作。随后就可以不用流量的将静态文件上传到oss。</p><p>开启OSS的静态网站托管，将hexo生成的静态blog都放到挂载的目录下即可。非常的方便，文章内的图片也可以使用相对路径，而不需要一张一张的插入外链那么麻烦了。</p><p>需要注意一点的是：使用OSS默认域名访问时，Response Header中会自动加上<code> Content-Disposition:&#39;attachment=filename;&#39;</code>。即从浏览器访问网页类型文件时，不会显示文件内容，而是以附件形式进行下载。也就是说需要绑定自己的域名才能静态托管。</p><h3 id="多重备份"><a href="#多重备份" class="headerlink" title="多重备份"></a>多重备份</h3><p>这种方案解决的好处就是，可以在多个地方实现多重的数据备份。且不需要在备份数据库了。</p><ul><li>Github一份备份</li><li>CDN一份备份</li><li>ECS一份备份</li><li>自己的电脑还可以有多份备份</li></ul><p>一步直接实现异地多备份。</p><h3 id="OSSFS"><a href="#OSSFS" class="headerlink" title="OSSFS"></a>OSSFS</h3><p>目前有多个发行版的安装包：</p><table><thead><tr><th align="left">Linux发行版</th><th align="left">下载</th></tr></thead><tbody><tr><td align="left">Ubuntu 18.04 (x64)</td><td align="left"><a href="http://gosspublic.alicdn.com/ossfs/ossfs_1.80.6_ubuntu18.04_amd64.deb">ossfs_1.80.6_ubuntu18.04_amd64.deb</a></td></tr><tr><td align="left">Ubuntu 16.04 (x64)</td><td align="left"><a href="http://gosspublic.alicdn.com/ossfs/ossfs_1.80.6_ubuntu16.04_amd64.deb">ossfs_1.80.6_ubuntu16.04_amd64.deb</a></td></tr><tr><td align="left">Ubuntu 14.04 (x64)</td><td align="left"><a href="http://gosspublic.alicdn.com/ossfs/ossfs_1.80.6_ubuntu14.04_amd64.deb">ossfs_1.80.6_ubuntu14.04_amd64.deb</a></td></tr><tr><td align="left">CentOS 7.0 (x64)</td><td align="left"><a href="http://gosspublic.alicdn.com/ossfs/ossfs_1.80.6_centos7.0_x86_64.rpm">ossfs_1.80.6_centos7.0_x86_64.rpm</a></td></tr><tr><td align="left">CentOS 6.5 (x64)</td><td align="left"><a href="http://gosspublic.alicdn.com/ossfs/ossfs_1.80.6_centos6.5_x86_64.rpm">ossfs_1.80.6_centos6.5_x86_64.rpm</a></td></tr></tbody></table><p>下载到主机内后，根据不同的发行版进行安装就好了。而对于Ubuntu需要使用gdebi：</p><pre><code class="hljs bash">sudo apt-get updatesudo apt-get install gdebi-coresudo gdebi your_ossfs_package</code></pre><h4 id="配置账号信息"><a href="#配置账号信息" class="headerlink" title="配置账号信息"></a>配置账号信息</h4><p>成功了安装了之后就可以配置oss的账号信息来登陆。使用AccessKeyId/AccessKeySecret来代替账号密码进行访问。如果担心安全问题还可以使用阿里云的子账号只赋予oss的访问权限，来最大程度的保护账户资产。在阿里云的<a href="https://ram.console.aliyun.com/overview">RAM访问控制</a>中可以进行添加子账户并赋予特定的权限。</p><p><img src="../images/%E5%86%99%E4%BD%9C%E4%B8%8E%E5%8D%8F%E4%BD%9C/image-20200229104812836.webp" alt="image-20200229104812836"></p><p>AccessKeyId/AccessKeySecret信息存放在<code>/etc/passwd-ossfs</code>文件中。并且文件的权限必须正确设置，建议设为640。</p><p>格式为：<code>bucket名:AccessKeyId:AccessKeySecret</code></p><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> my-bucket:my-access-key-id:my-access-key-secret &gt; /etc/passwd-ossfschmod 640 /etc/passwd-ossfs</code></pre><p>如果需要配置多个账号或者多个bucket，可以直接将账号信息写在后面，ossfs会根据挂载的存储空间名称匹配到正确的账号上。</p><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> my-second-bucket:my-access-key-id:my-access-key-secret &gt;&gt; /etc/passwd-ossfs</code></pre><h4 id="挂载到指定目录"><a href="#挂载到指定目录" class="headerlink" title="挂载到指定目录"></a>挂载到指定目录</h4><p>账号信息填写的非常简单，写到指定文件里就可以了。填完之后就可以将oss挂载到本地的指定目录上。</p><p>格式为：<code>ossfs bucket名 本地挂载点 -ourl=oss url</code></p><pre><code class="hljs applescript">ossfs <span class="hljs-keyword">my</span>-bucket <span class="hljs-keyword">my</span>-mount-point -ourl=<span class="hljs-keyword">my</span>-oss-endpoint</code></pre><p>如果正好使用的是阿里云的ECS机器，可以走oss的内网，在上传文件时就不会产生多余的流量费用。通常oss的内网域名包含internal。例如：</p><pre><code class="hljs css"><span class="hljs-selector-tag">oss-cn-beijing-internal</span><span class="hljs-selector-class">.aliyuncs</span><span class="hljs-selector-class">.com</span></code></pre><p>只需要将近4条左右的命令就可以将oss成功挂载到本地上，就如同一个文件夹。</p><h4 id="开机自动挂载"><a href="#开机自动挂载" class="headerlink" title="开机自动挂载"></a>开机自动挂载</h4><p>和开机自动挂载分区一样，Ubuntu需要在<code>/etc/fstab</code>中进行操作。</p><pre><code class="hljs bash">ossfs<span class="hljs-comment">#bucket_name mount_point fuse _netdev,url=url,allow_other 0 0</span></code></pre><p>对应的填入了信息之后，可以使用<code>mount -a</code>进行测试。如果没有任何报错，即代表成功。</p><h3 id="阿里云子目录"><a href="#阿里云子目录" class="headerlink" title="阿里云子目录"></a>阿里云子目录</h3><p>阿里云oss的默认配置是不会去访问子目录下的首页的，子目录下的<code>index.html</code>必须访问全部的静态链接。否则会跳转回主页的<code>index.html</code>。</p><p>网上的大多数解决办法就是修改hexo的配置，把所有的子目录的绝对路径都生成出来。这是一种解决办法，但不能从根源上解决所有问题。</p><p>并且阿里云也早就支持了子目录首页了。只需要简单开一下就能解决这个问题。</p><p><img src="../images/%E5%86%99%E4%BD%9C%E4%B8%8E%E5%8D%8F%E4%BD%9C/image-20200401100940056.webp" alt="image-20200401100940056"></p>]]></content>
    
    
    <categories>
      
      <category>实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript笔记-引用类型</title>
    <link href="/defect/javascript-notes-reference-type.html"/>
    <url>/defect/javascript-notes-reference-type.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>这是来自Professional JavaScript for Web Develops第五章的笔记。</p></blockquote><p><img src="../images/JavaScript%E7%AC%94%E8%AE%B0-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/javascript.webp" alt="javascript"></p><h2 id="基本类型和引用类型"><a href="#基本类型和引用类型" class="headerlink" title="基本类型和引用类型"></a>基本类型和引用类型</h2><p>基本类型值指的是简单的数据段。</p><p>引用类型值指那些可能由多个值构成的对象。</p><p>JS的五种基本数据类型就是基本类型值。这五种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。</p><p>引用类型的值是保存在内存中的对象。js不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。在复制保存着对象的某个变量时，操作的是变量的引用。但为变量添加属性时，操作的是实际的对象。</p><p>传递参数只有按值传递，没有按引用传递：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = &#123;&#125;;<span class="hljs-literal">undefined</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setName</span>(<span class="hljs-params">ojb</span>) </span>&#123;ojb.name = <span class="hljs-string">&#x27;xfy&#x27;</span>;&#125;<span class="hljs-literal">undefined</span>setName(person);<span class="hljs-literal">undefined</span>person.name;<span class="hljs-string">&quot;xfy&quot;</span></code></pre><p>当在函数内，将ojb2重新声明为一个新的对象。如果参数是按引用传递的，person对象应该自动修改name属性值指向<code>&#39;notxfy&#39;</code>。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setName2</span>(<span class="hljs-params">ojb2</span>) </span>&#123;ojb2.name = <span class="hljs-string">&#x27;xfy2&#x27;</span>;ojb2 = &#123;&#125;;ojb2.name = <span class="hljs-string">&#x27;notxfy&#x27;</span>;&#125;<span class="hljs-literal">undefined</span>setName2(person);<span class="hljs-literal">undefined</span>person.name<span class="hljs-string">&quot;xfy2&quot;</span></code></pre><p>js引用类型的值（对象）是引用类型的一个实例。引用类型是一种数据结构，用于将数据和功能组织在一起。虽然引用类型和类看起来类似，但是它们不是相同的概念。</p><p>对象是某个特定引用类型的实例。</p><h2 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h2><p>Object是目前ECMAScript中使用最多的一个语言。虽然Object实例不具备多少功能，对对于在应用程序中存储和传输数据而言，它们确实是非常理想的选择。</p><h3 id="创建Object实例"><a href="#创建Object实例" class="headerlink" title="创建Object实例"></a>创建Object实例</h3><p>创建方式有两种。第一种是new操作符后接Object构造函数。构造函数本身就是一个函数，只不过它时出于创建新对象的目的而定义的。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();person.name = <span class="hljs-string">&quot;Defectink&quot;</span>;person.age = <span class="hljs-number">8</span>;</code></pre><p>另外一种是使用对象字面量：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> person2 = &#123;    name = <span class="hljs-string">&quot;xfy&quot;</span>,    age = <span class="hljs-number">88</span>&#125;</code></pre><p>左边的花括号表示对象字面量的开始，因为它出现在表达式上下文（expression context）中。同样的花括号如果出现在一个语句上下文（statement context）中，则表示一个语句块的开始。例如if语句的花括号。</p><p>在对象字面量中使用逗号来分隔不同的属性。最后一个属性不添加逗号。</p><p>在使用对象字面量语法时，属性名也可以使用字符串。</p><p>对象字面量还有另外一种写法：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> person3 = &#123;&#125;;person3.name = <span class="hljs-string">&#x27;xxx&#x27;</span>;person3.age = <span class="hljs-number">3</span>;</code></pre><h4 id="传递大量参数"><a href="#传递大量参数" class="headerlink" title="传递大量参数"></a>传递大量参数</h4><p>对象字面量也是想函数传递大量可选参数的首选方式。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> output = <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showInfo</span>(<span class="hljs-params">args</span>)</span>&#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> args.name == <span class="hljs-string">&quot;string&quot;</span>)&#123;        output += <span class="hljs-string">&quot;the Name: &quot;</span> + args.name + <span class="hljs-string">&quot;\n&quot;</span>;    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> args.age == <span class="hljs-string">&quot;number&quot;</span>)&#123;        output += <span class="hljs-string">&quot;the Age: &quot;</span> + args.age + <span class="hljs-string">&quot;\n&quot;</span>;    &#125;    alert(output);&#125;showInfo(&#123;    name:<span class="hljs-string">&quot;test&quot;</span>,    age: <span class="hljs-number">128</span>&#125;)</code></pre><p>函数showInfo()接收一个名为args的参数。这个参数可能带有名为name或age的属性，又或者这两个属性都有或没有。每次都可以使用一个对象字面量来传递不同的可选数据。</p><p>通常访问对象属性都是用点表示法。在js中也可以使用方括号表示法来访问对象的属性。</p><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(personn.name);<span class="hljs-built_in">console</span>.log(person[<span class="hljs-string">&quot;name&quot;</span>]);</code></pre><p>这两种方法没有任何区别。但方括号的优点时可以通过变量来访问属性。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> personAnotherName = <span class="hljs-string">&#x27;test&#x27;</span>;<span class="hljs-built_in">console</span>.log(person[personAnotherName]);</code></pre><h2 id="Array类型"><a href="#Array类型" class="headerlink" title="Array类型"></a>Array类型</h2><p>js的数组是数据的有序列表。数组的每一项都都可以用来保存任何类型的数据。数组的大小也是可以动态调整的，即可以随着数据的添加自动增长以容纳新数据。</p><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><p>使用Array构造函数：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> colors = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();</code></pre><p>Array构造函数可以传递数组的数量，创建十个数组：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> colors = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">10</span>);</code></pre><p>传递的参数还能用于创建数组的内容，但是不能创建纯数字的内容：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> colors = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">3</span>);      <span class="hljs-comment">//create an array with three items</span><span class="hljs-keyword">let</span> names = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-string">&quot;Greg&quot;</span>);  <span class="hljs-comment">//create an array with one item, the string &quot;Greg&quot;</span></code></pre><p>可以省略new操作符：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> colors = <span class="hljs-built_in">Array</span>(<span class="hljs-number">3</span>);      <span class="hljs-keyword">let</span> names = <span class="hljs-built_in">Array</span>(<span class="hljs-string">&quot;Greg&quot;</span>);</code></pre><p>使用字面量表示法：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> colors = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>]; <span class="hljs-comment">//creates an array with three strings</span><span class="hljs-keyword">let</span> names = [];                        <span class="hljs-comment">//creates an empty array</span><span class="hljs-keyword">let</span> values = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,];                   <span class="hljs-comment">//AVOID! Creates an array with 2 or 3 items</span><span class="hljs-keyword">let</span> options = [,,,,,];                 <span class="hljs-comment">//AVOID! creates an array with 5 or 6 items</span></code></pre><h3 id="读取数组"><a href="#读取数组" class="headerlink" title="读取数组"></a>读取数组</h3><p>使用方括号并提供相应值的基于0的数字索引：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> colors = [<span class="hljs-string">&#x27;red&#x27;</span>,<span class="hljs-string">&#x27;blue&#x27;</span>,<span class="hljs-string">&#x27;green&#x27;</span>];colors[<span class="hljs-number">0</span>];colors[<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;test&#x27;</span>;<span class="hljs-comment">//修改</span>colors[<span class="hljs-number">3</span>] = <span class="hljs-string">&#x27;new one&#x27;</span>;<span class="hljs-comment">//新增</span></code></pre><p>数组的项数保存在length属性中，这个属性始终都会返回0或更大的值。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> colors = [<span class="hljs-string">&#x27;red&#x27;</span>,<span class="hljs-string">&#x27;blue&#x27;</span>,<span class="hljs-string">&#x27;green&#x27;</span>];colors.length;<span class="hljs-number">3</span></code></pre><p>length属性不是只读的，可以通过设置这个属性来向数组的末尾添加或移除内容。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> colors = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>];    <span class="hljs-comment">//creates an array with three strings</span>colors.length = <span class="hljs-number">2</span>;alert(colors[<span class="hljs-number">2</span>]);        <span class="hljs-comment">//undefined</span><span class="hljs-keyword">let</span> colors = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>];    <span class="hljs-comment">//creates an array with three strings</span>colors.length = <span class="hljs-number">4</span>;alert(colors[<span class="hljs-number">3</span>]);        <span class="hljs-comment">//undefined</span></code></pre><p>数组的最后一项索引始终都是length-1，所以可以使用length方便在末尾添加内容。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> colors = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>];    <span class="hljs-comment">//creates an array with three strings</span>colors[colors.length] = <span class="hljs-string">&quot;black&quot;</span>;          <span class="hljs-comment">//add a color</span>colors[colors.length] = <span class="hljs-string">&quot;brown&quot;</span>;          <span class="hljs-comment">//add another color</span>alert(colors.length);    <span class="hljs-comment">//5</span>alert(colors[<span class="hljs-number">3</span>]);        <span class="hljs-comment">//black</span>alert(colors[<span class="hljs-number">4</span>]);        <span class="hljs-comment">//brown</span></code></pre><blockquote><p>数组最多可以包含4 294 967 295个项</p></blockquote><p>join()方法可以重现toString()的输出。定义数组分隔符。如果不给join()方法传入任何值，或者传入undefineed，则使用逗号。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> colors = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>];alert(colors.join(<span class="hljs-string">&quot;,&quot;</span>));      <span class="hljs-comment">//red,green,blue</span>alert(colors.join(<span class="hljs-string">&quot;||&quot;</span>));     <span class="hljs-comment">//red||green||blue</span></code></pre><h3 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h3><p>栈是一种可以限制插入和删除项的数据结构。栈是一种LIFO（Last-In-First-Out，后进先出）的数据结构。</p><p>栈项中的插入（推入）和移除（弹出）只发生在一个位置——栈的顶部。数组有push()和pop()方法实现了类似栈的行为。</p><p>push()将参数逐个添加到数组的末尾，并返回修改后数组的长度。</p><p>pop()将从数组末尾中移除一项，减少length的值，并返回移除的项。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> colors = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();                      <span class="hljs-comment">//create an array</span><span class="hljs-keyword">let</span> count = colors.push(<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>);       <span class="hljs-comment">//push two items</span>alert(count);  <span class="hljs-comment">//2</span>count = colors.push(<span class="hljs-string">&quot;black&quot;</span>);                  <span class="hljs-comment">//push another item on</span>alert(count);  <span class="hljs-comment">//3</span><span class="hljs-keyword">let</span> item = colors.pop();                       <span class="hljs-comment">//get the last item</span>alert(item);   <span class="hljs-comment">//&quot;black&quot;</span>alert(colors.length);  <span class="hljs-comment">//2</span></code></pre><p>栈方法可以和其他数组方法连用。</p><pre><code class="hljs js">      <span class="hljs-keyword">let</span> colors = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>];      colors.push(<span class="hljs-string">&quot;brown&quot;</span>);              <span class="hljs-comment">//add another item</span>      colors[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;black&quot;</span>;               <span class="hljs-comment">//add an item</span>      alert(colors.length);  <span class="hljs-comment">//4</span><span class="hljs-keyword">let</span> item = colors.pop();item;<span class="hljs-comment">//&quot;black&quot;</span>colors;<span class="hljs-comment">// [&quot;red&quot;, &quot;blue&quot;, &quot;brown&quot;]</span></code></pre><h3 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h3><p>队列数据结构的访问顺序是FIFO（First-In-First-Out，先进先出）。数组有shift()方法，它能够移除数组的第一个项，减少length值，并返回该项。它就像和pop()方法相反的操作。</p><p>结合shift()和push()方法，可以像队列一样使用数组。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> colors = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();                      <span class="hljs-comment">//create an array</span><span class="hljs-keyword">let</span> count = colors.push(<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>);       <span class="hljs-comment">//push two items</span>alert(count);  <span class="hljs-comment">//2</span>count = colors.push(<span class="hljs-string">&quot;black&quot;</span>);                  <span class="hljs-comment">//push another item on</span>alert(count);  <span class="hljs-comment">//3</span><span class="hljs-keyword">let</span> item = colors.shift();                     <span class="hljs-comment">//get the first item</span>alert(item);   <span class="hljs-comment">//&quot;red&quot;</span>alert(colors.length);  <span class="hljs-comment">//2</span></code></pre><p>数组还有个unshift()方法，它在数组前端添加添加任意个项，并返回修改后数组的长度。它就像和push()相反的操作。</p><p>结合unshift()和pop()方法可以反向模拟队列操作。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> colors = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();                      <span class="hljs-comment">//create an array</span><span class="hljs-keyword">let</span> count = colors.unshift(<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>);    <span class="hljs-comment">//push two items</span>alert(count);  <span class="hljs-comment">//2</span>count = colors.unshift(<span class="hljs-string">&quot;black&quot;</span>);               <span class="hljs-comment">//push another item on</span>alert(count);  <span class="hljs-comment">//3</span><span class="hljs-keyword">let</span> item = colors.pop();                     <span class="hljs-comment">//get the first item</span>alert(item);   <span class="hljs-comment">//&quot;green&quot;</span>alert(colors.length);  <span class="hljs-comment">//2</span></code></pre><h3 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h3><p>数组中有两个可以重排序的方法：reverse()和sort()。</p><p>reverse()对数组反向排序：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> values = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];values.reverse();alert(values);       <span class="hljs-comment">//5,4,3,2,1</span></code></pre><p>sort()按升序排列数组——即最小的值位于最前面。sort()会调用每个数组项的toString()转型方法。然后比较得到的字符串。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> values = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>];values.sort();alert(values);    <span class="hljs-comment">//0,1,10,15,5</span></code></pre><p>由于1&lt;5，所有10会被排在5前面。所以sort()可以接受一个比较函数来重新排序。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compare</span>(<span class="hljs-params">v1,v2</span>)</span>&#123;    <span class="hljs-keyword">if</span> (v1 &lt; v2)&#123;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;<span class="hljs-keyword">else</span> <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-params">v1 &gt; v2</span>)</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;&#125;<span class="hljs-keyword">let</span> values = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>];values.sort(compare);(<span class="hljs-number">5</span>) [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>]</code></pre><blockquote><p>reverse()和sort()返回的是经过排序之后的数组。</p></blockquote><p>对于数值类型或者其valueOf()方法会返回数值类型的对象类型，可以使用一个更简单的比较函数。只要有第二个值减第一个值即可。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compare2</span>(<span class="hljs-params">v1,v2</span>)</span>&#123;    v2 - v1;&#125;values.sort(compare2);(<span class="hljs-number">5</span>) [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>]</code></pre><h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><p>concat()基于当前数组中所有项目创建一个新的数组。它会先创建一个数组副本，然后将参数添加到这个副本的末尾，返回新构建的数组。没有传递参数时，它只是返回副本。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> colors = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>];<span class="hljs-keyword">let</span> colors2 = colors.concat(<span class="hljs-string">&quot;yellow&quot;</span>, [<span class="hljs-string">&quot;black&quot;</span>, <span class="hljs-string">&quot;brown&quot;</span>]);alert(colors);     <span class="hljs-comment">//red,green,blue        </span>alert(colors2);    <span class="hljs-comment">//red,green,blue,yellow,black,brown</span></code></pre><pre><code class="hljs js"><span class="hljs-keyword">let</span> colors = [<span class="hljs-string">&#x27;red&#x27;</span>,<span class="hljs-string">&#x27;blue&#x27;</span>,<span class="hljs-string">&#x27;green&#x27;</span>];<span class="hljs-literal">undefined</span><span class="hljs-keyword">let</span> color2 = [<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>];<span class="hljs-literal">undefined</span>color2.concat(colors);(<span class="hljs-number">6</span>) [<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>]</code></pre><p>slice()基于当前数组中的指定位置创建一个新的数组。它接受两个参数，即起始位置和结束位置（不返回结束位置的项）。当只有 一个参数时，返回直到数组末尾的所有项。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> colors = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;yellow&quot;</span>, <span class="hljs-string">&quot;purple&quot;</span>];<span class="hljs-keyword">let</span> colors2 = colors.slice(<span class="hljs-number">1</span>);<span class="hljs-keyword">let</span> colors3 = colors.slice(<span class="hljs-number">1</span>,<span class="hljs-number">4</span>);alert(colors2);   <span class="hljs-comment">//green,blue,yellow,purple</span>alert(colors3);   <span class="hljs-comment">//green,blue,yellow</span></code></pre><p>splice()是功能更全面的数组操作方法。</p><ul><li>删除：可以删除任意数量的项，指定两个参数：要删除的第一项位置和要删除的项数。<code>splice(0,2)</code></li><li>插入：可以向指定位置插入任意数量的项。指定三个参数：起始位置、0（要删除的项数）和需要插入的项。<code>splice(2,0,&#39;red&#39;,&#39;green&#39;)</code></li><li>替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项。指定三个参数：起始位置、要删除的项数和要插入的项。<code>splice(2,1,&#39;red&#39;,&#39;blcak&#39;)</code></li></ul><p>插入和删除都在起始位开始。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> colors = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>];<span class="hljs-keyword">let</span> removed = colors.splice(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);              <span class="hljs-comment">//remove the first item</span>alert(colors);     <span class="hljs-comment">//green,blue</span>alert(removed);    <span class="hljs-comment">//red - one item array</span>removed = colors.splice(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;yellow&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>);  <span class="hljs-comment">//insert two items at position 1</span>alert(colors);     <span class="hljs-comment">//green,yellow,orange,blue</span>alert(removed);    <span class="hljs-comment">//empty array</span>removed = colors.splice(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;purple&quot;</span>);    <span class="hljs-comment">//insert two values, remove one</span>alert(colors);     <span class="hljs-comment">//green,red,purple,orange,blue</span>alert(removed);    <span class="hljs-comment">//yellow - one item array</span></code></pre><h3 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h3><p>ECMAScript5为数组添加了两个位置方法：indexOf()和lastIndexOf()。他们都接受两个参数：要查找的项和（可选）起始位置的索引。</p><p>indexOf()从数组开头索引，lastIndexOf()从数组末尾开始索引。</p><p>接受两个参数：要查找的项和（可选）表示查找位置地点的索引。返回查找到的位置索引，没找返回-1。比较查找项时会使用全等操作。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>];<span class="hljs-built_in">console</span>.log(arr.indexOf(<span class="hljs-number">3</span>));<span class="hljs-built_in">console</span>.log(arr.lastIndexOf(<span class="hljs-number">3</span>));<span class="hljs-built_in">console</span>.log(arr.indexOf(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>));<span class="hljs-built_in">console</span>.log(arr.lastIndexOf(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>));<span class="hljs-keyword">let</span> person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Nicholas&quot;</span> &#125;;<span class="hljs-keyword">let</span> people = [&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Nicholas&quot;</span> &#125;];<span class="hljs-keyword">let</span> morePeople = [person];alert(people.indexOf(person));     <span class="hljs-comment">//-1</span>alert(morePeople.indexOf(person)); <span class="hljs-comment">//0</span></code></pre><h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><ul><li>every()：对数组的每一项运行给定的函数，每一项都返回ture，则返回ture。</li><li>filter()：对数组的每一项运行给定的函数，返回函数会返回ture组成的数组。</li><li>forEach()：对数组的每一项运行给定的函数，没有返回值。</li><li>map()：对数组的每一项运行给定的函数，返回函数调用结果。</li><li>some()：对数组的每一项运行给定的函数，任意一项返回ture，返回ture。</li></ul><p>所有方法都不会修改数组中的包含的值。</p><p>every()</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> dd = <span class="hljs-function"><span class="hljs-params">input</span> =&gt;</span> input &lt; <span class="hljs-number">9</span>;<span class="hljs-comment">// let dd = function (input) &#123;</span><span class="hljs-comment">//     return input &lt; 9;</span><span class="hljs-comment">// &#125;</span><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<span class="hljs-built_in">console</span>.log(arr.every(dd));<span class="hljs-comment">//ture</span></code></pre><p>filter()</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> ff = <span class="hljs-function"><span class="hljs-params">word</span> =&gt;</span> word.length &gt; <span class="hljs-number">5</span>;<span class="hljs-keyword">let</span> arr2 = [<span class="hljs-string">&#x27;spray&#x27;</span>, <span class="hljs-string">&#x27;limit&#x27;</span>, <span class="hljs-string">&#x27;elite&#x27;</span>, <span class="hljs-string">&#x27;exuberant&#x27;</span>, <span class="hljs-string">&#x27;destruction&#x27;</span>, <span class="hljs-string">&#x27;present&#x27;</span>];<span class="hljs-built_in">console</span>.log(arr2.filter(ff));</code></pre><p>forEach()，可以用来遍历数组</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr3 = [<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];arr3.forEach(<span class="hljs-function"><span class="hljs-params">ele</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(ele));</code></pre><p>map()</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr4 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];<span class="hljs-built_in">console</span>.log(arr4.map(<span class="hljs-function"><span class="hljs-params">sx</span> =&gt;</span> (sx + <span class="hljs-number">1</span>) * <span class="hljs-number">2</span> / <span class="hljs-number">3</span>));</code></pre><p>some()</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr5 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<span class="hljs-built_in">console</span>.log(arr5.some(<span class="hljs-function"><span class="hljs-params">qy</span> =&gt;</span> qy % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>));</code></pre><h3 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h3><p>reduce()和reduceRight()。这两个方法都会迭代数组的所有项，然后构建一个最终返回值。reduceRgiht()从数组的最后一项开始遍历到开头。</p><p>他们都接受四个参数：</p><ol><li>Accumulator (acc) (累计器)</li><li>Current Value (cur) (当前值)</li><li>Current Index (idx) (当前索引)</li><li>Source Array (src) (源数组)</li></ol><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];<span class="hljs-built_in">console</span>.log(arr.reduce(<span class="hljs-function">(<span class="hljs-params">a1,a2</span>) =&gt;</span> a1 + a2));<span class="hljs-built_in">console</span>.log(arr.reduceRight(<span class="hljs-function">(<span class="hljs-params">a1,a2</span>) =&gt;</span> a1 + a2));</code></pre><h2 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a>Date类型</h2><p>Date类型使用自1970年1月1日开始以来的毫秒数来保存日期。</p><p>创建日期对象，使用new操作符和Date构造函数。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> dd = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<span class="hljs-keyword">let</span> d2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2017</span>, <span class="hljs-number">0</span>2, <span class="hljs-number">0</span>1);<span class="hljs-keyword">let</span> d3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-built_in">Date</span>.UTC(<span class="hljs-number">2000</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">21</span>, <span class="hljs-number">23</span>, <span class="hljs-number">31</span>));</code></pre><p>Date()构造函数会假设第一个参数是年份，第二个参数是月份，以此类推。</p><p>Date.now()返回调用这个方法时日期和时间的毫秒数，可以用来做一个简单计时。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> start = <span class="hljs-built_in">Date</span>.now();<span class="hljs-built_in">console</span>.log(start);<span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">666</span>,<span class="hljs-number">745</span>,<span class="hljs-number">23</span>,<span class="hljs-number">441</span>,<span class="hljs-number">323</span>,<span class="hljs-number">123123</span>,<span class="hljs-number">123</span>,<span class="hljs-number">123</span>,<span class="hljs-number">85858585</span>,,<span class="hljs-number">3</span>,<span class="hljs-number">23</span>,<span class="hljs-number">1</span>,<span class="hljs-number">23</span>,<span class="hljs-number">123123123123</span>];<span class="hljs-built_in">console</span>.log(arr.reduce(<span class="hljs-function">(<span class="hljs-params">a1, a2</span>) =&gt;</span> a1 + a2));<span class="hljs-keyword">let</span> stop = <span class="hljs-built_in">Date</span>.now();<span class="hljs-built_in">console</span>.log(stop);<span class="hljs-keyword">let</span> result = stop - start;<span class="hljs-built_in">console</span>.log(result);</code></pre><p>使用+操作符获取Date对象的时间戳也可以达到同样的目的。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> test = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();</code></pre><h3 id="继承的方法"><a href="#继承的方法" class="headerlink" title="继承的方法"></a>继承的方法</h3><p>与其他的引用类型一样，Date也重写了toLocalString()、toString()和valueOf()方法。</p><p><code>toLocaleString()</code> 方法返回该日期对象的字符串，该字符串格式因不同语言而不同。</p><p><code>toString()</code> 方法返回一个字符串，表示该Date对象。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> d4 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<span class="hljs-built_in">console</span>.log(d4.toLocaleString());<span class="hljs-built_in">console</span>.log(d4.toString())<span class="hljs-comment">// 3/5/2020, 10:00:01 PM</span><span class="hljs-comment">// Thu Mar 05 2020 22:00:01 GMT+0800 (China Standard Time)</span></code></pre><p><code>valueOf() </code>方法返回一个 Date 对象的原始值。即返回毫秒数。</p><h2 id="RegExp类型"><a href="#RegExp类型" class="headerlink" title="RegExp类型"></a>RegExp类型</h2><p>js通过RegExp类型来支持正则表达式。</p><p>创建使用字面量, 构造函数和工厂符号都是可以的：</p><pre><code class="hljs js">/pattern/flags<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(pattern [, flags])<span class="hljs-built_in">RegExp</span>(pattern [, flags])</code></pre><p>Flags：</p><ul><li>g：全局匹配;找到所有匹配，而不是在第一个匹配后停止</li><li>i：忽略大小写</li><li>m：多行; 将开始和结束字符（^和$）视为在多行上工作（也就是，分别匹配每一行的开始和结束（由 \n 或 \r 分割），而不只是只匹配整个输入字符串的最开始和最末尾处。</li></ul><p>使用构造函数创建时，参数需要使用字符串：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> pattern2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&quot;[bc]at&quot;</span>,<span class="hljs-string">&quot;g&quot;</span>);</code></pre><p>所以在构造函数的情况下可能需要双重转义</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> pattern3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&quot;\\[bc\\]at&quot;</span>,<span class="hljs-string">&quot;g&quot;</span>);</code></pre><p>由于实例属性不会重置，所以在循环中再次调用test()方法会失败。第一次找到了cat，第二次会从上一次匹配的末尾开始寻找。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> re = <span class="hljs-literal">null</span>,    i;<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;    re = <span class="hljs-regexp">/cat/g</span>;    re.test(<span class="hljs-string">&#x27;catastrophe&#x27;</span>);&#125;<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;    re = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&quot;cat&quot;</span>,<span class="hljs-string">&quot;g&quot;</span>);    re.test(<span class="hljs-string">&#x27;catastrophe&#x27;</span>)&#125;</code></pre><h3 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h3><p>  <code>RegExp.prototype.constructor</code></p><p>  创建该正则对象的构造函数。</p><p>  <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/global"><code>RegExp.prototype.global</code></a></p><p>  是否开启全局匹配，也就是匹配目标字符串中所有可能的匹配项，而不是只进行第一次匹配。</p><p>  <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/ignoreCase"><code>RegExp.prototype.ignoreCase</code></a></p><p>  在匹配字符串时是否要忽略字符的大小写。</p><p>  <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastIndex"><code>RegExp.prototype.lastIndex</code></a></p><p>  下次匹配开始的字符串索引位置。</p><p>  <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/multiline"><code>RegExp.prototype.multiline</code></a></p><p>  是否开启多行模式匹配（影响 ^ 和 $ 的行为）。</p><p>  <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/source"><code>RegExp.prototype.source</code></a></p><p>  正则对象的源模式文本。</p><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(pattern.global);<span class="hljs-built_in">console</span>.log(pattern.ignoreCase);<span class="hljs-built_in">console</span>.log(pattern.multiline);<span class="hljs-built_in">console</span>.log(pattern.lastIndex);<span class="hljs-built_in">console</span>.log(pattern.source);</code></pre><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><p>exec()和test()。</p><p>exec()设置了全局模式也只会返回一个匹配项，多次调用一次返回向后匹配到的值。而不设置全局模式则只返回第一次匹配到的匹配项。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> text = <span class="hljs-string">&quot;cat, bat, sat, fat&quot;</span>;        <span class="hljs-keyword">var</span> pattern1 = <span class="hljs-regexp">/.at/</span>;<span class="hljs-keyword">var</span> matches = pattern1.exec(text);        alert(matches.index);    <span class="hljs-comment">//0</span>alert(matches[<span class="hljs-number">0</span>]);       <span class="hljs-comment">//&quot;cat&quot;</span>alert(pattern1.lastIndex);<span class="hljs-comment">//0</span>matches = pattern1.exec(text);        alert(matches.index);    <span class="hljs-comment">//0</span>alert(matches[<span class="hljs-number">0</span>]);       <span class="hljs-comment">//&quot;cat&quot;</span>alert(pattern1.lastIndex);<span class="hljs-comment">//0</span><span class="hljs-keyword">var</span> pattern2 = <span class="hljs-regexp">/.at/g</span>;<span class="hljs-keyword">var</span> matches = pattern2.exec(text);        alert(matches.index);    <span class="hljs-comment">//0</span>alert(matches[<span class="hljs-number">0</span>]);       <span class="hljs-comment">//&quot;cat&quot;</span>alert(pattern2.lastIndex);<span class="hljs-comment">//0</span>matches = pattern2.exec(text);        alert(matches.index);    <span class="hljs-comment">//5</span>alert(matches[<span class="hljs-number">0</span>]);       <span class="hljs-comment">//&quot;bat&quot;</span>alert(pattern2.lastIndex);<span class="hljs-comment">//0</span></code></pre><p>test()接受一个字符串参数，在模式与该参数匹配的情况下返回ture。通常与if语句一起使用。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> text = <span class="hljs-string">&#x27;123-00-12345&#x27;</span>;<span class="hljs-keyword">let</span> pattern4 = <span class="hljs-regexp">/\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;/</span>;<span class="hljs-keyword">if</span> (pattern4.test(text)) &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;all matched&#x27;</span>);&#125;</code></pre><h2 id="Function类型"><a href="#Function类型" class="headerlink" title="Function类型"></a>Function类型</h2><p>函数实际上是对象，函数名是指针。所以函数名与包装对象指针的其他变量没有什么不同。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span> (<span class="hljs-params">a,b</span>) </span>&#123;    <span class="hljs-keyword">return</span> a + b;&#125;<span class="hljs-keyword">let</span> anotherSum = sum;<span class="hljs-built_in">console</span>.log(anotherSum(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>));sum = <span class="hljs-literal">null</span>;<span class="hljs-built_in">console</span>.log(anotherSum(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>));</code></pre><p>构造函数用来创建对象。</p><h3 id="函数声明提升"><a href="#函数声明提升" class="headerlink" title="函数声明提升"></a>函数声明提升</h3><p>解析器会率先读取函数声明，并使其在执行任何代码之前可以访问。至于函数表达式，则必须等到解析器执行到它所在的代码行，才会被真正的解析执行。</p><p>就像var的提升一样！</p><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(sum2(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>));<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum2</span>(<span class="hljs-params">a,b</span>) </span>&#123;    <span class="hljs-keyword">return</span> a * b;&#125;</code></pre><p>但使用函数表达式就不存在这种情况了。</p><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(sum3(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>));<span class="hljs-keyword">let</span> sum3 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a,b</span>) </span>&#123;    <span class="hljs-keyword">return</span> a * b;&#125;</code></pre><p>由于函数在一个初始化语句中，（就算使用var，也只有var的声明会提升，语句并没有初始化）而不是函数声明。</p><h3 id="作为参数传递"><a href="#作为参数传递" class="headerlink" title="作为参数传递"></a>作为参数传递</h3><p>因为函数名本身就是变量，所以函数也可以作为值来使用。(回调)</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">num</span>) </span>&#123;    <span class="hljs-keyword">return</span> num + <span class="hljs-number">10</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addd</span>(<span class="hljs-params">ff,num</span>) </span>&#123;    <span class="hljs-keyword">return</span> ff(num);&#125;<span class="hljs-built_in">console</span>.log(addd(add,<span class="hljs-number">1</span>));</code></pre><p>另一种就是从一个函数中返回另一个函数，实际上就是一个函数嵌套了另一个函数。（闭包）</p><p>例如对对象数组进行按照对象属性排序：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> data = [    &#123;        name: <span class="hljs-string">&#x27;xfy&#x27;</span>,        age: <span class="hljs-number">18</span>    &#125;,    &#123;        name: <span class="hljs-string">&#x27;dfy&#x27;</span>,        age: <span class="hljs-number">81</span>    &#125;]<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">com</span>(<span class="hljs-params">propertyName</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">object1,object2</span>) </span>&#123;        <span class="hljs-keyword">let</span> value1 = object1[propertyName];        <span class="hljs-keyword">let</span> value2 = object2[propertyName];        <span class="hljs-keyword">if</span> (value1 &lt; value2) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value1 &gt; value2) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;    &#125;&#125;<span class="hljs-built_in">console</span>.log(data.sort(com(<span class="hljs-string">&#x27;name&#x27;</span>)));</code></pre><h3 id="函数内部属性"><a href="#函数内部属性" class="headerlink" title="函数内部属性"></a>函数内部属性</h3><p>在函数内部，有两个特殊的对象：arguments和this。arguments的主要作用是保存函数参数，但它还有一个callee的属性。该属性是一个指针，指针指向拥有这个arguments对象的函数。</p><p>一个经典的递归函数：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">num</span>) </span>&#123;    <span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> num + test(num - <span class="hljs-number">1</span>);&#125;<span class="hljs-built_in">console</span>.log(test(<span class="hljs-number">100</span>));</code></pre><p>当遇到使用函数表达式重新指向函数时</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">num</span>) </span>&#123;    <span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> num + test(num - <span class="hljs-number">1</span>);&#125;<span class="hljs-built_in">console</span>.log(test(<span class="hljs-number">100</span>));<span class="hljs-keyword">let</span> test2 = test;test = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-built_in">console</span>.log(test2(<span class="hljs-number">100</span>));    <span class="hljs-comment">// 101 test2不能完成回调，因为函数中还是test(num -1)</span><span class="hljs-built_in">console</span>.log(test(<span class="hljs-number">100</span>));</code></pre><p>使用callee就能解决这个问题，类似于对象的this。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cb</span>(<span class="hljs-params">num</span>) </span>&#123;    <span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> num + <span class="hljs-built_in">arguments</span>.callee(num - <span class="hljs-number">1</span>);&#125;<span class="hljs-built_in">console</span>.log(cb(<span class="hljs-number">100</span>));<span class="hljs-keyword">let</span> cb2 = cb;       <span class="hljs-comment">// 指针交换</span>cb = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-built_in">console</span>.log(cb2(<span class="hljs-number">100</span>));<span class="hljs-built_in">console</span>.log(cb(<span class="hljs-number">100</span>));</code></pre><blockquote><p>函数的名字仅仅只是一个包含指针的变量而已。</p></blockquote><p>ECMAScript5还定义了一个函数对象的属性：caller。它保存着调用当前函数的函数的引用。如果是在全局作用域中调用当前函数，它的值为null。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> inner();&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inner</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> inner.caller;&#125;<span class="hljs-built_in">console</span>.log(outer());</code></pre><p>甚至还能更进一步解耦合：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outer</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> inner();&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inner</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.callee.caller;&#125;</code></pre><p>在严格模式下，访问<code>arguments.callee</code>和<code>arguments.caller</code>都会导致访问错误。且不能为函数的caller属性赋值，否则会导致错误。</p><h3 id="函数属性与方法"><a href="#函数属性与方法" class="headerlink" title="函数属性与方法"></a>函数属性与方法</h3><p>js中的函数也是对象，所以函数也有属性和方法。每个函数都包含两个属性：length和prototype。</p><p>length属性表示函数希望接受的命名参数的个数。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">arg1,arg2</span>) </span>&#123;    <span class="hljs-keyword">return</span> arg1 + arg2;&#125;<span class="hljs-built_in">console</span>.log(test.length);</code></pre><p>对于引用类型而言，prototype是保存它们所有实例方法的真正所在。prototype属性是不可枚举的，所以用for-in是无法发现的。</p><p>每个函数都包含两个非继承而来的方法：apply()和call()。它们常用来动态改变this的值。call()与apply()相同，它们区别仅在接受参数的方式不同。第一个参数是this值，第二个参数分别是逐个传参和数组传参。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fruits</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;fruits.prototype = &#123;    color: <span class="hljs-string">&#x27;red&#x27;</span>,    say: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;the color is : &#x27;</span> + <span class="hljs-built_in">this</span>.color);    &#125;&#125;<span class="hljs-keyword">let</span> apple = <span class="hljs-keyword">new</span> fruits();<span class="hljs-built_in">console</span>.log(apple);<span class="hljs-built_in">console</span>.log(apple.say());<span class="hljs-keyword">let</span> banana = &#123;    color: <span class="hljs-string">&#x27;yellow&#x27;</span>&#125;<span class="hljs-built_in">console</span>.log(apple.say.apply(banana));</code></pre><p>除了在对象中的应用，call和apply真正的用武之地是扩充函数的作用于。</p><pre><code class="hljs js"><span class="hljs-built_in">window</span>.color = <span class="hljs-string">&#x27;red&#x27;</span>;<span class="hljs-keyword">let</span> o = &#123;    color: <span class="hljs-string">&#x27;blue&#x27;</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayColor</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.color;&#125;sayColor()<span class="hljs-string">&quot;red&quot;</span>sayColor.call(o)<span class="hljs-string">&quot;blue&quot;</span>sayColor.call(<span class="hljs-built_in">window</span>)<span class="hljs-string">&quot;red&quot;</span></code></pre><p>除此之外还有一个方法：bind()。这个方法会创建一个函数的实例，其this值会被绑定到传给bind()函数的值。</p><pre><code class="hljs js"><span class="hljs-built_in">window</span>.color = <span class="hljs-string">&#x27;red&#x27;</span>;<span class="hljs-keyword">let</span> o = &#123;    color: <span class="hljs-string">&#x27;blue&#x27;</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayColor</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.color;&#125;<span class="hljs-keyword">let</span> sayAnotherColor = sayColor.bind(o);sayAnotherColor();<span class="hljs-string">&quot;blue&quot;</span></code></pre><h3 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h3><p>三个特殊的引用类型：Boolean、Number和String。</p><p>包装对象都会经过三个步骤：</p><ol><li>创建String或其他类型的一个实例；</li><li>在实例上调用指定的方法；</li><li>销毁这个实例；</li></ol><p>也就是类似于这样的操作：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> s1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&#x27;some string&#x27;</span>);<span class="hljs-keyword">let</span> s2 = s1.length;s1 = <span class="hljs-literal">null</span>;</code></pre><p>引用类型与基本包装类型的主要区别就是对象的生存期。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前一直都保存在内存中。而包装对象，则只存在执行代码的一瞬间，然后立即被销毁。所以不能在运行时为基本类型添加属性和方法。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> s1 = <span class="hljs-string">&#x27;xfy&#x27;</span>;s1.color = <span class="hljs-string">&#x27;pink&#x27;</span>;<span class="hljs-built_in">console</span>.log(s1.color);<span class="hljs-comment">// undefined</span></code></pre><p>在第二行创建的String对象在执行第三行代码时就已经被销毁了，第三行代码则又创建自己String对象，而没有第二行创建color属性。</p><p>Object构造函数也会像工厂方法一样，根据传入值的类型来返回相应基本包装类型的实例。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> test = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>(<span class="hljs-string">&#x27;xfy&#x27;</span>);<span class="hljs-keyword">typeof</span> test<span class="hljs-string">&quot;object&quot;</span>test <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">String</span><span class="hljs-literal">true</span>test <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Number</span><span class="hljs-literal">false</span>test <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span><span class="hljs-literal">true</span></code></pre><p>使用new调用资本包装类型的构造函数，与直接调用同名的转型函数是不一样的。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> value = <span class="hljs-string">&#x27;25&#x27;</span>;<span class="hljs-keyword">let</span> test = <span class="hljs-built_in">Number</span>(value);<span class="hljs-keyword">typeof</span> test<span class="hljs-string">&quot;number&quot;</span><span class="hljs-keyword">let</span> test2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-number">25</span>);<span class="hljs-keyword">typeof</span> test2;<span class="hljs-string">&quot;object&quot;</span></code></pre><blockquote><p>不建显式的创建基本包装类型的对象。</p></blockquote><h2 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h2><p>Boolean有基本类型与引用类型。使用Boolean对象构造的值为引用类型。Boolean类型的实例重写了valueOf()与toString()。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">false</span>);     <span class="hljs-comment">// falseObject</span><span class="hljs-keyword">let</span> bb = <span class="hljs-literal">true</span>;<span class="hljs-keyword">let</span> b2 = <span class="hljs-literal">false</span>;     <span class="hljs-comment">// falseValue</span><span class="hljs-built_in">console</span>.log(b &amp;&amp; bb);   <span class="hljs-comment">//true</span><span class="hljs-built_in">console</span>.log(b2 &amp;&amp; bb);  <span class="hljs-comment">//false</span></code></pre><p>布尔表达式中所有对象都会被转为true，因此引用类型的Boolean都会被转为true。</p><p>基本类型与引用类型的Boolean还有两个区别：</p><ul><li>typeof对基本类型返回”Boolean“。对引用类型返回”Object“；</li><li>Boolean对象是Boolean类型的实例，所以instanceof会返回true。而基本类型则返回false；</li></ul><blockquote><p>建议不要使用Boolean对象。</p></blockquote><h2 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h2><p>Number类型也重写了valueOf()、toLocaleString()和toString()。</p><p>toString()可以传递一个表示基数的参数，将返回进制化数值的字符串形式。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> num = <span class="hljs-number">123</span>;<span class="hljs-built_in">console</span>.log(num.toString(<span class="hljs-number">2</span>));<span class="hljs-built_in">console</span>.log(num.toString(<span class="hljs-number">8</span>));<span class="hljs-built_in">console</span>.log(num.toString(<span class="hljs-number">16</span>));</code></pre><p>除了继承的方法之外，Number类型还提供了一些用于将数值格式化为字符串的方法。toFixed()方法返回指定位数的小数。</p><p>当小数比指定位数还多一位的情况下，就会舍入。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> num = <span class="hljs-number">123</span>;<span class="hljs-built_in">console</span>.log(num.toFixed(<span class="hljs-number">2</span>));<span class="hljs-built_in">console</span>.log(num.toFixed(<span class="hljs-number">20</span>));num = <span class="hljs-number">12.005</span>;<span class="hljs-built_in">console</span>.log(num.toFixed(<span class="hljs-number">2</span>));</code></pre><blockquote><p>通常情况下toFixed()可以表示0-20位小数，但这只是标准实现的范围。有些运行环境可以支持更多。</p></blockquote><p>也有用于格式化为指数表示法的方法，toExponential()（e表示法）。toExponential()接受一个参数，指定输出结果的小数的位数。返回也是字符串形式。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> num = <span class="hljs-number">123</span>;<span class="hljs-keyword">let</span> num2 = num.toExponential(<span class="hljs-number">10</span>);<span class="hljs-built_in">console</span>.log(num2);  <span class="hljs-comment">// 1.2300000000e+2</span></code></pre><p>还有toPrecision()会根据情况来使用toFixed()或者是toExponential()。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> num = <span class="hljs-number">123</span>;<span class="hljs-built_in">console</span>.log(num.toPrecision(<span class="hljs-number">1</span>));<span class="hljs-built_in">console</span>.log(num.toPrecision(<span class="hljs-number">2</span>));<span class="hljs-built_in">console</span>.log(num.toPrecision(<span class="hljs-number">3</span>));<span class="hljs-built_in">console</span>.log(num.toPrecision(<span class="hljs-number">4</span>));<span class="hljs-built_in">console</span>.log(num.toPrecision(<span class="hljs-number">5</span>));<span class="hljs-built_in">console</span>.log(num.toPrecision(<span class="hljs-number">6</span>));<span class="hljs-number">1e+2</span><span class="hljs-number">1.2e+2</span><span class="hljs-number">123</span><span class="hljs-number">123.0</span><span class="hljs-number">123.00</span><span class="hljs-number">123.000</span></code></pre><p>Number与Boolean一样，实例化Number类型在使用typeof和instanceof时，会有完全不同的结果。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> num = <span class="hljs-number">123</span>;<span class="hljs-keyword">let</span> num2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-number">123</span>);<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> num);<span class="hljs-comment">// &quot;Number&quot;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> num2);<span class="hljs-comment">// &quot;Object&quot;</span><span class="hljs-built_in">console</span>.log(num <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Number</span>);<span class="hljs-comment">// false</span><span class="hljs-built_in">console</span>.log(num2 <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Number</span>);<span class="hljs-comment">// true</span></code></pre><h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>String类型是字符串的对象包装类型。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&#x27;xfy&#x27;</span>);</code></pre><p>访问特定字符方法：charAt()和charCodeAt()，接受一个参数，从0开始的字符位置。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;xfy&#x27;</span>;<span class="hljs-built_in">console</span>.log(str.charAt(<span class="hljs-number">1</span>));<span class="hljs-built_in">console</span>.log(str.charCodeAt(<span class="hljs-number">1</span>));</code></pre><p>还有另一个访问个别字符的方法，类似于访问数组</p><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(str[<span class="hljs-number">1</span>]);</code></pre><p>操作方法</p><p>除了<code>+</code>拼接字符串，还有类似于数组的concat()方法。用于将一个或多个字符串拼接起来，返回新的字符串。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> str2 = <span class="hljs-string">&#x27;yyy&#x27;</span>;<span class="hljs-built_in">console</span>.log(str.concat(<span class="hljs-string">&#x27;abc&#x27;</span>,str2));</code></pre><p>还有三个基于字符串创建新字符串的方法，基于字符串修改或裁减。返回新的字符串。slice()、substr()和substring()。它们都接受两个参数，第一个参数指定字符串开始的位置，第二个参数（可选）表示字符串到哪里结束。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;xiaofeiyang&#x27;</span>;<span class="hljs-built_in">console</span>.log(str.slice(<span class="hljs-number">4</span>));<span class="hljs-built_in">console</span>.log(str.substr(<span class="hljs-number">4</span>));<span class="hljs-built_in">console</span>.log(str.substring(<span class="hljs-number">4</span>));<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;---&#x27;</span>);<span class="hljs-built_in">console</span>.log(str.slice(<span class="hljs-number">4</span>,<span class="hljs-number">7</span>));<span class="hljs-built_in">console</span>.log(str.substr(<span class="hljs-number">4</span>,<span class="hljs-number">7</span>));<span class="hljs-built_in">console</span>.log(str.substring(<span class="hljs-number">4</span>,<span class="hljs-number">7</span>));feiyangfeiyangfeiyang---feifeiyangfei</code></pre>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker-全面容器化！</title>
    <link href="/defect/docker-container-all.html"/>
    <url>/defect/docker-container-all.html</url>
    
    <content type="html"><![CDATA[<p>自上篇<a href="https://www.defectink.com/defect/docker-build-own-images.html">Docker - 构建属于自己的镜像</a>以来，发现Docker非常的有意思。主要是非常的方便，并且在可以跨平台的情况下部署环境对于以后迁移也是一件极其有利的事。研究了Dockerfile的编写以及实践。一些基础的实践之后，对于Docker的工作方式以及操作命令都有了一些熟悉。也逐渐了发现了它的一些优点。</p><p>翻开自己的旧机器里的多种环境交杂在一起的配置，时间长了连配置文件在哪都找不到了。管理起来比较复杂。那些服务器的管理面板并不是很喜欢，而且相对于Docker来说，管理面板只是简化了部署的操作，并没有达到方便管理的目的。到最后可能它的软件目录，镜像源都是按照它的想法去放的。对于自己并没有完全的掌控。当然不能完全拿管理面板与Docker来相比，二者完全是两种技术。只是相较于方便管理这方面来对比一下。</p><p>而最近研究的Docker，无疑是最满意的了。在保持宿主机不乱的情况下，可以完全的掌控自己的运行环境。于是就有了将自己目前跑了挺长时间的一套blog环境都迁移到Docker上。对于以后若是迁移机器也会更加的方便。</p><h2 id="涉及到的操作"><a href="#涉及到的操作" class="headerlink" title="涉及到的操作"></a>涉及到的操作</h2><ul><li>Dockerfile</li><li>docker-compose.yml</li><li>apache virtualhost</li><li>php-fpm</li><li>http2</li><li>apache https</li><li>certbot with docker</li><li>apache proxy</li></ul><h2 id="目前环境"><a href="#目前环境" class="headerlink" title="目前环境"></a>目前环境</h2><p>先来简单看下当前跑在机器上的环境：</p><p>基本的LAMP环境，加上一些自定义的应用，与一个服务器监控软件。其中apache有多个虚拟主机，全部都使用了https。</p><p>咋一看是一套很简单的环境，其中apache配置稍多一点。但是实际在迁移到Docker的操作起来还是比较复杂的。并且为了镜像的最小化，apache基于的镜像都是alpine。配置与常用的Ubuntu略有不同。</p><h2 id="容器化"><a href="#容器化" class="headerlink" title="容器化"></a>容器化</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>将多个运行LAMP分别拆分出三个运行环境，使用docker-compose来捆绑运行。</p><p>目录树</p><pre><code class="hljs css">.├── <span class="hljs-selector-tag">apache</span>│   ├── <span class="hljs-selector-tag">Dockerfile</span>│   ├── <span class="hljs-selector-tag">httpd</span><span class="hljs-selector-class">.conf</span>│   └── <span class="hljs-selector-tag">sites</span>│       ├── 000<span class="hljs-selector-tag">-default-ssl</span><span class="hljs-selector-class">.conf</span>│       └── 000<span class="hljs-selector-tag">-default</span><span class="hljs-selector-class">.conf</span>├── <span class="hljs-selector-tag">docker-compose</span><span class="hljs-selector-class">.yml</span>├── <span class="hljs-selector-tag">mysql</span>│   └── <span class="hljs-selector-tag">backup</span>├── <span class="hljs-selector-tag">php</span>│   └── <span class="hljs-selector-tag">Dockerfile</span>└── <span class="hljs-selector-tag">www</span>    └── <span class="hljs-selector-tag">html</span>        └── <span class="hljs-selector-tag">index</span><span class="hljs-selector-class">.php</span></code></pre><p>首先创建一个用于存放整个运行环境的<code>Docker</code>父文件夹。然后根据不同的镜像来划分不同的子文件夹，子文件夹内存放的就是各个镜像的<code>Dockerfile</code>与配置文件等。将docker-compose.yml存放与父目录下。</p><p>apache与php-fpm通信借助Docker的网络，实现内部的通信。</p><h2 id="Apahce"><a href="#Apahce" class="headerlink" title="Apahce"></a>Apahce</h2><p>在当前的apache目录下，主要文件夹的划分为<code>Dockerfile</code>、<code>httpd.conf</code>和sites文件夹。</p><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>虽然httpd有了一个单独的镜像，但是还是需要使用Dockerfile来对其进行自定义配置。为了尽量减小镜像的大小。这里使用基于alpine的apache。</p><p>在Docker hub中的<a href="https://hub.docker.com/_/httpd">httpd</a>当前支持的tag：</p><p><img src="../images/Docker%E5%85%A8%E9%9D%A2%E5%AE%B9%E5%99%A8%E5%8C%96/image-20191221185631177.webp" alt="image-20191221185631177"></p><p>整个Dockerfile：</p><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> httpd:alpine<span class="hljs-keyword">RUN</span><span class="bash"> sed -i <span class="hljs-string">&#x27;s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g&#x27;</span> /etc/apk/repositories \</span><span class="bash">&amp;&amp; apk update \</span><span class="bash">        &amp;&amp; apk upgrade</span><span class="hljs-keyword">COPY</span><span class="bash"> sites/ /usr/<span class="hljs-built_in">local</span>/apache2/conf/sites/</span><span class="hljs-keyword">COPY</span><span class="bash"> httpd.conf /usr/<span class="hljs-built_in">local</span>/apache2/conf/httpd.conf</span></code></pre><p>所以<code>FROM</code>里使用的就是带alpine的tag了。我还尝试过测试使用基于alpine的空载运行apache大概节约了1MB的内存。</p><pre><code class="hljs apache"><span class="hljs-attribute">176d166ee52a</span>        testa               <span class="hljs-number">0</span>.<span class="hljs-number">00</span>%             <span class="hljs-number">4</span>.<span class="hljs-number">484</span>MiB / <span class="hljs-number">3</span>.<span class="hljs-number">607</span>GiB   <span class="hljs-number">0</span>.<span class="hljs-number">12</span>%         <span class="hljs-attribute">3dac39c11385</span>        test                <span class="hljs-number">0</span>.<span class="hljs-number">00</span>%             <span class="hljs-number">5</span>.<span class="hljs-number">664</span>MiB / <span class="hljs-number">3</span>.<span class="hljs-number">607</span>GiB   <span class="hljs-number">0</span>.<span class="hljs-number">15</span>%</code></pre><p>对于跑在国内的机器上，alpine也有国内的源。并且替换的也很简单，一句话就好了。这样在后续的更新源和安装软件就没有那么苦恼了。</p><pre><code class="hljs gradle">sed -i <span class="hljs-string">&#x27;s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g&#x27;</span> <span class="hljs-regexp">/etc/</span>apk/<span class="hljs-keyword">repositories</span></code></pre><p>剩下的<code>COPY</code>就是复制自定义的配置文件到容器里去了。</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>首先，之前的环境中apache是有多个虚拟主机，并且每个主机都启用了ssl以及一些其他的配置。所以第一步是需要修改容器的配置文件。也就是要先获取默认的配置文件。</p><p>优雅的获取apache默认配置文件：</p><pre><code class="hljs stata">docker <span class="hljs-keyword">run</span> --<span class="hljs-keyword">rm</span> httpd:2.4 <span class="hljs-keyword">cat</span> /usr/<span class="hljs-keyword">local</span>/apache2/<span class="hljs-keyword">conf</span>/httpd.<span class="hljs-keyword">conf</span> &gt; httpd.<span class="hljs-keyword">conf</span></code></pre><p>默认的ssl配置文件：</p><pre><code class="hljs stata">docker <span class="hljs-keyword">run</span> --<span class="hljs-keyword">rm</span> httpd:2.4 <span class="hljs-keyword">cat</span> /usr/<span class="hljs-keyword">local</span>/apache2/<span class="hljs-keyword">conf</span>/extra/httpd-ssl.<span class="hljs-keyword">conf</span> &gt; ssl.<span class="hljs-keyword">conf</span></code></pre><p>容器的配置文件路径：</p><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/apache2/</span>conf/httpd.conf</code></pre><p>获取到了默认的配置文件之后，在apache的文件夹内可以先自定义<code>httpd.conf</code>。并且尝试启动一次，没用问题后可以继续配置虚拟主机。</p><p>由于不同的站点都交给了虚拟主机的配置文件来处理。所以<code>httpd.conf</code>主要是负责一些mod的配置，和一些全局的配置了。还有就是将余下的配置文件<code>Include</code>进来了。</p><p>后期还有需要添加更多的虚拟主机的配置文件，到时候一个一个的<code>Include</code>操作太过繁琐。所以创建个专门存放配置文件的文件夹，再在<code>httpd.conf</code>里将整个文件夹<code>Include</code>进去。这样就最简单的解决了操作繁琐的问题。</p><p>创建一个<code>sites</code>文件夹用于存放配置文件，<code>COPY</code>到容器内相应的目录：</p><pre><code class="hljs gradle"><span class="hljs-keyword">COPY</span> sites<span class="hljs-regexp">/ /u</span>sr<span class="hljs-regexp">/local/</span>apache2<span class="hljs-regexp">/conf/</span>sites/</code></pre><p>在<code>httpd.conf</code>中相应的引入：</p><pre><code class="hljs gradle"><span class="hljs-keyword">Include</span> <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/apache2/</span>conf<span class="hljs-regexp">/sites/</span>*.conf</code></pre><p>{*}这一操作方法还是学自Ubuntu下的apache，它的配置目录下有两个文件夹<code>sites-available</code>和<code>sites-enabled</code>。在主要的apache2.conf中引入配置文件。</p><pre><code class="hljs http"># Include generic snippets of statementsIncludeOptional conf-enabled/*.conf# Include the virtual host configurations:IncludeOptional sites-enabled/*.conf</code></pre><p><code>httpd.conf</code>中的虚拟主机配置不需要修改了。所有的站点可以都在Include中的配置文件中准备。基本上<code>httpd.conf</code>就是为引入配置文件和启用mod所准备的。</p><h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p>在基于alpine中的apache，所有的mod加载都写在了配置文件<code>httpd.conf</code>里。只需要取消注释就可以加载/启用模组了。</p><p>这次添加的module：</p><pre><code class="hljs apache"><span class="hljs-attribute"><span class="hljs-nomarkup">LoadModule</span></span> deflate_module modules/mod_deflate.so<span class="hljs-attribute"><span class="hljs-nomarkup">LoadModule</span></span> proxy_module modules/mod_proxy.so<span class="hljs-attribute"><span class="hljs-nomarkup">LoadModule</span></span> proxy_connect_module modules/mod_proxy_connect.so<span class="hljs-attribute"><span class="hljs-nomarkup">LoadModule</span></span> proxy_ftp_module modules/mod_proxy_ftp.so<span class="hljs-attribute"><span class="hljs-nomarkup">LoadModule</span></span> proxy_http_module modules/mod_proxy_http.so<span class="hljs-attribute"><span class="hljs-nomarkup">LoadModule</span></span> proxy_fcgi_module modules/mod_proxy_fcgi.so<span class="hljs-attribute"><span class="hljs-nomarkup">LoadModule</span></span> setenvif_module modules/mod_setenvif.so<span class="hljs-attribute"><span class="hljs-nomarkup">LoadModule</span></span> mpm_event_module modules/mod_mpm_event.so<span class="hljs-attribute"><span class="hljs-nomarkup">LoadModule</span></span> http<span class="hljs-number">2</span>_module modules/mod_http<span class="hljs-number">2</span>.so<span class="hljs-attribute"><span class="hljs-nomarkup">LoadModule</span></span> proxy_http<span class="hljs-number">2</span>_module modules/mod_proxy_http<span class="hljs-number">2</span>.so<span class="hljs-attribute"><span class="hljs-nomarkup">LoadModule</span></span> ssl_module modules/mod_ssl.so<span class="hljs-attribute"><span class="hljs-nomarkup">LoadModule</span></span> socache_shmcb_module modules/mod_socache_shmcb.so<span class="hljs-attribute"><span class="hljs-nomarkup">LoadModule</span></span> rewrite_module modules/mod_rewrite.so<span class="hljs-attribute"><span class="hljs-nomarkup">LoadModule</span></span> headers_module modules/mod_headers.so<span class="hljs-comment">#LoadModule mpm_prefork_module modules/mod_mpm_prefork.so</span></code></pre><p>这些mod都是作用于何？</p><ul><li><p>mod_deflate是一个压缩算法。</p></li><li><p>mod_socache_shmcb共享对象缓存提供程序。</p></li><li><p>因为需要配置反代和与php-fpm工作，所以需要启用多个proxy配置文件。</p></li><li><p>因为需要用到http2，所以工作模式得修改为event。同时注释掉默认的工作模式prefork。自然也需要mod_http2</p></li><li><p>https是不可或缺的，所以mod_ssl不可缺少。</p></li><li><p>后续的博客需要用到伪静态，mod_rewrite也不可少。</p></li><li><p>在最近也添加了多个header头，需要用到mod_headers。</p></li></ul><blockquote><p>info：根据自己需要启用module是一个良好的习惯，过多的module会影响性能。</p></blockquote><h3 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h3><p>前面提到，专门创建了一个sites文件夹来存放虚拟主机的配置文件，目前sites文件夹还是空的。既然<code>httpd.conf</code>以及准备就绪，那么接下来就是填满sites文件夹了。</p><p>在还未添加虚拟主机时，默认的站点配置文件全部都写在<code>httpd.conf</code>里。默认的根目录在htdocs。所以在第一次启动测试时，访问的时这里的html文件。</p><pre><code class="hljs apache"><span class="hljs-attribute"><span class="hljs-nomarkup">DocumentRoot</span></span> <span class="hljs-string">&quot;/usr/local/apache2/htdocs&quot;</span></code></pre><p>这里的配置可以不用动，全部操作交给虚拟主机就好。</p><p>整个虚拟主机（default.conf）配置文件：</p><pre><code class="hljs apache"><span class="hljs-section">&lt;VirtualHost *<span class="hljs-number">:80</span>&gt;</span><span class="hljs-attribute">ProtocolsHonorOrder</span> <span class="hljs-literal">On</span><span class="hljs-attribute">Protocols</span> h<span class="hljs-number">2</span> h<span class="hljs-number">2</span>c<span class="hljs-attribute"><span class="hljs-nomarkup">Header</span></span> set X-Frame-Options <span class="hljs-string">&quot;SAMEORIGIN&quot;</span><span class="hljs-attribute"><span class="hljs-nomarkup">Header</span></span> always set Strict-Transport-Security <span class="hljs-string">&quot;max-age=63072000; includeSubdomains;&quot;</span><span class="hljs-attribute"><span class="hljs-nomarkup">Header</span></span> set Content-Security-Policy <span class="hljs-string">&quot;default-src &#x27;self&#x27; https://cdn.defectink.com; script-src &#x27;self&#x27; &#x27;unsafe-inline&#x27; &#x27;unsafe-eval&#x27; https://maxcdn.bootstrapcdn.com https://ajax.googleapis.com https://cdn.defectink.com; img-src *; style-src &#x27;self&#x27; &#x27;unsafe-inline&#x27; https://cdn.defectink.com https://maxcdn.bootstrapcdn.com https://fonts.googleapis.com/; font-src &#x27;self&#x27; https://cdn.defectink.com https://fonts.gstatic.com/ https://maxcdn.bootstrapcdn.com; form-action &#x27;self&#x27; https://cdn.defectink.com; upgrade-insecure-requests;&quot;</span><span class="hljs-attribute"><span class="hljs-nomarkup">Header</span></span> set X-Content-Type-Options nosniff<span class="hljs-attribute"><span class="hljs-nomarkup">Header</span></span> always set Referrer-Policy <span class="hljs-string">&quot;no-referrer-when-downgrade&quot;</span><span class="hljs-attribute"><span class="hljs-nomarkup">Header</span></span> always set Feature-Policy <span class="hljs-string">&quot;vibrate &#x27;self&#x27;; sync-xhr &#x27;self&#x27; https://cdn.defectink.com https://www.defectink.com&quot;</span>    <span class="hljs-comment"># Proxy .php requests to port 9000 of the php-fpm container</span>    <span class="hljs-attribute">ProxyPassMatch</span> ^/(.*\.php(/.*)?)$ fcgi://php:<span class="hljs-number">9000</span>/var/www/html/$<span class="hljs-number">1</span>    <span class="hljs-attribute"><span class="hljs-nomarkup">ServerName</span></span> www.defectink.com    <span class="hljs-attribute"><span class="hljs-nomarkup">DocumentRoot</span></span> /var/www/html/    <span class="hljs-section">&lt;Directory /var/www/html/&gt;</span>        <span class="hljs-attribute">DirectoryIndex</span> index.php        <span class="hljs-attribute"><span class="hljs-nomarkup">Options</span></span> Indexes FollowSymLinks        <span class="hljs-attribute">AllowOverride</span> <span class="hljs-literal">All</span>        <span class="hljs-attribute">Require</span> <span class="hljs-literal">all</span> granted    <span class="hljs-section">&lt;/Directory&gt;</span>    <span class="hljs-comment"># Send apache logs to stdout and stderr</span>    <span class="hljs-attribute">CustomLog</span> /proc/self/fd/<span class="hljs-number">1</span> common    <span class="hljs-attribute">ErrorLog</span> /proc/self/fd/<span class="hljs-number">2</span><span class="hljs-attribute"><span class="hljs-nomarkup">RewriteEngine</span></span> <span class="hljs-literal">on</span><span class="hljs-attribute"><span class="hljs-nomarkup">RewriteCond</span></span> <span class="hljs-variable">%&#123;SERVER_NAME&#125;</span> =www.defectink.com<span class="hljs-attribute"><span class="hljs-nomarkup">RewriteRule</span></span> ^ https://<span class="hljs-variable">%&#123;SERVER_NAME&#125;</span><span class="hljs-variable">%&#123;REQUEST_URI&#125;</span><span class="hljs-meta"> [END,NE,R=permanent]</span><span class="hljs-section">&lt;/VirtualHost&gt;</span></code></pre><h4 id="虚拟主机优先级"><a href="#虚拟主机优先级" class="headerlink" title="虚拟主机优先级"></a>虚拟主机优先级</h4><p>在apache中，虚拟主机的配置文件是拥有优先级的。优先级的意思就是，当一个域名指向当前机器的ip，而配置文件中没有绑定的ServerName时，默认被引导到的页面。</p><p>优先级的顺序是根据虚拟主机的配置文件名来决定的。名称首字母越靠前，优先级越高。使用数字开头将大于子母开头。</p><blockquote><p>000-default will be the default, because it goes “numbers, then letters”.</p></blockquote><p>可以使用命令来查看当前的默认站点：</p><pre><code class="hljs bash">httpd -S</code></pre><pre><code class="hljs bash">apache2ctl -S</code></pre><h3 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h3><p>这里的ssl配置文件是来自于容器内的默认配置文件，使用上述的方法可以很方便的导出。</p><p>整个ssl（default-ssl.conf）配置文件：</p><pre><code class="hljs pgsql"><span class="hljs-keyword">Listen</span> <span class="hljs-number">443</span>SSLCipherSuite HIGH:MEDIUM:!MD5:!RC4:!<span class="hljs-number">3</span>DESSSLProxyCipherSuite HIGH:MEDIUM:!MD5:!RC4:!<span class="hljs-number">3</span>DESSSLHonorCipherOrder <span class="hljs-keyword">on</span> SSLProtocol <span class="hljs-keyword">all</span> -SSLv3SSLProxyProtocol <span class="hljs-keyword">all</span> -SSLv3SSLPassPhraseDialog  builtinSSLSessionCache        &quot;shmcb:/usr/local/apache2/logs/ssl_scache(512000)&quot;SSLSessionCacheTimeout  <span class="hljs-number">300</span>&lt;VirtualHost *:<span class="hljs-number">443</span>&gt;ProtocolsHonorOrder <span class="hljs-keyword">On</span>Protocols h2 h2c<span class="hljs-keyword">Header</span> <span class="hljs-keyword">set</span> X-Frame-<span class="hljs-keyword">Options</span> &quot;SAMEORIGIN&quot;<span class="hljs-keyword">Header</span> <span class="hljs-keyword">always</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">Strict</span>-Transport-<span class="hljs-keyword">Security</span> &quot;max-age=63072000; includeSubdomains;&quot;<span class="hljs-keyword">Header</span> <span class="hljs-keyword">set</span> Content-<span class="hljs-keyword">Security</span>-<span class="hljs-keyword">Policy</span> &quot;default-src &#x27;self&#x27; https://cdn.defectink.com; script-src &#x27;self&#x27; &#x27;unsafe-inline&#x27; &#x27;unsafe-eval&#x27; https://maxcdn.bootstrapcdn.com https://ajax.googleapis.com https://cdn.defectink.com; img-src *; style-src &#x27;self&#x27; &#x27;unsafe-inline&#x27; https://cdn.defectink.com https://maxcdn.bootstrapcdn.com https://fonts.googleapis.com/; font-src &#x27;self&#x27; https://cdn.defectink.com https://fonts.gstatic.com/ https://maxcdn.bootstrapcdn.com; form-action &#x27;self&#x27; https://cdn.defectink.com; upgrade-insecure-requests;&quot;<span class="hljs-keyword">Header</span> <span class="hljs-keyword">set</span> X-Content-<span class="hljs-keyword">Type</span>-<span class="hljs-keyword">Options</span> nosniff<span class="hljs-keyword">Header</span> <span class="hljs-keyword">always</span> <span class="hljs-keyword">set</span> Referrer-<span class="hljs-keyword">Policy</span> &quot;no-referrer-when-downgrade&quot;<span class="hljs-keyword">Header</span> <span class="hljs-keyword">always</span> <span class="hljs-keyword">set</span> Feature-<span class="hljs-keyword">Policy</span> &quot;vibrate &#x27;self&#x27;; sync-xhr &#x27;self&#x27; https://cdn.defectink.com https://www.defectink.com&quot;# Proxy .php requests <span class="hljs-keyword">to</span> port <span class="hljs-number">9000</span> <span class="hljs-keyword">of</span> the php-fpm containerProxyPassMatch ^/(.*\.php(/.*)?)$ fcgi://php:<span class="hljs-number">9000</span>/var/www/html/<span class="hljs-meta">$1</span># General setup <span class="hljs-keyword">for</span> the virtual hostDocumentRoot &quot;/var/www/html/&quot;ServerName www.defectink.com:<span class="hljs-number">443</span>ServerAdmin i@defect.ink    &lt;Directory /var/www/html/&gt;        DirectoryIndex <span class="hljs-keyword">index</span>.php        <span class="hljs-keyword">Options</span> Indexes FollowSymLinks        AllowOverride <span class="hljs-keyword">All</span>        Require <span class="hljs-keyword">all</span> granted    &lt;/Directory&gt;ErrorLog /proc/self/fd/<span class="hljs-number">2</span>TransferLog /proc/self/fd/<span class="hljs-number">1</span>SSLEngine <span class="hljs-keyword">on</span>SSLCertificateFile &quot;/etc/letsencrypt/live/www.defectink.com/fullchain.pem&quot;SSLCertificateKeyFile &quot;/etc/letsencrypt/live/www.defectink.com/privkey.pem&quot;&lt;FilesMatch &quot;\.(cgi|shtml|phtml|php)$&quot;&gt;    SSLOptions +StdEnvVars&lt;/FilesMatch&gt;&lt;Directory &quot;/usr/local/apache2/cgi-bin&quot;&gt;    SSLOptions +StdEnvVars&lt;/Directory&gt;BrowserMatch &quot;MSIE [2-5]&quot; \         nokeepalive ssl-unclean-shutdown \         downgrade<span class="hljs-number">-1.0</span> force-response<span class="hljs-number">-1.0</span>CustomLog /proc/self/fd/<span class="hljs-number">1</span> \          &quot;%t %h %&#123;SSL_PROTOCOL&#125;x %&#123;SSL_CIPHER&#125;x \&quot;%r\&quot; %b&quot;&lt;/VirtualHost&gt;</code></pre><p>这里的主要配置点就在<code>SSLCertificateFile</code>和<code>SSLCertificateKeyFile</code>。关于配合certbot申请证书，在前一篇水过。有兴趣的小伙伴可以去了解更多。<a href="https://www.defectink.com/defect/docker-build-own-images.html#menu_index_8">Docker - 构建属于自己的镜像</a>。</p><p>值得注意的是，在一个<code>httpd.conf</code>文件中只能有一个<code>Listen 443</code>字段。而默认的ssl配置文件中就包含一个<code>Listen 443</code>字段。当复制多个默认的配置文件时，会导致apache运行错误。因为所有的配置文件都会被引入到<code>httpd.conf</code>，而一个apache只能监听一次端口，也就是说只能有一个<code>Listen 443</code>在配置文件中。</p><p>可以考虑将其写在监听80端口下面：</p><pre><code class="hljs angelscript">#Listen <span class="hljs-number">12.34</span><span class="hljs-number">.56</span><span class="hljs-number">.78</span>:<span class="hljs-number">80</span>Listen <span class="hljs-number">80</span>Listen <span class="hljs-number">443</span></code></pre><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>这里虚拟主机的默认配置时将日志发送到stdout和stderr。可以理解为输出到终端上。</p><pre><code class="hljs awk"><span class="hljs-comment"># Send apache logs to stdout and stderr</span>CustomLog <span class="hljs-regexp">/proc/</span>self<span class="hljs-regexp">/fd/</span><span class="hljs-number">1</span> commonErrorLog <span class="hljs-regexp">/proc/</span>self<span class="hljs-regexp">/fd/</span><span class="hljs-number">2</span></code></pre><p>当然也可以实现日志的持久化保存。将其映射到宿主机的目录下就好了。</p><pre><code class="hljs maxima">CustomLog /<span class="hljs-built_in">var</span>/<span class="hljs-built_in">log</span>/access.<span class="hljs-built_in">log</span> commonErrorLog /<span class="hljs-built_in">var</span>/<span class="hljs-built_in">log</span>/<span class="hljs-built_in">error</span>.<span class="hljs-built_in">log</span></code></pre><h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h2><p>PHP这里使用fpm，配合docker-compose的内部网络与apache进行通信。</p><h3 id="Dockerfile-1"><a href="#Dockerfile-1" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><pre><code class="hljs routeros"><span class="hljs-keyword">FROM</span> php:7.4-fpm-alpine<span class="hljs-builtin-name">RUN</span> mv <span class="hljs-string">&quot;<span class="hljs-variable">$PHP_INI_DIR</span>/php.ini-production&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$PHP_INI_DIR</span>/php.ini&quot;</span>COPY php.ini <span class="hljs-variable">$PHP_INI_DIR</span>/conf.d/<span class="hljs-builtin-name">RUN</span> sed -i <span class="hljs-string">&#x27;s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g&#x27;</span> /etc/apk/repositories \        &amp;&amp; apk update \        &amp;&amp; apk<span class="hljs-built_in"> upgrade </span>\        &amp;&amp; docker-php-ext-install mysqli \        &amp;&amp; docker-php-ext-install pdo_mysql</code></pre><h3 id="php-ini"><a href="#php-ini" class="headerlink" title="php.ini"></a>php.ini</h3><p>优雅的获取容器内的php.ini文件：</p><pre><code class="hljs awk">docker cp somephp:<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/etc/</span>php<span class="hljs-regexp">/ /</span>root</code></pre><p>修改过后的配置文件可以在Dockerfile中copy，也可以在compose.yml中映射。只要到了宿主机的正确位置就可以生效。</p><p>官方的描述是这样的方法：</p><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="bash"> mv <span class="hljs-string">&quot;<span class="hljs-variable">$PHP_INI_DIR</span>/php.ini-production&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$PHP_INI_DIR</span>/php.ini&quot;</span></span><span class="hljs-keyword">COPY</span><span class="bash"> php.ini <span class="hljs-variable">$PHP_INI_DIR</span>/conf.d/</span></code></pre><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>如果需要安装typecho这样的blog程序的话，再连接sql时需要安装mysql的拓展，写在Dockerfile就好了：</p><pre><code class="hljs cmake">docker-php-ext-<span class="hljs-keyword">install</span> pdo_mysql</code></pre><p>如果还需要其他的拓展的话，还可以在Dockerfile里自定义安装。可以使用<code>pecl</code>来安装，然后使用<code>docker-php-ext-enable</code>来启用它。</p><blockquote><p>use <code>pecl install</code> to download and compile it, then use <code>docker-php-ext-enable</code> to enable it:</p></blockquote><pre><code class="hljs angelscript">FROM php:<span class="hljs-number">7.4</span>-cliRUN pecl install redis<span class="hljs-number">-5.1</span><span class="hljs-number">.1</span> \    &amp;&amp; pecl install xdebug<span class="hljs-number">-2.8</span><span class="hljs-number">.1</span> \    &amp;&amp; docker-php-ext-enable redis xdebug</code></pre><p>或者直接使用<code>docker-php-ext-install</code>来安装：</p><pre><code>    &amp;&amp; docker-php-ext-install mysqli \    &amp;&amp; docker-php-ext-install pdo_mysql</code></pre><p>至于更多的拓展，还可以编译安装：</p><pre><code class="hljs livescript">FROM php:<span class="hljs-number">5.6</span>-cliRUN curl -fsSL <span class="hljs-string">&#x27;https://xcache.lighttpd.net/pub/Releases/3.2.0/xcache-3.2.0.tar.gz&#x27;</span> -o xcache.tar.gz <span class="hljs-string">\</span>    &amp;&amp; mkdir -p xcache <span class="hljs-string">\</span>    &amp;&amp; tar -xf xcache.tar.gz -C xcache --strip-components=<span class="hljs-number">1</span> <span class="hljs-string">\</span>    &amp;&amp; rm xcache.tar.gz <span class="hljs-string">\</span>    &amp;&amp; ( <span class="hljs-string">\</span>        cd xcache <span class="hljs-string">\</span>        &amp;&amp; phpize <span class="hljs-string">\</span>        &amp;&amp; ./configure --enable-xcache <span class="hljs-string">\</span>        &amp;&amp; make -j <span class="hljs-string">&quot;$(nproc)&quot;</span> <span class="hljs-string">\</span>        &amp;&amp; make install <span class="hljs-string">\</span>    ) <span class="hljs-string">\</span>    &amp;&amp; rm -r xcache <span class="hljs-string">\</span>    &amp;&amp; docker-php-ext-enable xcache</code></pre><h2 id="MySql"><a href="#MySql" class="headerlink" title="MySql"></a>MySql</h2><p>mysql主要修改的一些配置使用启动时的环境变量就可以了，不需要修改其配置文件的情况下，便用不到Dockerfile了。直接使用官方的镜像就好了。</p><h3 id="Docker-Secrets"><a href="#Docker-Secrets" class="headerlink" title="Docker Secrets"></a>Docker Secrets</h3><p>如果担心密码写在docker-compose.yml里不安全的话，可以考虑使用docker secret。不过secret需要使用swarm集群。单台主机只使用docker-compose可能会更加方便一点。</p><p>并且在compose中生成的是两个虚拟网络，只有apache在前端网络映射了端口。mysql完全放在后端，除了虚拟网络和宿主机都无法与其通信。所以密码的安全并不用太过于担心。如果mysql需要对外提供服务，那就需要多担心一下了。</p><pre><code class="hljs routeros">$ docker <span class="hljs-builtin-name">run</span> --name some-mysql -e <span class="hljs-attribute">MYSQL_ROOT_PASSWORD_FILE</span>=/run/secrets/mysql-root -d mysql:tag</code></pre><blockquote><p>映射了目录后，配置的密码都会被持久化保存。再次修改docker-compose.yml中的变量将不会生效。</p></blockquote><h3 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h3><p>对于docker来说，尽量不要在容器内发生写的操作为好。此外，对于数据库来，数据肯定是需要持久化存储的。官方推荐的是：</p><blockquote><p>Important note: There are several ways to store data used by applications that run in Docker containers. We encourage users of the <code>mysql</code> images to familiarize themselves with the options available, including:</p><ul><li>Let Docker manage the storage of your database data <a href="https://docs.docker.com/engine/tutorials/dockervolumes/#adding-a-data-volume">by writing the database files to disk on the host system using its own internal volume management</a>. This is the default and is easy and fairly transparent to the user. The downside is that the files may be hard to locate for tools and applications that run directly on the host system, i.e. outside containers.</li><li>Create a data directory on the host system (outside the container) and <a href="https://docs.docker.com/engine/tutorials/dockervolumes/#mount-a-host-directory-as-a-data-volume">mount this to a directory visible from inside the container</a>. This places the database files in a known location on the host system, and makes it easy for tools and applications on the host system to access the files. The downside is that the user needs to make sure that the directory exists, and that e.g. directory permissions and other security mechanisms on the host system are set up correctly.</li></ul></blockquote><p>说白了就是映射出来为最佳解决方案。如果在compose.yml中使用<code>-v</code>映射，而不添加宿主机的目录位置的话。文件将会被映射到一个随机的目录。</p><p>推荐方案：</p><pre><code class="hljs awk">$ docker run --name some-mysql -v <span class="hljs-regexp">/my/</span>own<span class="hljs-regexp">/datadir:/</span>var<span class="hljs-regexp">/lib/my</span>sql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag</code></pre><h3 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a>备份与恢复</h3><p>针对单个或多个数据库都可以导出为sql文件。在docker中当然也是同样。甚至密码可以使用变量<code>$MYSQL_ROOT_PASSWORD</code>来代替。</p><p>导入：</p><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -i mysql sh -c <span class="hljs-string">&#x27;exec mysql -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot; typecho&#x27;</span> &lt; /data/docker/typecho.sql</code></pre><p>导出：</p><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> mysql sh -c <span class="hljs-string">&#x27;exec mysqldump typecho -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;&#x27;</span> &gt; /data/docker/mysql/backup/typecho.sql</code></pre><h2 id="Docker-compose"><a href="#Docker-compose" class="headerlink" title="Docker-compose"></a>Docker-compose</h2><p>整个配置文件：</p><p>docker-compose.yml</p><pre><code class="hljs dockerfile">version: <span class="hljs-string">&quot;3.2&quot;</span>services:  php:    container_name: php    build: <span class="hljs-string">&#x27;./php/&#x27;</span>    networks:      - backend    volumes:      - ./www/:/var/www/  apache:    container_name: apache    build: <span class="hljs-string">&#x27;./apache/&#x27;</span>    depends_on:      - php      - mysql    networks:      - frontend      - backend    ports:      - <span class="hljs-string">&quot;80:80&quot;</span>      - <span class="hljs-string">&quot;443:443&quot;</span>    volumes:      - ./www/:/var/www/      - /etc/letsencrypt/:/etc/letsencrypt/      - ./apache/logs/:/var/log/  mysql:    container_name: mysql    image: mysql:<span class="hljs-number">5.7</span>    volumes:      - ./mysql/sqldata/:/var/lib/mysql    networks:      - backend    environment:      - MYSQL_ROOT_PASSWORD=password    command: [<span class="hljs-string">&#x27;mysqld&#x27;</span>, <span class="hljs-string">&#x27;--character-set-server=utf8mb4&#x27;</span>]  bark:     container_name: bark    build: <span class="hljs-string">&#x27;./bark&#x27;</span>    ports:       - <span class="hljs-string">&quot;8181&quot;</span>    depends_on:      - apache    networks:      - backendnetworks:  frontend:  backend:</code></pre><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><pre><code class="hljs applescript">It <span class="hljs-keyword">does</span> <span class="hljs-keyword">not</span> belong <span class="hljs-keyword">to</span> any <span class="hljs-keyword">of</span> this network&#x27;s subnets</code></pre><p>这个问题很有意思，在配置文件中设置了网络段。也在服务下写了相同的地址段，它依然说我的网段不一样。</p><p>导致这个问题的原因是在自定义配置网段之前启动过相同的网络，在docker网络下它已经定义过网段了。再次重新手动指定网络地址时，会和之前的不一样。</p><p>只需要删除之前的网络，在重新运行<code>docker-sompose up</code>一遍就可以了。</p><p>查看网络：</p><pre><code class="hljs bash">docker network ls</code></pre><p>删除：</p><pre><code class="hljs bash">docker network rm docker_backend</code></pre><h3 id="此外"><a href="#此外" class="headerlink" title="此外"></a>此外</h3><pre><code class="hljs yaml">  <span class="hljs-bullet">-</span> <span class="hljs-string">backend</span><span class="hljs-attr">ipv4_address:</span> <span class="hljs-number">172.18</span><span class="hljs-number">.0</span><span class="hljs-number">.10</span></code></pre><p>不同的语法写在一起也会导致错误。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.digitalocean.com/community/questions/how-to-set-the-default-virtual-host-on-apache-2">How to set the default virtual host on Apache 2?</a></li><li><a href="https://stackoverflow.com/questions/45648821/docker-compose-up-error-invalid-address">docker-compose up error, Invalid address</a></li><li><a href="https://docs.docker.com/compose/networking/">Networking in Compose</a></li><li><a href="https://www.cloudreach.com/en/insights/blog/containerize-this-how-to-use-php-apache-mysql-within-docker-containers/">Containerize This! How to use PHP, Apache, MySQL within Docker containers</a></li></ul><pre><code class="hljs awk">docker run -it --rm --name certbot \   -v <span class="hljs-string">&quot;/etc/letsencrypt:/etc/letsencrypt&quot;</span> \   -v <span class="hljs-string">&quot;/var/lib/letsencrypt:/var/lib/letsencrypt&quot;</span> \   -v <span class="hljs-string">&quot;/data/docker/web/www/:/data/docker/web/www/&quot;</span> \   certbot/certbot certonly -n --webroot \   -w <span class="hljs-regexp">/data/</span>docker<span class="hljs-regexp">/web/</span>www/test -d test.defectink.com \   -w <span class="hljs-regexp">/data/</span>docker<span class="hljs-regexp">/web/</span>www/html -d www.defectink.com \   -w <span class="hljs-regexp">/data/</span>docker<span class="hljs-regexp">/web/</span>www/index -d index.defectink.com \   -w <span class="hljs-regexp">/data/</span>docker<span class="hljs-regexp">/web/</span>www/api -d api.defectink.com</code></pre><pre><code class="hljs angelscript">docker run --rm --name myadmin -d --network docker_backend --link mysql_db_server:mysql -e PMA_HOST=<span class="hljs-number">172.20</span><span class="hljs-number">.0</span><span class="hljs-number">.4</span> -p <span class="hljs-number">3002</span>:<span class="hljs-number">80</span> phpmyadmin/phpmyadmin</code></pre><pre><code class="hljs awk">certbot certonly -n --webroot -w <span class="hljs-regexp">/data/</span>docker<span class="hljs-regexp">/web/</span>www/html -d www.defectink.com --post-hook <span class="hljs-string">&quot;docker restart apache&quot;</span></code></pre><pre><code class="hljs awk">certbot certonly -n --webroot -w <span class="hljs-regexp">/data/</span>docker<span class="hljs-regexp">/web/</span>www/html -d www.defectink.comcertbot certonly -n --webroot -w <span class="hljs-regexp">/data/</span>docker<span class="hljs-regexp">/web/</span>www/index -d index.defectink.comcertbot certonly -n --webroot -w <span class="hljs-regexp">/data/</span>docker<span class="hljs-regexp">/web/</span>www/test -d test.defectink.comcertbot certonly -n --webroot -w <span class="hljs-regexp">/data/</span>docker<span class="hljs-regexp">/web/</span>www/api -d api.defectink.com</code></pre>]]></content>
    
    
    <categories>
      
      <category>实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Header实践-得拿下这个A</title>
    <link href="/defect/header-practice-have-to-win-this-a.html"/>
    <url>/defect/header-practice-have-to-win-this-a.html</url>
    
    <content type="html"><![CDATA[<p><a href="https://securityheaders.com/">Header安全检测</a></p><p>之前在学习HTML时候研究过<code>X-Frame-Options</code>，它也是header头中的一个安全策略。用于给浏览器指示是否允许一个页面能否嵌入<code>&lt;iframe&gt;</code>等嵌入元素。</p><p>下述所有apache2的操作都需要先启用<code>header</code>模块（Model）才能使用。</p><p>所有参考/摘录来自于<a href="https://developer.mozilla.org/">MDN</a></p><h2 id="X-Frame-Options"><a href="#X-Frame-Options" class="headerlink" title="X-Frame-Options"></a>X-Frame-Options</h2><p><a href="https://www.defectink.com/defect/HTML-practice-x-frame-option.html">https://www.defectink.com/defect/HTML-practice-x-frame-option.html</a></p><h2 id="Strict-Transport-Security"><a href="#Strict-Transport-Security" class="headerlink" title="Strict-Transport-Security"></a>Strict-Transport-Security</h2><p><code> HTTP Strict Transport Security</code>（通常简称为HSTS）是一个安全功能，它告诉浏览器只能通过HTTPS访问当前资源，而不是HTTP。</p><p>一个网站接受一个HTTP的请求，然后跳转到HTTPS，用户可能在开始跳转前，通过没有加密的方式和服务器对话，比如，用户输入<a href="http://foo.com或者直接foo.com./">http://foo.com或者直接foo.com。</a></p><p>这样存在中间人攻击潜在威胁，跳转过程可能被恶意网站利用来直接接触用户信息，而不是原来的加密信息。</p><p>网站通过HTTP Strict Transport Security通知浏览器，这个网站禁止使用HTTP方式加载，浏览器应该自动把所有尝试使用HTTP的请求自动替换为HTTPS请求。</p><h3 id="Apache配置"><a href="#Apache配置" class="headerlink" title="Apache配置"></a>Apache配置</h3><p>在配置文件中添加：</p><pre><code class="hljs pgsql"><span class="hljs-keyword">Header</span> <span class="hljs-keyword">always</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">Strict</span>-Transport-<span class="hljs-keyword">Security</span> &quot;max-age=63072000; includeSubdomains;&quot;</code></pre><h3 id="浏览器工作方式"><a href="#浏览器工作方式" class="headerlink" title="浏览器工作方式"></a>浏览器工作方式</h3><p>你的网站第一次通过HTTPS请求，服务器响应<code>Strict-Transport-Security</code> 头，浏览器记录下这些信息，然后后面尝试访问这个网站的请求都会自动把HTTP替换为HTTPS。</p><p>当HSTS头设置的过期时间到了，后面通过HTTP的访问恢复到正常模式，不会再自动跳转到HTTPS。</p><p>每次浏览器接收到Strict-Transport-Security头，它都会更新这个网站的过期时间，所以网站可以刷新这些信息，防止过期发生。</p><p>Chrome、Firefox等浏览器里，当您尝试访问该域名下的内容时，会产生一个307 Internal Redirect（内部跳转），自动跳转到HTTPS请求。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre><code class="hljs pgsql"><span class="hljs-keyword">Strict</span>-Transport-<span class="hljs-keyword">Security</span>: max-age=&lt;expire-<span class="hljs-type">time</span>&gt;<span class="hljs-keyword">Strict</span>-Transport-<span class="hljs-keyword">Security</span>: max-age=&lt;expire-<span class="hljs-type">time</span>&gt;; includeSubDomains<span class="hljs-keyword">Strict</span>-Transport-<span class="hljs-keyword">Security</span>: max-age=&lt;expire-<span class="hljs-type">time</span>&gt;; preload</code></pre><ul><li><code>max-age=&lt;expire-time&gt;</code>：设置在浏览器收到这个请求后的<expire-time>秒的时间内凡是访问这个域名下的请求都使用HTTPS请求。</li><li><code>includeSubDomains</code>：如果这个可选的参数被指定，那么说明此规则也适用于该网站的所有子域名。</li><li><code>preload</code>：查看 <a href="https://developer.mozilla.org/zh-CN/docs/Security/HTTP_Strict_Transport_Security#%E9%A2%84%E5%8A%A0%E8%BD%BD_HSTS">预加载 HSTS</a> 获得详情。不是标准的一部分。</li></ul><h2 id="Content-Security-Policy"><a href="#Content-Security-Policy" class="headerlink" title="Content-Security-Policy"></a>Content-Security-Policy</h2><p>内容安全策略  (<a href="https://developer.mozilla.org/en-US/docs/Glossary/CSP">CSP</a>) 是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (<a href="https://developer.mozilla.org/en-US/docs/Glossary/XSS">XSS</a>) 和数据注入攻击等。无论是数据盗取、网站内容污染还是散发恶意软件，这些攻击都是主要的手段。</p><h3 id="Apache配置-1"><a href="#Apache配置-1" class="headerlink" title="Apache配置"></a>Apache配置</h3><p>在配置文件中添加：</p><pre><code class="hljs html">Header set Content-Security-Policy &quot;default-src &#x27;self&#x27; https://cdn.defectink.com; script-src &#x27;self&#x27; &#x27;unsafe-inline&#x27; &#x27;unsafe-eval&#x27; https://maxcdn.bootstrapcdn.com https://ajax.googleapis.com https://cdn.defectink.com; img-src *; style-src &#x27;self&#x27; &#x27;unsafe-inline&#x27; https://cdn.defectink.com https://maxcdn.bootstrapcdn.com https://fonts.googleapis.com/; font-src &#x27;self&#x27; https://cdn.defectink.com https://fonts.gstatic.com/ https://maxcdn.bootstrapcdn.com; form-action &#x27;self&#x27; https://cdn.defectink.com; upgrade-insecure-requests;&quot;</code></pre><p>说白了就是添加允许加载的脚本、样式等内容的白名单。配置相应的值，以控制用户代理（浏览器等）可以为该页面获取哪些资源。比如一个可以上传文件和显示图片页面，应该允许图片来自任何地方，但限制表单的action属性只可以赋值为指定的端点。一个经过恰当设计的内容安全策略应该可以有效的保护页面免受跨站脚本攻击。</p><h3 id="跨站脚本攻击"><a href="#跨站脚本攻击" class="headerlink" title="跨站脚本攻击"></a>跨站脚本攻击</h3><p>CSP 的主要目标是减少和报告 XSS 攻击 ，XSS 攻击利用了浏览器对于从服务器所获取的内容的信任。恶意脚本在受害者的浏览器中得以运行，因为浏览器信任其内容来源，即使有的时候这些脚本并非来自于它本该来的地方。</p><p>CSP通过指定有效域——即浏览器认可的可执行脚本的有效来源——使服务器管理者有能力减少或消除XSS攻击所依赖的载体。一个CSP兼容的浏览器将会仅执行从白名单域获取到的脚本文件，忽略所有的其他脚本 (包括内联脚本和HTML的事件处理属性)。</p><p>作为一种终极防护形式，始终不允许执行脚本的站点可以选择全面禁止脚本执行。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>一个网站管理者想要所有内容均来自站点的同一个源 (不包括其子域名)</p><pre><code class="hljs html">Content-Security-Policy: default-src &#x27;self&#x27;</code></pre><p>一个网站管理者允许网页应用的用户在他们自己的内容中包含来自任何源的图片, 但是限制音频或视频需从信任的资源提供者(获得)，所有脚本必须从特定主机服务器获取可信的代码.</p><pre><code class="hljs html">Content-Security-Policy: default-src &#x27;self&#x27;; img-src *; media-src media1.com media2.com; script-src userscripts.example.com</code></pre><p>在这里，各种内容默认仅允许从文档所在的源获取, 但存在如下例外:</p><ul><li>图片可以从任何地方加载(注意 “*” 通配符)。</li><li>多媒体文件仅允许从 media1.com 和 media2.com 加载(不允许从这些站点的子域名)。</li><li>可运行脚本仅允许来自于userscripts.example.com。</li></ul><h2 id="X-Content-Type-Options"><a href="#X-Content-Type-Options" class="headerlink" title="X-Content-Type-Options"></a>X-Content-Type-Options</h2><p><code>X-Content-Type-Options</code> 响应首部相当于一个提示标志，被服务器用来提示客户端一定要遵循在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type"><code>Content-Type</code></a> 首部中对 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types">MIME 类型</a> 的设定，而不能对其进行修改。</p><p>注意: <code>nosniff</code> 只应用于 “<code>script</code>“ 和 “<code>style</code>“ 两种类型。事实证明，将其应用于图片类型的文件会导致<a href="https://github.com/whatwg/fetch/issues/395">与现有的站点冲突</a>。</p><h3 id="Apache配置-2"><a href="#Apache配置-2" class="headerlink" title="Apache配置"></a>Apache配置</h3><p>在配置文件中添加：</p><pre><code class="hljs pgsql"><span class="hljs-keyword">Header</span> <span class="hljs-keyword">set</span> X-Content-<span class="hljs-keyword">Type</span>-<span class="hljs-keyword">Options</span> nosniff</code></pre><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p><code>nosniff</code></p><p>下面两种情况的请求将被阻止：</p><ul><li>请求类型是”<code>style</code>“ 但是 MIME 类型不是 “<code>text/css</code>“，</li><li>请求类型是”<code>script</code>“ 但是 MIME 类型不是 <a href="https://html.spec.whatwg.org/multipage/scripting.html#javascript-mime-type">JavaScript MIME 类型</a>。</li></ul><h2 id="Referrer-Policy"><a href="#Referrer-Policy" class="headerlink" title="Referrer-Policy"></a>Referrer-Policy</h2><p><strong><code>Referrer-Policy</code></strong> 首部用来监管哪些访问来源信息——会在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Referer"><code>Referer</code></a> 中发送——应该被包含在生成的请求当中。</p><h3 id="Apache配置-3"><a href="#Apache配置-3" class="headerlink" title="Apache配置"></a>Apache配置</h3><p>在配置文件中添加：</p><pre><code class="hljs pgsql"><span class="hljs-keyword">Header</span> <span class="hljs-keyword">always</span> <span class="hljs-keyword">set</span> Referrer-<span class="hljs-keyword">Policy</span> &quot;no-referrer-when-downgrade&quot;</code></pre><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><p>注意 <code>Referer</code> 实际上是单词 “referrer” 的错误拼写。<code>Referrer-Policy</code> 这个首部并没有延续这个错误拼写。</p><pre><code class="hljs pgsql">Referrer-<span class="hljs-keyword">Policy</span>: <span class="hljs-keyword">no</span>-referrerReferrer-<span class="hljs-keyword">Policy</span>: <span class="hljs-keyword">no</span>-referrer-<span class="hljs-keyword">when</span>-downgradeReferrer-<span class="hljs-keyword">Policy</span>: originReferrer-<span class="hljs-keyword">Policy</span>: origin-<span class="hljs-keyword">when</span>-<span class="hljs-keyword">cross</span>-originReferrer-<span class="hljs-keyword">Policy</span>: same-originReferrer-<span class="hljs-keyword">Policy</span>: <span class="hljs-keyword">strict</span>-originReferrer-<span class="hljs-keyword">Policy</span>: <span class="hljs-keyword">strict</span>-origin-<span class="hljs-keyword">when</span>-<span class="hljs-keyword">cross</span>-originReferrer-<span class="hljs-keyword">Policy</span>: unsafe-url</code></pre><h2 id="Feature-Policy"><a href="#Feature-Policy" class="headerlink" title="Feature-Policy"></a>Feature-Policy</h2><p><strong>这是一个实验中的功能</strong></p><p>**<code>Feature-Policy</code>**响应头提供了一种可以在本页面或包含的iframe上启用或禁止浏览器特性的机制。</p><h3 id="Apache配置-4"><a href="#Apache配置-4" class="headerlink" title="Apache配置"></a>Apache配置</h3><p>在配置文件中添加：</p><pre><code class="hljs pgsql"><span class="hljs-keyword">Header</span> <span class="hljs-keyword">always</span> <span class="hljs-keyword">set</span> Feature-<span class="hljs-keyword">Policy</span> &quot;vibrate &#x27;self&#x27;; sync-xhr &#x27;self&#x27; https://cdn.defectink.com https://www.defectink.com&quot;</code></pre><h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><pre><code class="hljs gherkin"><span class="hljs-keyword">Feature</span>-Policy: <span class="hljs-variable">&lt;directive&gt;</span> <span class="hljs-variable">&lt;allowlist&gt;</span></code></pre><p><code>&lt;allowlist&gt;</code></p><ul><li><p><code>*</code>: 允许在当前文档和所有包含的内容（比如iframes）中使用本特性。</p></li><li><p><code>&#39;self&#39;</code>: 允许在当前文档中使用本特性，但在包含的内容（比如iframes）仍使用原值。</p></li><li><p><code>&#39;src&#39;</code>: (只在iframe中允许) 只要在<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe#Attributes">src</a> 中的URL和加载iframe用的URL相同，则本特性在iframe中允许，</p></li><li><p><code>&#39;none&#39;</code>: 从最上层到包含的内容都禁止本特性。 &lt;origin(s)&gt;: 在特定的源中允许，源URL以空格分割。</p></li><li><p><code>*</code>: 本特性默认在最上层和包含的内容中（iframes）允许。</p></li><li><p><code>&#39;self&#39;</code>: 本特性默认在最上层允许，而包含的内容中（iframes）使用源地址相同设定。也就是说本特性在iframe中不允许跨域访问。</p></li><li><p><code>&#39;none&#39;</code>: 本特性默认在最上层和包含的内容中（iframes）都禁止。</p></li></ul><p><code>*</code>(在所有源地址启用)<code>或&#39;none&#39;</code>(在所有源地址禁用)只允许单独使用，而<code>&#39;self&#39;</code>和<code>&#39;src&#39;</code>可以与多个源地址一起使用。</p><p>所有的特性都有一个如下的默认的allowlist</p><ul><li><code>*</code>: 本特性默认在最上层和包含的内容中（iframes）允许。</li><li><code>&#39;self&#39;</code>: 本特性默认在最上层允许，而包含的内容中（iframes）使用源地址相同设定。也就是说本特性在iframe中不允许跨域访问。</li><li><code>&#39;none&#39;</code>: 本特性默认在最上层和包含的内容中（iframes）都禁止。</li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><img src="../images/Header%E5%AE%9E%E8%B7%B5-%E5%BE%97%E6%8B%BF%E4%B8%8B%E8%BF%99%E4%B8%AAA/image-20191218171928050.webp" alt="image-20191218171928050"></p><h3 id="为什么没有A-？"><a href="#为什么没有A-？" class="headerlink" title="为什么没有A+？"></a>为什么没有A+？</h3><p>因为CSP的一个报错，拒绝加载内联的JS脚本。可以使用<code>unsafe-inline</code>来启用内联脚本。但是启用了<code>unsafe-inline</code>之后，就得不到A+了。</p><p><img src="../images/Header%E5%AE%9E%E8%B7%B5-%E5%BE%97%E6%8B%BF%E4%B8%8B%E8%BF%99%E4%B8%AAA/image-20191218172218399.webp" alt="image-20191218172218399"></p><pre><code class="hljs routeros">Refused <span class="hljs-keyword">to</span> execute inline<span class="hljs-built_in"> script </span>because it violates the following Content Security<span class="hljs-built_in"> Policy </span>directive: <span class="hljs-string">&quot;script-src &#x27;self&#x27; &#x27;unsafe-eval&#x27; https://maxcdn.bootstrapcdn.com https://ajax.googleapis.com https://cdn.defectink.com&quot;</span>. Either the <span class="hljs-string">&#x27;unsafe-inline&#x27;</span> keyword</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Security/HTTP_Strict_Transport_Security">HTTP Strict Transport Security</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP">内容安全策略( CSP )</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/X-Content-Type-Options">X-Content-Type-Options</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Referrer-Policy">Referrer-Policy</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Feature-Policy">Feature-Policy</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker-构建属于自己的镜像</title>
    <link href="/defect/docker-build-own-image.html"/>
    <url>/defect/docker-build-own-image.html</url>
    
    <content type="html"><![CDATA[<p>以前一直在使用别人构建好的镜像来使用Docker容器，在一次想搭建一个完整的Web环境时，发现使用过多容器非常难以管理。并且容器之间的交互通信变的困难。当然，也可以使用Docker Compose来捆绑多个镜像运行；不过对于运行服务较少的来说，使用Dockerfile来构建成一个镜像也是件好事。</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>首先，在构建一个镜像之前，需要先明白这个镜像将会包含哪些东西，运行哪些服务。目前主要是想在当前机器上跑一个hexo的blog。当然可以部署在Github，以前还写过一篇关于部署在Github的<a href="https://www.defectink.com/defect/set-up-the-hexo-blog.html">水文</a>。不过现在的想法是Github放一份，在本地服务器上也跑一个Server。</p><p>当然跑一个hexo是一件很简单的事情，使用Docker来部署也是为了想体验一下写<code>Dockerfile</code>。目前有两个思路：</p><ol><li><p>把node.js和hexo都部署在当前的宿主机，用Docker的Web服务器来跑宿主机生成的静态文件。</p><blockquote><p>但是这样的话就不需要用到Dockerfile了，直接pull一个http服务的镜像就好了。</p></blockquote></li><li><p>只在宿主机上使用Git来和Github同步文件，每次的生成和运行Web服务都放在Docker容器里。</p><blockquote><p>目前打算尝试的一种方式，可以在每次写完文章后使用Docker构建，并且也可以尝试Dockerfile了。</p></blockquote></li></ol><p>具体需要什么使用软件，完全看自己的需求，需要用到什么，就安装什么。就像在当前的宿主机上安装软件一样。只不过是使用Dockerfile来构建时安装的而已。</p><h2 id="构建自己的镜像"><a href="#构建自己的镜像" class="headerlink" title="构建自己的镜像"></a>构建自己的镜像</h2><p>好在还可以使用Dockerfile来基于其他的镜像来构建属于自己的镜像。可以在其他的系统基础镜像上来在构建时就安装自己需要的软件服务等，这样就可以构建一个自己需要的镜像了。</p><h3 id="使用基础镜像"><a href="#使用基础镜像" class="headerlink" title="使用基础镜像"></a>使用基础镜像</h3><p>构建时使用的第一个命令是<code>FROM</code>命令。它会指定一个用于构建的基础镜像。这样就可以在基础镜像中使用自己喜欢的发行版，也解决了继承其他 Docker 镜像的途径 。</p><p>创建一个目录，或者<code>clone</code>一个hexo博客等，在目录内编写一个<code>Dockerfile</code>。</p><pre><code class="hljs dockerfile"><span class="hljs-comment">#test</span>  <span class="hljs-keyword">FROM</span> alpine:latest<span class="hljs-keyword">MAINTAINER</span> Defectink &lt;i@defect.ink&gt;</code></pre><p>这里选择的是alpine系统作为基础镜像，主要原因是alpine是个超级轻量的系统，对于最为基础镜像可以有效的减少构建后镜像的大小。</p><p>除此之外，还有个<code>MAINTAINER</code>命令，它是用来著名当前Dockerfile的作者的。Docker支持<code>#</code>作为注释，使用起来很方便。</p><h3 id="第一次的构建"><a href="#第一次的构建" class="headerlink" title="第一次的构建"></a>第一次的构建</h3><p>编写了一个最基本的<code>Dockerfile</code>之后，就是运行第一次的构建测试了。使用<code>Docker</code>加上<code>build</code>来构建指定的<code>Dockerfile</code>为镜像。添加<code>-t</code>参数来为构建后的镜像指定一个tag标签，也就是之后的镜像(REPOSITORY)名。最后命令指定的目录是包含刚刚写好的<code>Dockerfile</code>文件的目录，被称作为“构建目录”。</p><p>当前系统下没有基础镜像alpine的话，在第一次运行时docker也会进行下载。</p><pre><code class="hljs bash"><span class="hljs-comment"># docker build -t blog /data/github/DefectingCat.github.io/                                          </span>Sending build context to Docker daemon     64kBStep 1/2 : FROM alpine:latestlatest: Pulling from library/alpine89d9c30c1d48: Pull complete Digest: sha256:c19173c5ada610a5989151111163d28a67368362762534d8a8121ce95cf2bd5aStatus: Downloaded newer image <span class="hljs-keyword">for</span> alpine:latest ---&gt; 965ea09ff2ebStep 2/2 : MAINTAINER Defectink &lt;i@defect.ink&gt; ---&gt; Running <span class="hljs-keyword">in</span> d572ac48c8f8Removing intermediate container d572ac48c8f8 ---&gt; b8296646acaaSuccessfully built b8296646acaaSuccessfully tagged blog:latest</code></pre><p>第一次的镜像构建已经完成了，虽然什么都没有进行定制，但已经迈出了第一步。</p><h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><p>迈出第一步之后，就可以开始考虑定制属于自己的镜像了。使用<code>docker images</code>可以查看当前系统下的docker镜像。也能看到刚刚所构建的第一个镜像。</p><pre><code class="hljs bash"><span class="hljs-comment"># docker images                                                                                      </span>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZEblog                latest              b8296646acaa        19 minutes ago      5.55MBalpine              latest              965ea09ff2eb        5 weeks ago         5.55MB</code></pre><p>既然是定制属于自己的镜像，那么肯定是需要安装所需求的软件的。这里我想构建一个运行hexo的镜像，所以至少需要3款软件：</p><ul><li>apache</li><li>node.js</li><li>hexo</li></ul><p>使用<code>RUN</code>命令来在基础镜像上执行命令，像是安装软件等操作。由于alpine默认时区不是国内，还可以顺便修改下时区。可以使用<code>RUN</code>来一次安装完所有需要的软件，不需要分开执行。</p><p>使用alpine的另个原因就是在它本身体积小的情况下，它安装软件还可以使用<code>--no-cache</code>来减少缓存。</p><p>在容器内使用npm来安装hexo时会出现一个<code>uid:0</code>的问题，npm会有生命周期，某个包会有生命周期来执行一些东西，安全起见会自动降级导致没有权限执行一些操作，通过``–unsafe-perm`参数来解锁该限制。</p><pre><code class="hljs dockerfile"><span class="hljs-comment">#install</span><span class="hljs-keyword">RUN</span><span class="bash"> apk update \</span><span class="bash">        &amp;&amp; apk upgrade \</span><span class="bash">        &amp;&amp; apk add --no-cache \</span><span class="bash">        apache2 \</span><span class="bash">        nodejs \</span><span class="bash">        npm \</span><span class="bash">        tzdata \</span><span class="bash">        &amp;&amp; cp -r -f /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \</span><span class="bash">        &amp;&amp; rm -rf /var/cache/apk/* \</span><span class="bash">        &amp;&amp; mkdir -p /data/DefectingCat.github.io \</span><span class="bash">        &amp;&amp; npm config <span class="hljs-built_in">set</span> unsafe-perm <span class="hljs-literal">true</span> \</span><span class="bash">        &amp;&amp; npm install -g hexo</span></code></pre><p>因为是基于一个操作系统上构建的镜像，所以在构建完成后可以使用Docker来运行一个“伪终端”，让我们可以直接在终端内进行一些修改和查看。值得注意的是，在“伪终端”里进行的操作只是在当前容器内的，不会被写入镜像。当前被关闭后，任何操作将不复存在。</p><p>在构建完后可以使用“伪终端”进入系统内查看一些信息，测试软件能否正常工作等。</p><pre><code class="hljs bash">docker run -it --rm blog</code></pre><p>关于这里的一些参数：</p><ul><li><p><code>-i</code>即使没有附加也保持STDIN 打开。</p></li><li><p><code>-t</code>分配一个伪终端。</p></li><li><p><code>--rm</code>在退出后立刻删除容器。</p></li></ul><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><pre><code class="hljs bash"><span class="hljs-comment"># docker build -t blog /data/github/DefectingCat.github.io/                                          </span>Sending build context to Docker daemon     64kBStep 1/5 : FROM alpine:latest ---&gt; 965ea09ff2ebStep 2/5 : MAINTAINER Defectink &lt;i@defect.ink&gt; ---&gt; Using cache ---&gt; 92cd04f91315</code></pre><p>在构建的时候可以在某一步(Step)下看到<code>Using cache</code>。 当 Docker 构建镜像时，它不仅仅构建一个单独的镜像；事实上，在构建过程中，它会构建许多镜像。 </p><p>输出信息中的每一步(Step)，Docker都在创建一个新的镜像。同时它还打印了镜像ID：<code> ---&gt; 92cd04f91315</code>。这样的好处在于，我们修改<code>Dockerfile</code>后重新构建镜像时，那些没有被修改的部分可以将上次构建的镜像当作缓存，加快构建的速度。</p><p>但是这也会有些小问题，Docker是根据<code>Dockerfile</code>来判断构建时的变化的。但如果需要执行更新软件等操作，而<code>Dockerfile</code>内的命令是没有变化时，Docker会继续使用以前的缓存，导致旧的软件还是被安装了。</p><p>所有在执行某些必要的操作时，不使用缓存也是极有好处的。在构建镜像时，<strong>使用<code>--no-cache=True</code>即可</strong>。</p><p><code>RUN</code>命令推荐使用一条命令完成尽可能多的操作，<code>Dockerfile</code>中的每个命令都会被分为构建镜像的一步来执行，这样可以减少构建时的步数(Step)。Docker 镜像类似于洋葱。它们都有很多层。为了修改内层，则需要将外面的层都删掉。</p><h3 id="第一次的运行"><a href="#第一次的运行" class="headerlink" title="第一次的运行"></a>第一次的运行</h3><p>将所有的软件都安装、测试完后，就可以构建能够第一次运行的镜像了。在此之前，还需要配置需要运行的软件，例如使用hexo生成静态文件，启动apache等。</p><pre><code class="hljs dockerfile"><span class="hljs-keyword">COPY</span><span class="bash"> DefectingCat.github.io /data/DefectingCat.github.io</span><span class="hljs-keyword">WORKDIR</span><span class="bash"> /data/DefectingCat.github.io</span><span class="hljs-keyword">RUN</span><span class="bash"> hexo g \</span><span class="bash">        &amp;&amp; cp -a public/* /var/www/localhost/htdocs</span><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span> <span class="hljs-number">443</span><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;/usr/sbin/httpd&quot;</span>,<span class="hljs-string">&quot;-f&quot;</span>,<span class="hljs-string">&quot;/etc/apache2/httpd.conf&quot;</span>,<span class="hljs-string">&quot;-DFOREGROUND&quot;</span>]</span></code></pre><ul><li><code>COPY</code>将宿主机上的文件复制进容器内的目录。在安装软件时就已经使用<code>RUN</code>来创建过需要的目录了。</li><li><code>WORKDIR</code>切换工作的目录，和<code>cd</code>类似；切换后<code>RUN</code>等命令都会在当前目录下工作。</li><li><code>EXPOSE</code>暴露需要使用到的端口。</li><li><code>CMD</code>和<code>RUN</code>类似，通常用于来启动容器服务。</li></ul><p>关于<code>CMD</code>：</p><p><code>CMD</code>只能存在一条，根据运行的软件，它将占据最后容器输出的终端。因为容器并不像虚拟化或者物理机那样，可以使用守护进程；容器本身就是一个进程，容器内没有后台服务的概念。正确的做法是使用<code>CMD</code>直接执行可执行文件，并且要求以前台形式运行。</p><p>当前的操作很简单，就是复制宿主机上git克隆下来的文件到容器的制定文件夹，然后使用<code>hexo</code>来生成静态文件，最后复制到<code>apache</code>的工作目录下。</p><p>到这里就可以来运行一个一次性的容器测试一下我们的服务是否运行正常了。如果上述都没有任何问题的话，现在打开浏览器就应该能看到hexo的blog了🎉。</p><pre><code class="hljs bash">docker run -p 80:80 --rm blog</code></pre><p>到目前为止，Dockerfile应该是这样的：</p><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> alpine:latest<span class="hljs-keyword">MAINTAINER</span> Defectink &lt;i@defect.ink&gt;<span class="hljs-comment">#install</span><span class="hljs-keyword">RUN</span><span class="bash"> apk update \</span><span class="bash">        &amp;&amp; apk upgrade \</span><span class="bash">        &amp;&amp; apk add --no-cache \</span><span class="bash">        apache2 \</span><span class="bash">        nodejs \</span><span class="bash">        npm \</span><span class="bash">        tzdata \</span><span class="bash">        &amp;&amp; cp -r -f /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \</span><span class="bash">        &amp;&amp; rm -rf /var/cache/apk/* \</span><span class="bash">        &amp;&amp; mkdir -p /data/DefectingCat.github.io \</span><span class="bash">        &amp;&amp; npm config <span class="hljs-built_in">set</span> unsafe-perm <span class="hljs-literal">true</span> \</span><span class="bash">        &amp;&amp; npm install -g hexo</span><span class="hljs-keyword">COPY</span><span class="bash"> DefectingCat.github.io /data/DefectingCat.github.io</span><span class="hljs-keyword">WORKDIR</span><span class="bash"> /data/DefectingCat.github.io</span><span class="hljs-keyword">RUN</span><span class="bash"> hexo g \</span><span class="bash">        &amp;&amp; cp -a public/* /var/www/localhost/htdocs</span><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span> <span class="hljs-number">443</span><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;/usr/sbin/httpd&quot;</span>,<span class="hljs-string">&quot;-f&quot;</span>,<span class="hljs-string">&quot;/etc/apache2/httpd.conf&quot;</span>,<span class="hljs-string">&quot;-DFOREGROUND&quot;</span>]</span></code></pre><p>安装了一些必要的软件，同时也尽量的减少了镜像构建后的大小。</p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>现代的网站应该都不会少的了SSL，也就是我们常见的https。目前自己的网站用的是最简单的LetsEncrypt，使用他家的工具Certbot来申请证书及其方便。在宿主机的环境下甚至还能自动配置。但是目前用的是Docker环境，在使用Dockefile构建时，是没有交互环境的。自动配置也可能无法生效。</p><h3 id="生成证书"><a href="#生成证书" class="headerlink" title="生成证书"></a>生成证书</h3><p>Certbot生成证书很是方便，在Docker环境下也是如此。使用官方的镜像可以很方便的生成：</p><pre><code class="hljs bash">sudo docker run -it --rm --name certbot \            -v <span class="hljs-string">&quot;/etc/letsencrypt:/etc/letsencrypt&quot;</span> \            -v <span class="hljs-string">&quot;/var/lib/letsencrypt:/var/lib/letsencrypt&quot;</span> \            certbot/certbot certonly</code></pre><p>配合<code>certonly</code>只获取证书，并<code>-v</code>来将容器的目录映射到宿主机，这样就能在生成后把证书存到宿主机目录了。</p><p>生成时，也会有两种工作模式选择：</p><pre><code class="hljs bash">How would you like to authenticate with the ACME CA?- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -1: Spin up a temporary webserver (standalone)2: Place files <span class="hljs-keyword">in</span> webroot directory (webroot)- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -Select the appropriate number [1-2] <span class="hljs-keyword">then</span> [enter] (press <span class="hljs-string">&#x27;c&#x27;</span> to cancel):</code></pre><p>分别是：</p><ul><li>standalone模式：启动一个临时的webserver；</li><li>webroot模式：将验证文件放到当前已有的webserver目录下；</li></ul><p>如果当前没有正在运行的webserver，使用standalone模式是最为方便的。Certbot将自己运行一个临时的webserver完成认证。但是如果使用standalone模式，在运行需要添加一个映射的端口：</p><pre><code class="hljs bash">sudo docker run -it -p 80:80 --rm --name certbot \            -v <span class="hljs-string">&quot;/data/docker/apache/letsencrypt:/etc/letsencrypt&quot;</span> \            -v <span class="hljs-string">&quot;/var/lib/letsencrypt:/var/lib/letsencrypt&quot;</span> \            certbot/certbot certonly</code></pre><p>因为Certbot启用了一个临时的webserver来验证域名解析，如果不把容器的<code>80</code>端口映射出来的话，将无法完成验证。</p><p>在一切都没有任何问题之后，就能看到Congratulations了：</p><pre><code class="hljs bash">IMPORTANT NOTES: - Congratulations! Your certificate and chain have been saved at:   /etc/letsencrypt/live/domain/fullchain.pem</code></pre><p>根据官网的说法，证书均链接在<code>/etc/letsencrypt/live</code>目录内。</p><blockquote><p><code>/etc/letsencrypt/archive</code> and <code>/etc/letsencrypt/keys</code> contain all previous keys and certificates, while <code>/etc/letsencrypt/live</code> symlinks to the latest versions.</p></blockquote><h3 id="Mod-ssl"><a href="#Mod-ssl" class="headerlink" title="Mod_ssl"></a>Mod_ssl</h3><p>有了证书之后，apache还需要ssl的mod。alpine的镜像安装apache时是没有安装的ssl的mod。所以还需要在Dockerfile内添加一行，手动进行安装，包名为<code>apache2-ssl</code>：</p><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="bash"> apk update \</span><span class="bash">        &amp;&amp; apk upgrade \</span><span class="bash">        &amp;&amp; apk add --no-cache \</span><span class="bash">        apache2 \</span><span class="bash">        apache2-ssl \</span></code></pre><p>在重新构建之前，还需要修改apache的<code>ssl.conf</code>。如何取得<code>ssl.conf</code>呢？我们只需要构建一个临时的alpine镜像，在容器内使用相同的命令安装一个apache与ssl mod，之后在<code>/etc/apache2/conf.d</code>目录内就有<code>ssl.conf</code>配置文件了。将其copy到宿主机内修改就好了。</p><pre><code class="hljs bash">apk add apache2-ssl</code></pre><p>在启动命令内的<code>httpd.conf</code>配置文件会包含<code>ssl.conf</code>。所以只需要修改<code>ssl.conf</code>，再在构建时将其copy到镜像内就好了。</p><p><code>httpd.conf</code>内的已有配置：</p><pre><code class="hljs awk">IncludeOptional <span class="hljs-regexp">/etc/</span>apache2<span class="hljs-regexp">/conf.d/</span>*.conf</code></pre><p>那么，如何优雅的将容器内的<code>ssl.conf</code>copy出来呢？</p><p>可以在先将容器放在后台运行：</p><pre><code class="hljs bash">docker run -id <span class="hljs-built_in">test</span></code></pre><p>然后使用docker自带的<code>docker cp</code>命令来copy到宿主机的目录：</p><pre><code class="hljs bash">docker cp 253d3ca34521:/etc/apache2/conf.d/ssl.conf /root</code></pre><p>当然也可以直接打开，然后记录文件内容再复制出来。</p><p>有了Mod_ssl组件之后，就可以配合SSL证书来对网站进行加密了。既然能将默认的<code>ssl.conf</code>复制出来，就可以对其修改然后在生成镜像时再复制会容器内的原目录。</p><p>剩下对于SSL的配置就和给宿主机配置加密一样了，几乎没有什么不同。主要就是在<code>ssl.conf</code>中填上正确的证书目录：</p><pre><code class="hljs awk">SSLCertificateFile <span class="hljs-regexp">/etc/</span>letsencrypt<span class="hljs-regexp">/live/</span>defect.ink/fullchain.pem<span class="hljs-comment">#SSLCertificateFile /etc/ssl/apache2/server-dsa.pem</span><span class="hljs-comment">#SSLCertificateFile /etc/ssl/apache2/server-ecc.pem</span><span class="hljs-comment">#   Server Private Key:</span><span class="hljs-comment">#   If the key is not combined with the certificate, use this</span><span class="hljs-comment">#   directive to point at the key file.  Keep in mind that if</span><span class="hljs-comment">#   you&#x27;ve both a RSA and a DSA private key you can configure</span><span class="hljs-comment">#   both in parallel (to also allow the use of DSA ciphers, etc.)</span><span class="hljs-comment">#   ECC keys, when in use, can also be configured in parallel</span>SSLCertificateKeyFile <span class="hljs-regexp">/etc/</span>letsencrypt<span class="hljs-regexp">/live/</span>defect.ink/privkey.pem</code></pre><p>Let’s Encrypt生成的证书在路径下还会有个<code>fullchain.pem</code>，这是一整个证书链。在配置文件中只需要这个证书和一个私钥<code>privkey.pem</code>就好。</p><h3 id="跳转至443"><a href="#跳转至443" class="headerlink" title="跳转至443"></a>跳转至443</h3><p>在有了https之后，如果不需要80端口还能继续访问。可以使用301跳转来将访问80端口的访客都跳转到443。Apache的mod_rewrite可以轻松的实现针对各种条件的跳转。</p><p>mod_rewrite的作用很多，能设置的条件也可以很复杂。当然配置个简单的跳转不是非常的复杂。</p><pre><code class="hljs apache"><span class="hljs-attribute"><span class="hljs-nomarkup">RewriteEngine</span></span> <span class="hljs-literal">on</span><span class="hljs-attribute"><span class="hljs-nomarkup">RewriteCond</span></span> <span class="hljs-variable">%&#123;SERVER_NAME&#125;</span> =defect.ink<span class="hljs-attribute"><span class="hljs-nomarkup">RewriteRule</span></span> ^ https://<span class="hljs-variable">%&#123;SERVER_NAME&#125;</span><span class="hljs-variable">%&#123;REQUEST_URI&#125;</span><span class="hljs-meta"> [END,NE,R=permanent]</span></code></pre><ul><li><code>RewriteEngine</code>打开跳转引擎；</li><li><code>RewriteCond</code>跳转的条件；这里设置当域名为<code>defect.ink</code>时，执行下面的跳转动作；</li><li><code>RewriteRule</code>跳转的动作；当符合上面的条件时，执行添加https<code>https://%&#123;SERVER_NAME&#125;%&#123;REQUEST_URI&#125;</code>。而后面的变量保持不动。</li></ul><p>这行配置是来自于certbot的自动配置中的，在配置宿主机的ssl时可以选择全部跳转。然后它就会帮我们自动配置了。对其进行简单的修改就可以作用与其他的配置文件了。</p><p>这几行推荐是写在<code>httpd.conf</code>的末尾，也就是<code>IncludeOptional /etc/apache2/conf.d/*.conf</code>的上方。虽然ssl.conf也会被include进来，但是还是感觉写在这里要方便一点。</p><p>然后将<code>httpd.conf</code>和<code>ssl.conf</code>一样在构建时复制到容器内就ok了。</p><pre><code class="hljs dockerfile">&amp;&amp; cp -a ssl.conf /etc/apache2/conf.d/ \&amp;&amp; cp -a httpd.conf /etc/apache2/</code></pre><h3 id="Renew"><a href="#Renew" class="headerlink" title="Renew"></a>Renew</h3><p>Let’s Encrypt的证书虽然很方便，但是一次只能生成三个月有效期的证书。使用和生成差不多的方法renew证书就好了。</p><pre><code class="hljs livescript">sudo docker run -<span class="hljs-literal">it</span> -p <span class="hljs-number">80</span>:<span class="hljs-number">80</span> --rm --name certbot <span class="hljs-string">\</span>             -v <span class="hljs-string">&quot;/data/docker/apache/letsencrypt:/etc/letsencrypt&quot;</span> <span class="hljs-string">\</span>             -v <span class="hljs-string">&quot;/var/lib/letsencrypt:/var/lib/letsencrypt&quot;</span> <span class="hljs-string">\</span>             certbot/certbot renew</code></pre><p>想要自动化执行话，可以使用crontab来定时运行。</p><h2 id="全部的Dockerfile"><a href="#全部的Dockerfile" class="headerlink" title="全部的Dockerfile"></a>全部的Dockerfile</h2><p>这时候的配置文件看起来应该是这个样子的：</p><pre><code class="hljs dockerfile"><span class="hljs-comment">#test</span>  <span class="hljs-keyword">FROM</span> alpine:latest<span class="hljs-keyword">MAINTAINER</span> Defectink &lt;i@defect.ink&gt;<span class="hljs-comment">#install</span><span class="hljs-keyword">RUN</span><span class="bash"> apk update \</span><span class="bash">        &amp;&amp; apk upgrade \</span><span class="bash">        &amp;&amp; apk add --no-cache \</span><span class="bash">        apache2 \</span><span class="bash">        apache2-ssl \</span><span class="bash">        nodejs \</span><span class="bash">        npm \</span><span class="bash">        tzdata \</span><span class="bash">        &amp;&amp; cp -r -f /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \</span><span class="bash">        &amp;&amp; rm -rf /var/cache/apk/* \</span><span class="bash">        &amp;&amp; mkdir -p /data/DefectingCat.github.io \</span><span class="bash">        &amp;&amp; npm config <span class="hljs-built_in">set</span> unsafe-perm <span class="hljs-literal">true</span> \</span><span class="bash">        &amp;&amp; npm install -g hexo</span><span class="hljs-keyword">COPY</span><span class="bash"> DefectingCat.github.io /data/DefectingCat.github.io</span><span class="hljs-keyword">WORKDIR</span><span class="bash"> /data/DefectingCat.github.io</span><span class="hljs-keyword">RUN</span><span class="bash"> hexo g \</span><span class="bash">        &amp;&amp; cp -a public/* /var/www/localhost/htdocs/ \</span><span class="bash">        &amp;&amp; cp -a ssl.conf /etc/apache2/conf.d/ \</span><span class="bash">        &amp;&amp; cp -a httpd.conf /etc/apache2/</span><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span> <span class="hljs-number">443</span><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;/usr/sbin/httpd&quot;</span>,<span class="hljs-string">&quot;-f&quot;</span>,<span class="hljs-string">&quot;/etc/apache2/httpd.conf&quot;</span>,<span class="hljs-string">&quot;-DFOREGROUND&quot;</span>]</span></code></pre><h2 id="启动！"><a href="#启动！" class="headerlink" title="启动！"></a>启动！</h2><pre><code class="hljs bash">docker run -id --name=<span class="hljs-string">&quot;blog&quot;</span> -v /etc/letsencrypt/:/etc/letsencrypt/ -p 80:80 -p 443:443 blog</code></pre><p>全部操作完了，启动命令也随着操作变得更加的复杂了。</p><ul><li><code>-id</code>扔到后台；</li><li><code>--name</code>容器别名；</li><li><code>-v</code>映射之前的ssl证书的目录；</li><li><code>-p</code>80和443都需要映射；</li></ul><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>一些比较方便的命令。</p><p>删除所有<code>&lt;none&gt;</code>的镜像：</p><pre><code class="hljs bash">docker rmi $(docker images -f <span class="hljs-string">&quot;dangling=true&quot;</span> -q)</code></pre><p>停止所有容器，删除所有容器：</p><pre><code class="hljs bash">docker <span class="hljs-built_in">kill</span> $(docker ps -q) ; docker rm $(docker ps -a -q)</code></pre><p>停止所有容器，删除所有容器，<strong>删除所有镜像</strong>：</p><pre><code class="hljs bash">docker <span class="hljs-built_in">kill</span> $(docker ps -q) ; docker rm $(docker ps -a -q) ; docker rmi $(docker images -q -a)</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://www.digitalocean.com/community/tutorials/how-to-create-an-ssl-certificate-on-apache-for-centos-7">How To Create an SSL Certificate on Apache for CentOS 7</a></p></li><li><p><a href="https://pkgs.alpinelinux.org/package/edge/main/x86/apache2-ssl">apache2-ssl</a></p></li><li><p><a href="https://certbot.eff.org/docs/install.html#running-with-docker">Certbot running with Docker</a></p></li><li><p><a href="https://certbot.eff.org/docs/using.html#where-certs">Where my Certificate</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>修改Windows端iCloud云盘存储位置</title>
    <link href="/defect/modify-icloud-storage-location-on-windows.html"/>
    <url>/defect/modify-icloud-storage-location-on-windows.html</url>
    
    <content type="html"><![CDATA[<p>自从有了水果之后，除了天天被人嘲讽之外，还花了大手笔买了一个月6块的iCloud 50GB存储空间。但是光有手机来用还是略微有点大。以前一直以为iCloud就是手机上存个照片的，都忘了它其实也是一个云盘来着。于是决定利用一下剩下的空间，在Windows也用它来同步。</p><p>果然在试用了一段时间过后，水果没有让我失望过。iCloud照片可以跟着Windows系统的【图片】文件夹跑，但是iCloud云盘就不那么听话了，它只会在<code>User</code>目录下直接怼一个目录，并且<strong>无法修改</strong>，连个设置都没有。对于我这种C盘小的可怜的来说，就非常难受了。</p><p>所以只能用最基本的方法，创建符号链接 : 软链接来解决问题了。</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><ol><li>找到当前的iCloud云盘文件夹位置，并剪切到目的位置。当然先复制更加稳妥。</li><li>关掉不听话的iCloud。</li><li>以管理员身份运行cmd，创建符号链接到新的存储位置。需要删除已经存在c盘的文件夹。</li></ol><pre><code class="hljs cmd"><span class="hljs-function">C:\<span class="hljs-title">WINDOWS</span>\<span class="hljs-title">system32</span>&gt;<span class="hljs-title">mklink</span> /<span class="hljs-title">D</span> <span class="hljs-title">C</span>:\<span class="hljs-title">Users</span>\<span class="hljs-title">Defectink</span>\<span class="hljs-title">iCloudDrive</span> <span class="hljs-title">D</span>:\<span class="hljs-title">iCloudDrive</span></span><span class="hljs-function">为 <span class="hljs-title">C</span>:\<span class="hljs-title">Users</span>\<span class="hljs-title">Defectink</span>\<span class="hljs-title">iCloudDrive</span> &lt;&lt;===&gt;&gt; <span class="hljs-title">D</span>:\<span class="hljs-title">iCloudDrive</span> 创建的符号链接</span></code></pre><ol start="4"><li>重新运行iCloud。</li></ol><p>没有退出按钮？</p><p><img src="../images/%E4%BF%AE%E6%94%B9Windows%E7%AB%AFiCloud%E4%BA%91%E7%9B%98%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE/image-20191029200503950.webp" alt="image-20191029200503950"></p><blockquote><p>如果先退出再复制文件可能会导致意外</p></blockquote><p><img src="../images/%E4%BF%AE%E6%94%B9Windows%E7%AB%AFiCloud%E4%BA%91%E7%9B%98%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE/image-20191029200837325.webp" alt="image-20191029200837325"></p><h2 id="启动文件夹"><a href="#启动文件夹" class="headerlink" title="启动文件夹"></a>启动文件夹</h2><p>我的iCloud不知道为什么就是无法开机自启，无奈只好放到Windows的启动文件夹里了。<del>效果还可以</del></p><pre><code class="hljs cmd"><span class="hljs-function">shell:<span class="hljs-title">startup</span></span></code></pre>]]></content>
    
    
    <categories>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ASCII在线视频流</title>
    <link href="/defect/online-ascii-video.html"/>
    <url>/defect/online-ascii-video.html</url>
    
    <content type="html"><![CDATA[<p>什么是ASCII？</p><p>来自百度百科的解释：<br>ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。它是现今最通用的单字节编码系统，并等同于国际标准ISO/IEC 646。</p><p>应该很多小伙伴们都非常熟悉ASCII码了，它也是现今最能玩的一套编码了吧（雾💊</p><p>那么ascii视频流又是啥呢？</p><p>这是来自某位大佬胡乱起的名字。🤣</p><p><img src="../images/ASCII%E5%9C%A8%E7%BA%BF%E8%A7%86%E9%A2%91%E6%B5%81/%E5%9B%BE%E5%83%8F-1.webp" alt="图像-1"></p><h2 id="那么如何安装呢？"><a href="#那么如何安装呢？" class="headerlink" title="那么如何安装呢？"></a>那么如何安装呢？</h2><p>根据<a href="https://file.aoaoao.me/2018/03/26/e6-9e-84-e5-bb-ba-e4-b8-80-e4-b8-aa-e5-9c-a8-e7-ba-bfascii-e8-a7-86-e9-a2-91-e6-b5-81-e6-9c-8d-e5-8a-a1/#%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E8%BF%99%E4%B9%88%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%EF%BC%9F">大佬的文章</a>与开源项目。首先我们需要：</p><ol><li>ffmpeg</li><li><a href="https://github.com/hit9/img2txt">hit9/img2txt</a></li><li><a href="https://github.com/HFO4/plus1s.live">HFO4/plus1s.live</a></li><li>node.js/Go/Python运行环境</li></ol><h3 id="使用ffmpeg截取视频片段"><a href="#使用ffmpeg截取视频片段" class="headerlink" title="使用ffmpeg截取视频片段"></a>使用ffmpeg截取视频片段</h3><p>安装ffmpeg：</p><p><strong>CentOS</strong><br>由于CentOS没有官方FFmpeg rpm软件包。但是，我们可以使用第三方YUM源（Nux Dextop）完成此工作。</p><pre><code class="hljs centos7">sudo rpm --import http:&#x2F;&#x2F;li.nux.ro&#x2F;download&#x2F;nux&#x2F;RPM-GPG-KEY-nux.rosudo rpm -Uvh http:&#x2F;&#x2F;li.nux.ro&#x2F;download&#x2F;nux&#x2F;dextop&#x2F;el7&#x2F;x86_64&#x2F;nux-dextop-release-0-5.el7.nux.noarch.rpmsudo rpm --import http:&#x2F;&#x2F;li.nux.ro&#x2F;download&#x2F;nux&#x2F;RPM-GPG-KEY-nux.rosudo rpm -Uvh http:&#x2F;&#x2F;li.nux.ro&#x2F;download&#x2F;nux&#x2F;dextop&#x2F;el6&#x2F;x86_64&#x2F;nux-dextop-release-0-2.el6.nux.noarch.rpm</code></pre><p><strong>Ubuntu</strong><br>Ubuntu的源里默认就有ffmpeg的软件包，所以我们直接安装就ok了。</p><pre><code class="hljs cmake">apt <span class="hljs-keyword">install</span> ffmpeg</code></pre><p>拥有了ffmpeg之后，我们可以使用如下命令：</p><pre><code class="hljs apache"><span class="hljs-attribute">ffmpeg</span> -i demo.mp<span class="hljs-number">4</span> -r <span class="hljs-number">5</span> -ss <span class="hljs-number">00</span>:<span class="hljs-number">01</span>:<span class="hljs-number">13</span> -t <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">15</span> %<span class="hljs-number">03</span>d.png</code></pre><p>将demo视频的第1分13秒后的15秒以每秒5帧的速度保存为图像，图像名格式为001.png 002.png ……<br>效果如下：</p><p><img src="../images/ASCII%E5%9C%A8%E7%BA%BF%E8%A7%86%E9%A2%91%E6%B5%81/%E5%9B%BE%E5%83%8F-2.webp" alt="图像-2"></p><pre><code class="hljs bash">➜  ~ ls time001.png  005.png  009.png  013.png  017.png  021.png  025.png  029.png  033.png  037.png  041.png  045.png  049.png  053.png  057.png  061.png  065.png  069.png  073.png002.png  006.png  010.png  014.png  018.png  022.png  026.png  030.png  034.png  038.png  042.png  046.png  050.png  054.png  058.png  062.png  066.png  070.png  074.png003.png  007.png  011.png  015.png  019.png  023.png  027.png  031.png  035.png  039.png  043.png  047.png  051.png  055.png  059.png  063.png  067.png  071.png  075.png004.png  008.png  012.png  016.png  020.png  024.png  028.png  032.png  036.png  040.png  044.png  048.png  052.png  056.png  060.png  064.png  068.png  072.png</code></pre><h3 id="使用修改过的hit9-img2txt将图像转换为ASCII画"><a href="#使用修改过的hit9-img2txt将图像转换为ASCII画" class="headerlink" title="使用修改过的hit9/img2txt将图像转换为ASCII画"></a>使用修改过的hit9/img2txt将图像转换为ASCII画</h3><blockquote><p>原版hit9/img2txt只能单张转换，我稍微改了下，可以批量转换并保存为txt。修改后的版本：<a href="https://github.com/HFO4/img2txt/blob/gh-pages/img2txt.py">https://github.com/HFO4/img2txt/blob/gh-pages/img2txt.py</a></p></blockquote><p>可能大佬都是说改就改的吧。<br>完事我们clone下来后修改img2txt.py第246行的目录为上一步存放图像的目录：</p><pre><code class="hljs basic"><span class="hljs-symbol">246 </span>        imgname = <span class="hljs-string">&quot;/root/time/&quot;</span>+str(i).zfill(<span class="hljs-number">3</span>)+<span class="hljs-string">&quot;.png&quot;</span></code></pre><p>然后再执行：</p><pre><code class="hljs vim">pip install img2txt.<span class="hljs-keyword">py</span><span class="hljs-keyword">python</span> img2txt.<span class="hljs-keyword">py</span> h</code></pre><p>稍等片刻，ASCII字符文件便会存放到与img2txt.py同级的pic目录下。若提示无pic文件夹导致的错误，手动创建一个名为<code>pic</code>的文件夹再运行一次即可。</p><h3 id="部署在线服务"><a href="#部署在线服务" class="headerlink" title="部署在线服务"></a>部署在线服务</h3><p>最后，使用大佬的<a href="https://github.com/HFO4/plus1s.live">HFO4/plus1s.live</a>来部署在线播放的服务。</p><p>将上一步使用img2txt的pic文件夹中的图片放到改项目下的pic文件夹内，然后修改stream.go的第13行为你得到的单帧图像的总个数。保存后执行：</p><pre><code class="hljs glsl">go build <span class="hljs-keyword">stream</span>.go./<span class="hljs-keyword">stream</span></code></pre><p>然后程序会默认开放一个暴力的端口，使用<code>curl 您的ip:1926</code>命令即可查看效果。</p><h2 id="另一款强大的软件"><a href="#另一款强大的软件" class="headerlink" title="另一款强大的软件"></a>另一款强大的软件</h2><blockquote><p>📺ASCIIPlayer : Golang写的ASCII码播放器</p></blockquote><p><img src="../images/ASCII%E5%9C%A8%E7%BA%BF%E8%A7%86%E9%A2%91%E6%B5%81/ascii_cat.gif" alt="ascii_cat"><br>如同作者自己所说的，该软件是Go语言写的一款强大的Ascii码的转码加播放器。</p><ul><li><p><a href="https://segmentfault.com/a/1190000016976239">ASCIIPlayer : Golang写的ASCII码播放器</a></p></li><li><p><a href="https://github.com/qeesung/asciiplayer">asciiplayer</a></p></li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code class="hljs vim"><span class="hljs-keyword">go</span> <span class="hljs-built_in">get</span> -<span class="hljs-keyword">u</span> github.<span class="hljs-keyword">com</span>/qeesung/asciiplayer</code></pre><p>安装后若提示：</p><pre><code class="hljs groovy"><span class="hljs-attr">zsh:</span> command not <span class="hljs-attr">found:</span> asciiplayer</code></pre><p>则在当前目录下会缓存一个<code>go</code>文件夹，在<code>go/bin/</code>文件夹内会有一个可执行的asciiplayer。我们将其copy至<code>/usr/bin/</code>目录下，并重连ssh即可解决。</p><pre><code class="hljs awk">cp -a asciiplayer <span class="hljs-regexp">/usr/</span>bin</code></pre><h3 id="三种工作模式"><a href="#三种工作模式" class="headerlink" title="三种工作模式"></a>三种工作模式</h3><p>该软件强大的地方就是在此了，对于转换为ascii码，它拥有三个工作模式：</p><ul><li>输出到一个一般文件中(Encode模式)： 这里我们只能逐帧，逐像素的将转化以后的ASCII图像写到文件中去。</li><li>输出到终端(Play模式): 直接将转换以后的图像按照一定的频率输出到终端即可。</li><li>输出到远端客户端(Server模式): 这里和输出到终端的原理类似，只是输出到了远端客户端所在的终端。</li></ul><pre><code class="hljs gherkin">                 +---------------+                                                  +---------+                 |<span class="hljs-string">               </span>|<span class="hljs-string">                                                  </span>|<span class="hljs-string">         </span>|          +------&gt; Gif Decoder   |<span class="hljs-string">                                              +---&gt; Encoder +---&gt; file</span><span class="hljs-string">          </span>|<span class="hljs-string">      </span>|<span class="hljs-string">               </span>|<span class="hljs-string">                                              </span>|<span class="hljs-string">   </span>|<span class="hljs-string">         </span>|          |<span class="hljs-string">      +---------------+                                              </span>|<span class="hljs-string">   +---------+</span><span class="hljs-string">          </span>|<span class="hljs-string">      +---------------+                +-------------+               </span>|<span class="hljs-string">   +---------+</span><span class="hljs-string">          </span>|<span class="hljs-string">      </span>|<span class="hljs-string">               </span>|<span class="hljs-string">                </span>|<span class="hljs-string">             </span>|<span class="hljs-string">               </span>|<span class="hljs-string">   </span>|<span class="hljs-string">         </span>|Input File+------&gt; Image Decoder +---&gt; Frames +--&gt;+ Image2ASCII +-&gt;ASCII Frames-+---&gt; Player  +---&gt; stdout          |<span class="hljs-string">      </span>|<span class="hljs-string">               </span>|<span class="hljs-string">                </span>|<span class="hljs-string">             </span>|<span class="hljs-string">               </span>|<span class="hljs-string">   </span>|<span class="hljs-string">         </span>|          |<span class="hljs-string">      +---------------+                +-------------+               </span>|<span class="hljs-string">   +---------+</span><span class="hljs-string">          </span>|<span class="hljs-string">      +---------------+                                              </span>|<span class="hljs-string">   +---------+</span><span class="hljs-string">          </span>|<span class="hljs-string">      </span>|<span class="hljs-string">               </span>|<span class="hljs-string">                                              </span>|<span class="hljs-string">   </span>|<span class="hljs-string">         </span>|          +------&gt; Video Decoder |<span class="hljs-string">                                              +---&gt; Server  +---&gt; socket</span><span class="hljs-string">                 </span>|<span class="hljs-string">               </span>|<span class="hljs-string">                                                  </span>|<span class="hljs-string">         </span>|                 +---------------+                                                  +---------+</code></pre><p>以至于它一款软件就能够直接实现我们是上述将视频中抽去图片再挨个转换为文本的ASCII码的工作了。除了不能将我们需要的输出为文本保存以外，其他都很完美。<br>唯一一个缺点就是目前还不支持直接读取视频文件，只能先使用ffmpeg将视频转换为gif中，在用此软件读取。作者目前也说后续会支持视频的。🎉</p><h3 id="常用的命令"><a href="#常用的命令" class="headerlink" title="常用的命令"></a>常用的命令</h3><ul><li>play</li></ul><p>通过适配屏幕的方式播放GIF</p><pre><code class="hljs css"><span class="hljs-selector-tag">asciiplayer</span> <span class="hljs-selector-tag">play</span> <span class="hljs-selector-tag">demo</span><span class="hljs-selector-class">.gif</span></code></pre><p>缩小为原来的十分之一，然后播放GIF</p><pre><code class="hljs apache"><span class="hljs-attribute">asciiplayer</span> play demo.gif -r <span class="hljs-number">0</span>.<span class="hljs-number">1</span></code></pre><p>缩放成固定的长和宽，然后播放GIF</p><pre><code class="hljs angelscript">asciiplayer play demo.gif -w <span class="hljs-number">100</span> -h <span class="hljs-number">40</span></code></pre><p>播放一个PNG图片</p><pre><code class="hljs css"><span class="hljs-selector-tag">asciiplayer</span> <span class="hljs-selector-tag">play</span> <span class="hljs-selector-tag">demo</span><span class="hljs-selector-class">.png</span></code></pre><ul><li>encode</li></ul><p>将一个GIF文件demo.gif编码为ASCII的Gif文件output.gif</p><pre><code class="hljs css"><span class="hljs-selector-tag">asciiplayer</span> <span class="hljs-selector-tag">encode</span> <span class="hljs-selector-tag">demo</span><span class="hljs-selector-class">.gif</span> <span class="hljs-selector-tag">-o</span> <span class="hljs-selector-tag">output</span><span class="hljs-selector-class">.gif</span></code></pre><p>指定输出ASCII字符大小的情况下，讲一个GIF文件demo.gif编码成ASCII的GIF动图文件output.gif</p><pre><code class="hljs lua">asciiplayer encode demo.gif -o <span class="hljs-built_in">output</span>.gif <span class="hljs-comment">--font_size=5</span></code></pre><p>将GIF动图demo.gif缩放为原来的十分之一，然后编码成ASCII的GIF动图文件output.gif</p><pre><code class="hljs css"><span class="hljs-selector-tag">asciiplayer</span> <span class="hljs-selector-tag">encode</span> <span class="hljs-selector-tag">demo</span><span class="hljs-selector-class">.gif</span> <span class="hljs-selector-tag">-o</span> <span class="hljs-selector-tag">output</span><span class="hljs-selector-class">.gif</span> <span class="hljs-selector-tag">-r</span> 0<span class="hljs-selector-class">.1</span></code></pre><p>编码一个jpeg文件，然后输出一个ASCII的output.png文件</p><pre><code class="hljs css"><span class="hljs-selector-tag">asciiplayer</span> <span class="hljs-selector-tag">encode</span> <span class="hljs-selector-tag">demo</span><span class="hljs-selector-class">.jpeg</span> <span class="hljs-selector-tag">-o</span> <span class="hljs-selector-tag">output</span><span class="hljs-selector-class">.png</span></code></pre><ul><li>Server</li></ul><p>输入demo.gif，并以默认端口8080启动一个http服务器</p><pre><code class="hljs routeros">asciiplayer<span class="hljs-built_in"> server </span>demo.gif</code></pre><p>输入demo.gif，并以自定义端口8888启动一个http服务器</p><pre><code class="hljs routeros">asciiplayer<span class="hljs-built_in"> server </span>demo.gif --port 8888</code></pre><p>输入一个demo.png图片，并且启动http 服务器</p><pre><code class="hljs routeros">asciiplayer<span class="hljs-built_in"> server </span>demo.png</code></pre><h2 id="大佬们"><a href="#大佬们" class="headerlink" title="大佬们"></a>大佬们</h2><p><a href="https://segmentfault.com/a/1190000016976239#articleHeader0">ASCIIPlayer : Golang写的ASCII码播放器</a><br><a href="https://file.aoaoao.me/2018/03/26/e6-9e-84-e5-bb-ba-e4-b8-80-e4-b8-aa-e5-9c-a8-e7-ba-bfascii-e8-a7-86-e9-a2-91-e6-b5-81-e6-9c-8d-e5-8a-a1/#%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E8%BF%99%E4%B9%88%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%EF%BC%9F">构建一个在线ASCII视频流服务</a></p><h2 id="Try-it"><a href="#Try-it" class="headerlink" title="Try it ?"></a>Try it ?</h2><pre><code class="hljs css"><span class="hljs-selector-tag">curl</span> <span class="hljs-selector-tag">time</span><span class="hljs-selector-class">.defect</span><span class="hljs-selector-class">.ink</span><span class="hljs-selector-pseudo">:1926</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bark-水果自定义通知大法🍎</title>
    <link href="/defect/bark-custom-notification-for-apple.html"/>
    <url>/defect/bark-custom-notification-for-apple.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>ding~</p></blockquote><p>用了一段时间的水果了，发现它的通知来的还是非常及时的。基本上只要连接了网络，通知都不会落下。简单了解过IOS的通知机制：APP→水果服务器→你的机器。也就是说这三个步骤都能够正常通信的情况下，我们的机器就能正常的收到通知。</p><p>在Android平台也有类似的通知机制，也是由服务端来推送通知到我们的机器，从而到达APP可以不挂后台的情况下收到推送。但是为什么国内的UI用不了我就不清楚了。</p><img src="https://support.apple.com/library/content/dam/edam/applecare/images/zh_CN/iOS/ios12-iphone-x-notification-screen-animation.gif" alt="ding" style="zoom:50%;" /><h2 id="给自己发通知🐾"><a href="#给自己发通知🐾" class="headerlink" title="给自己发通知🐾"></a>给自己发通知🐾</h2><p>上述我们简单了解到，既然是由APP控制的推送通知，那么我们既然想要自定义通知就非常简单了。只需要一个能够由我们控制的APP就可以了。</p><p>App Store中有位大佬开发的<a href="https://apps.apple.com/cn/app/bark-%E7%BB%99%E4%BD%A0%E7%9A%84%E6%89%8B%E6%9C%BA%E5%8F%91%E6%8E%A8%E9%80%81/id1403753865">Bark</a>就是为了这事存在的，它的存在目的就是为了让我们自己给自己推送通知。、</p><p>Github：<a href="https://github.com/Finb/Bark">Bark</a></p><p><img src="../images/%E6%B0%B4%E6%9E%9C%E8%87%AA%E5%AE%9A%E4%B9%89%E9%80%9A%E7%9F%A5%E5%A4%A7%E6%B3%95/1561705066368.webp" alt="1561705066368"></p><p>默认它提供了自己的服务器，如果我们需要推送一些较为隐私的消息，可以使用自建服务端。它提供了http接口，后端简单调用即可给自己的水果设备发送推送。</p><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>服务端是一个开源项目，<a href="https://github.com/Finb/bark-server"><strong>bark-server</strong></a>，这是一个非常简单易用的服务端软件。</p><p>部署非常简单，并且也有docker的部署方式:</p><pre><code class="hljs jboss-cli">docker run -dt <span class="hljs-params">--name</span> bark -p 8080<span class="hljs-function">:8080</span> -v `<span class="hljs-keyword">pwd</span>`<span class="hljs-string">/bark-data</span>:<span class="hljs-string">/data</span> finab/bark-server</code></pre><p>当然和我一样的传统用户喜欢直接部署在主机上的也很方便。相对来说，这种简单易用的服务端的部署和使用docker也差距不大，docker不一定会方便到哪去，说不定还会更加难用。</p><p>我们只需要简单的四步就可以部署完成。</p><ul><li>1、Download precompiled binaries from the <a href="https://github.com/Finb/bark-server/releases">releases</a> page</li><li>2、Add executable permissions to the bark-server binary: <code>chmod +x bark-server</code></li><li>3、Start bark-server: <code>./bark-server -l 0.0.0.0 -p 8080 -d ./bark-data</code></li><li>4、Test the server: <code>curl localhost:8080/ping</code></li></ul><p>对于第三步来说，<code>-l</code>定义是监听的地址，<code>-p</code>为监听的端口，<code>./bark-data</code>默认使用<code>/data</code>目录，可以不定义。</p><p>当我们使用测试时，返回这样的结果<code>&#123;&quot;code&quot;:200,&quot;data&quot;:&#123;&quot;version&quot;:&quot;1.0.0&quot;&#125;,&quot;message&quot;:&quot;pong&quot;&#125;</code>就意味着我们的服务端已经运行成功了。</p><p>此时，我们可以在客户端软件中添加我们的服务器地址<code>http://server-ip:8080</code>即可，正常通信后，软件界面上的服务器地址就会全部都变成我们自己刚刚搭建的服务器。</p><p>这个时候应该就已经能够正常的使用了。但是既然自己搭建服务端时为了推送一些较为隐私的消息。那么只使用http就显得有点白忙活了。</p><h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><p>目前还不太清楚作者有没有直接在服务端添加证书的操作，从目前的文档来看，https需要我们使用其他的思路了。</p><p>我目前实现的方法是，既然bark也是基于http接口的，那么我就可以将其只监听<code>127.0.0.1</code>，然后使用我的前端apache给它做反代。毕竟apache部署个证书是非常简单的操作。</p><p>这样可以达到apache和bark的交互只在机器内部工作，而对外开放的apache使用证书添加上https。达到传输加密的效果。</p><p>这样是可以实现了完全加密推送消息到我的设备上了，至于水果那段不太清楚，应该也是加密的吧。</p><p>我这里使用的是免费的Let’sEncrypt的证书，他家的不但免费，还有及其方便的脚本直接给apache或其他web服务端配置好证书以及配置文件。并且证书都是保存在相应的目录的，有其他需求时，可以随时使用。</p><p>唯一一个缺点就是一次的证书只有3个月时长，需要不停的续期，好在官方也有自动续期的脚本。不是特别的麻烦。</p><pre><code class="hljs bash">~ <span class="hljs-comment"># ls /etc/letsencrypt/live/api2.defectink.com                                           </span>cert.pem  chain.pem  fullchain.pem  privkey.pem  README</code></pre><h3 id="反代"><a href="#反代" class="headerlink" title="反代"></a>反代</h3><p>apache已经有了证书了，接下来直接反代到我们的bark服务端就ok了。</p><p>这是我的配置文件：</p><pre><code class="hljs bash">VirtualHost *:80 ProtocolsHonorOrder On Protocols h2 h2c http/1.1        Servername api2.defectink.com        ServerAdmin webmaster@localhost        ProxyRequests Off        ProxyMaxForwards 100        ProxyPreserveHost On        ProxyPass / http://127.0.0.1:8181/        ProxyPassReverse / http://127.0.0.1:8181/        Proxy *            Order Deny,Allow            Allow from all        /ProxyRewriteEngine onRewriteCond %&#123;SERVER_NAME&#125; =api2.defectink.comRewriteRule ^ https://%&#123;SERVER_NAME&#125;%&#123;REQUEST_URI&#125; [END,NE,R=permanent]/VirtualHost</code></pre><p>只需要注意反代的地址就ok了，也就是我们bark监听的地址。</p><p>如果一切都没啥问题的话，我们直接打开刚刚配置好证书的apache站点，bark应该就是能够正常运行了。</p><p><img src="../images/%E6%B0%B4%E6%9E%9C%E8%87%AA%E5%AE%9A%E4%B9%89%E9%80%9A%E7%9F%A5%E5%A4%A7%E6%B3%95/1561706128389.webp" alt="1561706128389"></p><h2 id="Systemd"><a href="#Systemd" class="headerlink" title="Systemd"></a>Systemd</h2><p>前不久才水过一篇systemd的水文，简单试了几个服务，发现还是非常方便的。尤其是像bark这样的占用一个终端，用screen又不太方便找的程序。给他使用systemd来控制更是非常的方便。</p><p>把配置文件直接放到<code>/etc/systemd/system/</code>目录下就可以了。只需要修改一下<code>ExecStart</code>字段的启动路劲就可以正常使用了。</p><pre><code class="hljs routeros">[Unit]<span class="hljs-attribute">Description</span>=bark<span class="hljs-built_in"> note </span><span class="hljs-keyword">for</span> ip<span class="hljs-attribute">Documentation</span>=https://www.defectink.com<span class="hljs-attribute">After</span>=network.target[Service]<span class="hljs-attribute">Type</span>=simple<span class="hljs-attribute">PIDFile</span>=/run/bark.pid<span class="hljs-attribute">ExecStart</span>=/data/bark-server_linux_amd64 -l 127.0.0.1 -p 8181<span class="hljs-attribute">ExecReload</span>=/bin/kill -s HUP <span class="hljs-variable">$MAINPID</span><span class="hljs-attribute">ExecStop</span>=/bin/kill -s QUIT <span class="hljs-variable">$MAINPID</span><span class="hljs-attribute">PrivateTmp</span>=<span class="hljs-literal">true</span>[Install]<span class="hljs-attribute">WantedBy</span>=multi-user.target</code></pre><p>具体的效果就和平时使用其他的systemd控制的软件一样了，并且不用再那么麻烦了。</p><p><img src="../images/%E6%B0%B4%E6%9E%9C%E8%87%AA%E5%AE%9A%E4%B9%89%E9%80%9A%E7%9F%A5%E5%A4%A7%E6%B3%95/1561706516651.webp" alt="1561706516651"></p>]]></content>
    
    
    <categories>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AliOssForTypecho</title>
    <link href="/defect/alioss-for-typecho.html"/>
    <url>/defect/alioss-for-typecho.html</url>
    
    <content type="html"><![CDATA[<p>原作大佬：</p><ul><li><a href="https://zhoujie.ink/AliOssForTypecho.html">Typecho插件</a></li></ul><p>最近从辣鸡七牛换到了阿里云的oss，对于我们使用阿里云的ECS来说，oss支持直接内网访问还是很友好的。</p><p>存储换了之后，于是找到了大佬的这款插件。可是大佬当初写插件的时候有些地方不太符合个人的使用习惯。比如存储的目录下都会给每张图片单独生成要一个文件夹。</p><p>虽然看到大佬blog下已经有留言了，但是那都是去年的事了。</p><p>当时是因为阿里云还没有检测object是否存在的sdk，大佬估计也是没有时间来跟这阿里云的sdk持续更新。就在18年10月份阿里云才更新了判断文件是否存在的php sdk。</p><p>对于我这种0基础没入门的php玩家，修改太多也太麻烦，也不会。于是只做了一些简单的修改</p><ul><li>去除每个图片随机创建一个文件夹，但是没有是否存在的检测，上传时要确保文件不会重名。</li><li>添加图片处理样式，支持自定义规则。</li><li>更新了最新的OssClient（虽然我不知道它怎么用</li></ul><p>为什么不做object存在检测？</p><ul><li>当前文件夹是按“年-月-日”来分层的，也就是说存在重名的文件的时间段只有一天内上传的文件才有机会重名。</li><li>不会</li><li>主要是不会</li></ul><p>阿里云的<a href="https://help.aliyun.com/document_detail/88501.html?spm=a2c4g.11186623.6.938.33f015cdQHplrY">判断文件是否存在</a>文档，有兴趣的大佬可以试试。</p><p>下载地址：</p><ul><li><a href="https://github.com/DefectingCat/AliOssForTypecho-">AliossForTypecho</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>typecho</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gitlab尝鲜</title>
    <link href="/defect/try-the-gitlab.html"/>
    <url>/defect/try-the-gitlab.html</url>
    
    <content type="html"><![CDATA[<h2 id="Gitlab"><a href="#Gitlab" class="headerlink" title="Gitlab?"></a>Gitlab?</h2><p><strong>GitLab</strong>是由GitLab Inc.开发，使用<a href="https://zh.wikipedia.org/wiki/MIT%E8%A8%B1%E5%8F%AF%E8%AD%89">MIT许可证</a>的基于<a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91">网络</a>的<a href="https://zh.wikipedia.org/wiki/Git">Git</a><a href="https://zh.wikipedia.org/wiki/%E4%BB%93%E5%BA%93_(%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6)">仓库</a>管理工具，且具有<a href="https://zh.wikipedia.org/wiki/Wiki">wiki</a>和<a href="https://zh.wikipedia.org/wiki/%E4%BA%8B%E5%8A%A1%E8%B7%9F%E8%B8%AA%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F">issue跟踪</a>功能。</p><p>它是一款和常见的Github很像仓库管理工具，大体使用上和Github很像。前端页面也很好看，主要的是安装非常的方便，它集成了自身需要的nginx的服务端。</p><p>起初是由Ruby写成，后来部分由Go语言重写。</p><p>最早，它是完全免费的开源软件，按照 MIT 许可证分发。毕竟人家是公司，后来Gitlab被拆分成GitLab CE（社区版）和 GitLab EE（企业版）。和如今的模式一样，ce是完全免费使用的社区版，而ee是可以进行试用且更多功能的收费版。</p><p><img src="../images/Gitlab%E5%B0%9D%E9%B2%9C/52152339.webp" alt="52152339"></p><h2 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h2><p><a href="https://about.gitlab.com/install/">官方</a>拥有详细的安装操作文档，并且对于不同的Linux发行版也有着不同的软件仓库源。除此之外，我们还可以选择其他的安装方式，如Docker等。</p><p>我当前是部署在Ubuntu上的，系统信息：</p><p><img src="../images/Gitlab%E5%B0%9D%E9%B2%9C/411390967.webp" alt="411390967"></p><pre><code>官方是推荐系统空闲内存在4GB以上的，对于类似我们这样的个人使用的较少的来说，推荐空闲内存是2GB以上。毕竟它会自己运行一套nginx、redis等服务端。</code></pre><p>自家的开源地址：<a href="https://gitlab.com/gitlab-org/gitlab-ce/">Gitlab</a></p><p>相对于从源码安装来说，自家提供的相应的软件包更加的方便，也更不会容易出错。我们只需要选择相应的操作系统即可。</p><p>这里仅以Ubunt示例：</p><p>首先安装需要的相关依赖：</p><pre><code class="hljs pgsql">sudo apt-<span class="hljs-keyword">get</span> <span class="hljs-keyword">update</span>sudo apt-<span class="hljs-keyword">get</span> install -y curl openssh-<span class="hljs-keyword">server</span> ca-certificates</code></pre><p>如果我们不使用外部的SMTP来发邮件的话，Gitlab可以使用postfix来进行发邮件。当然对我们完全不需要发邮件的这个需求的话，这步完全可以跳过。</p><pre><code class="hljs maxima">sudo apt-<span class="hljs-built_in">get</span> install -y <span class="hljs-built_in">postfix</span></code></pre><p>基本依赖安装完后，随后可以添加Gitlab的源来进行安装软件了：</p><pre><code class="hljs awk">curl https:<span class="hljs-regexp">//</span>packages.gitlab.com<span class="hljs-regexp">/install/</span>repositories<span class="hljs-regexp">/gitlab/gi</span>tlab-ce/script.deb.sh | sudo bashcurl https:<span class="hljs-regexp">//</span>packages.gitlab.com<span class="hljs-regexp">/install/</span>repositories<span class="hljs-regexp">/gitlab/gi</span>tlab-ee/script.deb.sh | sudo bash</code></pre><p><em>注意ce和ee的区别</em></p><p>接下来，我们就可以使用<code>apt</code>来进行安装GItlab-ce了。修改下方命令的<code>https://gitlab.example.com</code>为自己Gitlab运行的域名。安装程序将自动配置该网址启动Gitlab</p><p>对于需要启用<code>https</code>的小伙伴们，Gitlab可以自动请求[<a href="https://docs.gitlab.com/omnibus/settings/ssl.html#lets-encrypthttpsletsencryptorg-integration">Let’s Encrypt</a>]的证书，方便我们一步到位。当然我们也可以使用自己的证书。</p><pre><code class="hljs routeros">sudo <span class="hljs-attribute">EXTERNAL_URL</span>=<span class="hljs-string">&quot;https://gitlab.example.com&quot;</span> apt-<span class="hljs-builtin-name">get</span> install gitlab-ce</code></pre><p>到这里就安装的差不多了，此时我们可以打开自己的Gitlab。第一次访问时会被重定向到设定<code>root</code>密码的界面。设置完成后我们的Gitlab就安装完成了。初始管理员的账户就是<code>root</code></p><p>由官方给我们提供的安装方式是不是相对来说非常的简单呢?</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><img src="../images/Gitlab%E5%B0%9D%E9%B2%9C/99634888.webp" alt="99634888"></p><p>简洁多彩的界面也时非常的好看的。默认没有配置邮件的情况下是可以随意注册的，我们也可以在后台配置里关闭自动注册，作为一个私人的git仓库。也可以手动添加用户给想尝鲜的小伙伴们。</p><p>当然，Gitlab只是一个仓库源的管理工具，提供了类似与Github的功能。对于我们终端使用git来说，还是和Github一模一样。并且我们可以将其部署在国内的主机上，来提升某些情况到Github速度奇慢无比的问题。</p><h2 id="启动与管理"><a href="#启动与管理" class="headerlink" title="启动与管理"></a>启动与管理</h2><pre><code class="hljs powershell"><span class="hljs-variable">$</span> sudo gitlab<span class="hljs-literal">-ctl</span> reconfigure<span class="hljs-variable">$</span> sudo gitlab<span class="hljs-literal">-ctl</span> status<span class="hljs-variable">$</span> sudo gitlab<span class="hljs-literal">-ctl</span> stop<span class="hljs-variable">$</span> sudo gitlab<span class="hljs-literal">-ctl</span> restart<span class="hljs-variable">$</span> sudo <span class="hljs-built_in">ps</span> aux | grep runsvdir</code></pre>]]></content>
    
    
    <categories>
      
      <category>实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>systemd的基础操作</title>
    <link href="/defect/basic-knowledge-of-systemd.html"/>
    <url>/defect/basic-knowledge-of-systemd.html</url>
    
    <content type="html"><![CDATA[<h2 id="什么是systemd？"><a href="#什么是systemd？" class="headerlink" title="什么是systemd？"></a>什么是systemd？</h2><p>Systemd是我们常用的一些Linux发行版中常见的一套中央化系统及设置管理程序(init)，包括有<a href="https://zh.wikipedia.org/wiki/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B">守护进程</a>、<a href="https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BC%8F%E5%BA%AB">程序库</a>以及应用软件。</p><p>我们经常使用<code>systemctl start apache2</code>来启动一些服务或者应用软件时，使用到的就是Systemd的一部分。</p><p>当前绝大多数的Linux发行版都已采用systemd代替原来的<a href="https://zh.wikipedia.org/wiki/UNIX_System_V">System V</a>。</p><h2 id="学习它的作用？"><a href="#学习它的作用？" class="headerlink" title="学习它的作用？"></a>学习它的作用？</h2><p>它能够方便的对一些软件运行进行管理，经常使用<code>systemctl</code>的同学们可能会比较了解，譬如查看运行状态，设置开机自启等操作。</p><p>最近尝鲜了Ubuntu，但是遇到个新的问题。在Ubuntu 18.10中，已经将以前的开机自启动的脚本<code>/etc/rc.local</code>去掉了。无意中看到使用systemd来控制开机自启应用程序。</p><p>后来就顺便尝试进一步了解一下systemd，毕竟还是比较有用的。</p><h2 id="开机运行启动的原理"><a href="#开机运行启动的原理" class="headerlink" title="开机运行启动的原理"></a>开机运行启动的原理</h2><p>一些支持systemd的软件，在安装时会在<code>/usr/lib/systemd/system</code>目录下添加一个支持systemd的配置文件。当我们使用<code>systemctl enable apache2</code>时，就相当于将<code>/usr/lib/systemd/system</code>目录下的配置文件添加一个符号链接，链接到<code>/etc/systemd/system</code>目录。</p><p>当我们的系统开机时，systemd会执行<code>/etc/systemd/system</code>目录下的配置文件，以达到开机自启的效果。</p><p>最近发现当前较新的发行版，使用enable命令时，创建的链接目录为：</p><pre><code class="hljs crystal">~ systemctl enable httpd             Created symlink from /etc/systemd/system/multi-user.target.wants/httpd.service to /usr/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">systemd</span>/<span class="hljs-title">system</span>/<span class="hljs-title">httpd</span>.<span class="hljs-title">service</span>.</span></code></pre><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>几条常用且熟悉的sysemctl的命令这里就不在详细介绍了。这里直接了解一下最核心的部分，配置文件。</p><p>早在很久以前，对于<a href="https://www.defectink.com/defect/12.html">Nyncat</a>这篇文章，里面就使用到自己编写systemd的配置文件来达到对nyancat这个服务的详细控制。（虽然当时我不理解配置文件说的啥…</p><p>上述了解到，配置文件一般情况下出现在两个地方：<code>/usr/lib/systemd/system</code>目录和<code>/etc/systemd/system/multi-user.target.wants</code>目录。对于完全不了解配置文件的情况下，我们可以先在这两个目录找个案例了解一下。</p><p><strong>某些Ubuntu的发行版可能在<code>/lib/systemd/system</code>目录下保存配置文件</strong></p><p>例如，CentOS的httpd：</p><pre><code class="hljs routeros">[Unit]<span class="hljs-attribute">Description</span>=The Apache HTTP Server<span class="hljs-attribute">After</span>=network.target remote-fs.target nss-lookup.target<span class="hljs-attribute">Documentation</span>=man:httpd(8)<span class="hljs-attribute">Documentation</span>=man:apachectl(8)[Service]<span class="hljs-attribute">Type</span>=notify<span class="hljs-attribute">EnvironmentFile</span>=/etc/sysconfig/httpd<span class="hljs-attribute">ExecStart</span>=/usr/sbin/httpd <span class="hljs-variable">$OPTIONS</span> -DFOREGROUND<span class="hljs-attribute">ExecReload</span>=/usr/sbin/httpd <span class="hljs-variable">$OPTIONS</span> -k graceful<span class="hljs-attribute">ExecStop</span>=/bin/kill -WINCH <span class="hljs-variable">$&#123;MAINPID&#125;</span><span class="hljs-comment"># We want systemd to give httpd some time to finish gracefully, but still want</span><span class="hljs-comment"># it to kill httpd after TimeoutStopSec if something went wrong during the</span><span class="hljs-comment"># graceful stop. Normally, Systemd sends SIGTERM signal right after the</span><span class="hljs-comment"># ExecStop, which would kill httpd. We are sending useless SIGCONT here to give</span><span class="hljs-comment"># httpd time to finish.</span><span class="hljs-attribute">KillSignal</span>=SIGCONT<span class="hljs-attribute">PrivateTmp</span>=<span class="hljs-literal">true</span>[Install]<span class="hljs-attribute">WantedBy</span>=multi-user.target</code></pre><p>我们可以了解到，它基本上分为三个区块：<code>Unit</code>、<code>Service</code>和<code>Install</code>区块。</p><h3 id="Unit区域"><a href="#Unit区域" class="headerlink" title="Unit区域"></a>Unit区域</h3><p>Unit区域用于解释启动顺序与依赖关系。可以直观的看到它有几个字段：</p><ul><li>Description</li><li>After</li><li>Documentation</li></ul><p>第一眼看上去可能都是比较乱七八糟的，根本不知道它在说啥。但是我们拆开来一个一个了解，就会发现它意义非常的简单。</p><p><strong>Description</strong>：用于给出当前服务的简单描述。通常我们查看服务状态时，都会在第一行看到这么一句话：</p><pre><code class="hljs arduino">httpd.service - The Apache HTTP <span class="hljs-built_in">Server</span></code></pre><p>这就是<code>Descipton</code>字段的作用，一句话对当前服务的简单介绍。</p><p><strong>After</strong>：该字段是有关于启动顺序的字段，从字面意思我们就应该大概了解到，这个值应该是定义当前服务应该启动在哪些服务之后。</p><p>上述配置文件该值解释就是：当<code>network.target remote-fs.target nss-lookup.target</code>这些服务需要启动，那么当前的<code>httpd.service</code>应该在他们之后启动。</p><p>相对的，和<code>After</code>对应的还有个<code>Before</code>字段。了解了<code>After</code>这个<code>Before</code>就应该很容易理解了。完全和<code>After</code>相对的意思，定义<code>httpd.service</code>应该在哪些服务之前启动。</p><p>After和Before只关乎到服务的启动顺序，并不关乎到依赖关系。</p><p><strong>Documentation</strong>：该字段比较简单，和<code>Descripton</code>作用差不多。它的值用于给出当前服务的文档的位置。</p><p>当前配置文件中并没有说明依赖关系的字段。依赖关系和启动顺序都是写在当前这个Unit区域的，它俩非常像象，但是作用不同。</p><p>依赖关系有两个字段进行控制：<code>Wants</code>和<code>Requiers</code>。</p><p><strong>Wants</strong>：表示弱依赖关系，即使该值内的服务启动失败，也不影响当前服务的继续运行。</p><p><strong>Requires</strong>：表示强依赖关系，如果该值内的服务无法运行，那么当前服务也将停止。</p><p>打个比方：</p><p>当前的httpd.service需要依赖mysql来存储数据。如果在配置文件中它只定义了在mysql之后启动。而没定义依赖关系，那么当mysql出现错误停止时，在重新启动期间，当前的httpd将无法与mysql建立链接。</p><p><strong>这里只是打个比方帮助我们更好的了解，实际情况下httpd在通常和mysql是没有这样的依赖关系的🍥。</strong></p><h3 id="Service区域"><a href="#Service区域" class="headerlink" title="Service区域"></a>Service区域</h3><p>Service区域是主要的一部分，主要控制软件的启动停止等，都是在此部分声明的。也就是定义了如何启动当前的服务。</p><p>许多软件都有环境参数文件，使用<code>EnvironmentFile</code>字段便可以定义环境参数。</p><p><code>EnvironmentFile</code>字段：指定当前服务的环境参数文件。该文件内部的<code>key=value</code>键值对，可以用<code>$key</code>的形式，在当前配置文件中获取。</p><p>例如，启动<code>sshd</code>，执行的命令是<code>/usr/sbin/sshd -D $OPTIONS</code>，其中的变量<code>$OPTIONS</code>就来自<code>EnvironmentFile</code>字段指定的环境参数文件。</p><p>除此之外，Service区域还有一些关于控制软件行为的一些字段：</p><ul><li><code>ExecStart</code>字段：定义启动进程时执行的命令。</li></ul><ul><li><code>ExecReload</code>字段：重启服务时执行的命令</li><li><code>ExecStop</code>字段：停止服务时执行的命令</li><li><code>ExecStartPre</code>字段：启动服务之前执行的命令</li><li><code>ExecStartPost</code>字段：启动服务之后执行的命令</li><li><code>ExecStopPost</code>字段：停止服务之后执行的命令</li></ul><p>所有的启动设置之前，都可以加上一个连词号（<code>-</code>），表示”抑制错误”，即发生错误的时候，不影响其他命令的执行。比如，<code>EnvironmentFile=-/etc/sysconfig/sshd</code>（注意等号后面的那个连词号），就表示即使<code>/etc/sysconfig/sshd</code>文件不存在，也不会抛出错误。</p><p>此外，Service中还有几个比较重要的字段</p><p><strong>Type</strong>字段，它有如下一些值：</p><ul><li>simple（默认值）：<code>ExecStart</code>字段启动的进程为主进程</li><li>forking：<code>ExecStart</code>字段将以<code>fork()</code>方式启动，此时父进程将会退出，子进程将成为主进程</li><li>oneshot：类似于<code>simple</code>，但只执行一次，Systemd 会等它执行完，才启动其他服务</li><li>dbus：类似于<code>simple</code>，但会等待 D-Bus 信号后启动</li><li>notify：类似于<code>simple</code>，启动结束后会发出通知信号，然后 Systemd 再启动其他服务</li><li>idle：类似于<code>simple</code>，但是要等到其他任务都执行完，才会启动该服务。一种使用场合是为让该服务的输出，不与其他服务的输出相混合</li></ul><h3 id="Install区域"><a href="#Install区域" class="headerlink" title="Install区域"></a>Install区域</h3><p><code>Install</code>区块，定义如何安装这个配置文件，即怎样做到开机启动。</p><p><code>WantedBy</code>字段：表示该服务所在的 Target。</p><p><code>Target</code>的含义是服务组，表示一组服务。<code>WantedBy=multi-user.target</code>指的是，sshd 所在的 Target 是<code>multi-user.target</code>。</p><p>这个设置非常重要，因为执行<code>systemctl enable sshd.service</code>命令时，<code>sshd.service</code>的一个符号链接，就会放在<code>/etc/systemd/system</code>目录下面的<code>multi-user.target.wants</code>子目录之中。</p><p>Systemd 有默认的启动 Target。</p> <pre><code class="hljs bash">$ systemctl get-defaultmulti-user.target</code></pre><p>一般来说，常用的 Target 有两个：一个是<code>multi-user.target</code>，表示多用户命令行状态；另一个是<code>graphical.target</code>，表示图形用户状态，它依赖于<code>multi-user.target</code>。官方文档有一张非常清晰的 [Target 依赖关系图](<a href="https://www.freedesktop.org/software/systemd/man/bootup.html#System">https://www.freedesktop.org/software/systemd/man/bootup.html#System</a> Manager Bootup)。</p><p>Target 也有自己的配置文件。</p><pre><code class="hljs bash">$ systemctl cat multi-user.target[Unit]Description=Multi-User SystemDocumentation=man:systemd.special(7)Requires=basic.targetConflicts=rescue.service rescue.targetAfter=basic.target rescue.service rescue.targetAllowIsolate=yes</code></pre><h2 id="详细的字段解释"><a href="#详细的字段解释" class="headerlink" title="详细的字段解释"></a>详细的字段解释</h2><pre><code class="hljs mathematica">[Unit]Description : 服务的简单描述Documentation ： 服务文档<span class="hljs-keyword">Before</span>、<span class="hljs-keyword">After</span>:定义启动顺序。<span class="hljs-keyword">Before</span>=xxx.service,代表本服务在xxx.service启动之前启动。<span class="hljs-keyword">After</span>=xxx.service,代表本服务在xxx.service之后启动。Requires：这个单元启动了，它需要的单元也会被启动；它需要的单元被停止了，这个单元也停止了。Wants：推荐使用。这个单元启动了，它需要的单元也会被启动；它需要的单元被停止了，对本单元没有影响。</code></pre><pre><code class="hljs routeros">[Service]<span class="hljs-attribute">Type</span>=simple（默认值）：systemd认为该服务将立即启动。服务进程不会fork。如果该服务要启动其他服务，不要使用此类型启动，除非该服务是socket激活型。<span class="hljs-attribute">Type</span>=forking：systemd认为当该服务进程fork，且父进程退出后服务启动成功。对于常规的守护进程（daemon），除非你确定此启动方式无法满足需求，使用此类型启动即可。使用此启动类型应同时指定 <span class="hljs-attribute">PIDFile</span>=，以便systemd能够跟踪服务的主进程。<span class="hljs-attribute">Type</span>=oneshot：这一选项适用于只执行一项任务、随后立即退出的服务。可能需要同时设置 <span class="hljs-attribute">RemainAfterExit</span>=<span class="hljs-literal">yes</span> 使得 systemd 在服务进程退出之后仍然认为服务处于激活状态。<span class="hljs-attribute">Type</span>=notify：与 <span class="hljs-attribute">Type</span>=simple 相同，但约定服务会在就绪后向 systemd 发送一个信号。这一通知的实现由 libsystemd-daemon.so 提供。<span class="hljs-attribute">Type</span>=dbus：若以此方式启动，当指定的 BusName 出现在DBus系统总线上时，systemd认为服务就绪。<span class="hljs-attribute">Type</span>=idle: systemd会等待所有任务(Jobs)处理完成后，才开始执行idle类型的单元。除此之外，其他行为和<span class="hljs-attribute">Type</span>=simple 类似。PIDFile：pid文件路径ExecStartPre：停止服务时执行的命令ExecStart：指定启动单元的命令或者脚本，ExecStartPre和ExecStartPost节指定在ExecStart之前或者之后用户自定义执行的脚本。<span class="hljs-attribute">Type</span>=oneshot允许指定多个希望顺序执行的用户自定义命令。ExecReload：指定单元停止时执行的命令或者脚本。ExecStop：指定单元停止时执行的命令或者脚本。ExecStopPost：停止服务之后执行的命令ExecStartPost：启动服务之后执行的命令PrivateTmp：<span class="hljs-literal">True</span>表示给服务分配独立的临时空间Restart：这个选项如果被允许，服务重启的时候进程会退出，会通过systemctl命令执行清除并重启的操作。RemainAfterExit：如果设置这个选择为真，服务会被认为是在激活状态，即使所以的进程已经退出，默认的值为假，这个选项只有在<span class="hljs-attribute">Type</span>=oneshot时需要被配置。</code></pre><pre><code class="hljs pgsql">[Install]<span class="hljs-keyword">Alias</span>：为单元提供一个空间分离的附加名字。RequiredBy：单元被允许运行需要的一系列依赖单元，RequiredBy列表从Require获得依赖信息。WantBy：单元被允许运行需要的弱依赖性单元，Wantby从Want列表获得依赖信息。<span class="hljs-keyword">Also</span>：指出和单元一起安装或者被协助的单元。DefaultInstance：实例单元的限制，这个选项指定如果单元被允许运行默认的实例。</code></pre><h2 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h2><pre><code class="hljs bash"><span class="hljs-comment"># 重新加载配置文件</span>$ sudo systemctl daemon-reload<span class="hljs-comment"># 重启相关服务</span>$ sudo systemctl restart foobar</code></pre>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>公开密钥密码学🔑</title>
    <link href="/defect/public-key-cryptgraphy.html"/>
    <url>/defect/public-key-cryptgraphy.html</url>
    
    <content type="html"><![CDATA[<p>GPG/PGP赛高！</p><h2 id="什么是非对称加密？"><a href="#什么是非对称加密？" class="headerlink" title="什么是非对称加密？"></a>什么是非对称加密？</h2><p>人类的历史上加密走了很长的一段路程。想尽了各种办法来保护自己那不想让不该知道的人知道的东西。 加密这东西，在密码学中最直白的解释就是将一般的明文信息改变为难以读取的内容，使其不可读的过程只有拥有解密方法的对象，经由解密过程，才能将密文还原为正常可读的内容。 </p><p>大概在1970年代中期，所谓的“强加密”的使用开始从政府保密机构延申至公共的领域了，也就是说开始到我们大众都开始接触了。当今世界，加密已经是我们的日常生活中常常见到的东西了。 </p><p>例如我们常常访问的带有SSL/TLS的网站，这也是非对称加密的一种。 所谓的对称加密，它也是密码学中的一种。但他与对称加密不同的是，它需要两个密钥，一个是公开密钥，另一个是私有密钥；一个用作加密，另一个则用作解密。使用其中一个密钥把明文加密后所得的密文，只能用相对应的另一个密钥才能解密得到原本的明文；甚至连最初用来加密的密钥也不能用作解密。</p><p> 由于加密和解密需要两个不同的密钥，故被称为非对称加密； 不同于加密和解密都使用同一个密钥的对称加密。虽然两个密钥在数学上相关，但如果知道了其中一个，并不能凭此计算出另外一个；因此其中一个可以公开，称为公钥，任意向外发布；不公开的密钥为私钥，必须由用户自行严格秘密保管，绝不透过任何途径向任何人提供，也不会透露给被信任的要通信的另一方。</p><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>如果任何人使用公钥加密明文，得到的密文可以透过不安全的途径（如网络）发送，只有对应的私钥持有者才可以解密得到明文；其他人即使从网络上窃取到密文及加密公钥，也无法（在数以年计的合理时间内）解密得出明文。 </p><p>典型例子是在网络银行或购物网站上，因为客户需要输入敏感消息，浏览器连接时使用网站服务器提供的公钥加密并上传数据，可保证只有信任的网站服务器才能解密得知消息，不必担心敏感个人信息因为在网络上传送而被窃取。 </p><p>在现实世界上可作比拟的例子是，一个传统保管箱，开门和关门都是使用同一条钥匙，这是对称加密；而一个公开的邮箱，投递口是任何人都可以寄信进去的，这可视为公钥；而只有信箱主人拥有钥匙可以打开信箱，这就视为私钥。 </p><p>常见的公钥加密算法有：RSA、ElGamal、背包算法、Rabin（RSA的特例）、迪菲－赫尔曼密钥交换协议中的公钥加密算法、椭圆曲线加密算法（英语：Elliptic Curve Cryptography, ECC）。使用最广泛的是RSA算法（由发明者Rivest、Shmir和Adleman姓氏首字母缩写而来）是著名的公开秘钥加密算法，ElGamal是另一种常用的非对称加密算法。</p><h4 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h4><p>直白的解释： Tom 和 Jerry想发送一些消息/文件，而不被隔壁的Spike知道文件的内容。于是它们机智的采用了非对称加密来保证内容的安全性。</p><ol><li>Tom先生产非对称的两个密钥，分别为公钥A，私钥B</li><li>为了能让Jerry发过来的消息被加密了，Tom先将可公开的公钥A发给Jerry</li><li>因为公钥A是完全可公开的，所以Spike知道也没关系</li><li>Jerry收到Tom发的公钥A，并将自己的文件X使用公钥A进行加密</li><li>随后Jerry就可以将加密的文件A(X)正大光明的发送给Tom了</li><li>此时的Spike就算截取到加密过的文件A(X)也没有用</li><li>因为Tom收到的加密文件A(X)只有它自己的私钥B能够解密，于是它收到后可以使用私钥B正常解密</li><li>所以如果Tom丢失了它的私钥B，那么Tom and Jerry都无法读取加密的文件A(X)了</li><li>（没有私钥就无法解开公钥加密过的信息）</li><li>相反，Jerry也可以将自己的公钥发给Tom，使其加密要发给自己的信息。</li></ol><h4 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h4><p>如果某一用户使用他的私钥加密明文，任何人都可以用该用户的公钥解密密文；由于私钥只由该用户自己持有，故可以肯定该文件必定出自于该用户。 </p><p>公众可以验证该用户发布的数据或文件是否完整、中途有否曾被篡改，接收者可信赖这条信息确实来自于该用户，该用户亦无法抵赖，这被称作数字签名。 所以我们常常见到提示一定要保护好自己的私钥，因为不仅仅会使得加密失效，还会直接影响签名验证。</p><h2 id="非对称加密的软件"><a href="#非对称加密的软件" class="headerlink" title="非对称加密的软件"></a>非对称加密的软件</h2><p>对于软件来说，我们可能经常听说到GPG这一词。GPG的全称是GNU Privacy Guard（GnuPG或GPG）。它是一款非对称加密的软件，是PGP加密软件的满足GPL的替代物。 也就是说它相对于PGP加密来说，它是一款开源软件。</p><p>因为PGP的非对称的算法是开源的，所以GPG和PGP原理是完全一样的。通常我们会见到GPG/PGP。 所以PGP就可以简单了解到它是一款非开源的非对称加密软件了。 PGP（英语：Pretty Good Privacy，中文翻译“优良保密协议”）是一套用于讯息加密、验证的应用程序，采用IDEA的散列算法作为加密和验证之用。</p><h3 id="多平台的安装与使用"><a href="#多平台的安装与使用" class="headerlink" title="多平台的安装与使用"></a>多平台的安装与使用</h3><p>既然上述已经介绍了它是自由软件，那么它跨平台的几率就很大了，支持的平台也非常的多。在官方网站里，我们可以看到它支持很多平台。</p><p><img src="../images/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%AF%86%E7%A0%81%E5%AD%A6/GPG%E5%A4%9A%E5%B9%B3%E5%8F%B0.webp" alt="GPG多平台"></p><h4 id="Windows-GPG4win"><a href="#Windows-GPG4win" class="headerlink" title="Windows GPG4win"></a>Windows GPG4win</h4><p>安装就不再多说，GPG4win的官网有打包好的exe可执行程序，我们直接下载双击安装就好，安装过程也非常的简单，不需要进行任何配置。也就是常说的“无脑next☀”。 </p><p><a href="https://www.gpg4win.org/get-gpg4win.html">Download</a></p><p> GPG4win是GPG在Windows平台的一款可视化的非对称加密软件。对于可视化的软件来说，使用也非常的简单明了。 几乎常用的一些功能都非常直白的写在了刚开打的页面中。基本上只要使用者了解大概的非对称加密的运作原理，就可以很轻松的使用该软件了。</p><p><img src="../images/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%AF%86%E7%A0%81%E5%AD%A6/Kleopatra.webp" alt="Kleopatra"></p><p><img src="../images/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%AF%86%E7%A0%81%E5%AD%A6/%E5%AF%86%E9%92%A5.webp" alt="密钥"></p><h4 id="Ubuntu-amp-CentOS"><a href="#Ubuntu-amp-CentOS" class="headerlink" title="Ubuntu &amp; CentOS"></a>Ubuntu &amp; CentOS</h4><p>目前最新的Ubuntu与CentOS的发行版中都带有GnuPrivacyGuard。也就是GPG的一种，所以使用的方法也是大同小异了。 以Ubuntu为例： * 创建密钥</p><pre><code class="hljs ada">gpg <span class="hljs-comment">--gen-key</span></code></pre><p>不知道为啥我的机器在生成密钥的时候会卡住很长时间，导致我没有生成出来。等以后再考虑填这个坑吧。</p><ul><li>查看秘钥</li></ul><pre><code class="hljs lsl">查看公钥：gpg --<span class="hljs-type">list</span>-<span class="hljs-type">key</span>查看私钥：gpg --<span class="hljs-type">list</span>-secret-keys</code></pre><ul><li>提取秘钥</li></ul><pre><code class="hljs haxe">提取公钥：gpg -a --export <span class="hljs-keyword">new</span><span class="hljs-type">key</span> &gt; <span class="hljs-keyword">new</span><span class="hljs-type">key</span>.asc提取私钥：gpg -a --export-secret-keys <span class="hljs-keyword">new</span><span class="hljs-type">key</span> &gt; <span class="hljs-keyword">new</span><span class="hljs-type">key_pirv</span>.asc</code></pre><ul><li>导入秘钥</li></ul><pre><code class="hljs haxe">导入公钥或私钥：gpg --<span class="hljs-keyword">import</span> <span class="hljs-keyword">new</span><span class="hljs-type">key</span></code></pre><ul><li>使用公钥加密</li></ul><pre><code class="hljs haxe">gpg -ea -r <span class="hljs-keyword">new</span><span class="hljs-type">key</span> filename</code></pre><ul><li>解密并导出为文件</li></ul><pre><code class="hljs cmake">gpg -d <span class="hljs-keyword">test</span>.asc &gt; <span class="hljs-keyword">test</span></code></pre><ul><li>设置密钥信任程度</li></ul><pre><code class="hljs properties"><span class="hljs-attr">gpg</span> <span class="hljs-string">--edit-key [导入的密钥ID]</span><span class="hljs-attr">trust</span><span class="hljs-attr">您是否相信这位用户有能力验证其他用户密钥的有效性(查对身份证、通过不同的渠道检查</span><span class="hljs-attr">指纹等)？</span>  <span class="hljs-attr">1</span> = <span class="hljs-string">我不知道或我不作答</span>  <span class="hljs-attr">2</span> = <span class="hljs-string">我不相信</span>  <span class="hljs-attr">3</span> = <span class="hljs-string">我勉强相信</span>  <span class="hljs-attr">4</span> = <span class="hljs-string">我完全相信</span>  <span class="hljs-attr">5</span> = <span class="hljs-string">我绝对相信</span>  <span class="hljs-attr">m</span> = <span class="hljs-string">回到主菜单</span></code></pre><h2 id="我的公钥"><a href="#我的公钥" class="headerlink" title="我的公钥"></a>我的公钥</h2><p>如果有小伙伴想和我扮演Tom and Jerry的话，或者想校验我的签名的文件的话。欢迎使用下述公钥 </p><p><a href="https://1drv.ms/u/s!ArC4gW7Dc7wWhd5PD8R_o6Mmhp2LxA?e=Ivpa8X">我的公钥🔒！</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A">传输层安全性协议</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%B0%8D%E7%A8%B1%E5%AF%86%E9%91%B0%E5%8A%A0%E5%AF%86">对称密钥加密</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86">公开密钥加密</a></li><li><a href="https://zh.wikipedia.org/wiki/GnuPG">GnuPG</a></li><li><a href="https://zh.wikipedia.org/wiki/PGP">PGP</a></li><li><a href="https://help.ubuntu.com/community/GnuPrivacyGuardHowto">GnuPrivacyGuardHowto</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自动备份大法</title>
    <link href="/defect/auto-backup.html"/>
    <url>/defect/auto-backup.html</url>
    
    <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>最近看到几个数据爆炸的可怕事件，虽然我平时偶尔有手动备份的，但还是不怎么放心。以前有用过lsyncd自动同步到其他机器。但昨天发生了一个更可怕的事情，我重启机器后发现mysql启动不了，apt也不能update了。当时就蒙了，后来发现是我的/var目录满了。mysql与apt都需要用到/var目录，所以爆炸了。但是为什么会满呢…</p><p>因为一个lsyncd的日志写了34GB。</p><p><img src="../images/%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BD%E5%A4%A7%E6%B3%95/2874899693.webp" alt="1.webp/"></p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>放弃lsyncd。</p><p>以前因为懒，写过一个自动压缩网页根目录的脚本，配合crontab在每天的凌晨自动执行一遍非常不错。</p><p>但是最重要的不是根目录，而是数据库。最近有了解到mysqldump，表示可以crontab一下。</p><h3 id="dump为sql文件"><a href="#dump为sql文件" class="headerlink" title="dump为sql文件"></a>dump为sql文件</h3><p>导出整个数据库：</p><pre><code class="hljs nginx"><span class="hljs-attribute">mysqldump</span> -u 用户名 -p 数据库名 &gt; 导出的文件名</code></pre><p>例：</p><pre><code class="hljs css"><span class="hljs-selector-tag">mysqldump</span> <span class="hljs-selector-tag">-u</span> <span class="hljs-selector-tag">root</span> <span class="hljs-selector-tag">-p</span> <span class="hljs-selector-tag">typecho</span> &gt; <span class="hljs-selector-tag">typecho_backup</span><span class="hljs-selector-class">.sql</span></code></pre><p>导出一个表</p><pre><code class="hljs nginx"><span class="hljs-attribute">mysqldump</span> -u 用户名 -p 数据库名 表名&gt; 导出的文件名</code></pre><p>例：</p><pre><code class="hljs routeros">mysqldump -u root -p typecho<span class="hljs-built_in"> users </span>&gt; users_backup.sql</code></pre><p>导出一个数据库结构</p><pre><code class="hljs nginx"><span class="hljs-attribute">mysqldump</span> -u 用户名 -p -d 数据库名 &gt; 导出的文件名</code></pre><p>例：</p><pre><code class="hljs css"><span class="hljs-selector-tag">mysqldump</span> <span class="hljs-selector-tag">-u</span> <span class="hljs-selector-tag">root</span> <span class="hljs-selector-tag">-p</span> <span class="hljs-selector-tag">-d</span> <span class="hljs-selector-tag">typecho</span> &gt;  <span class="hljs-selector-tag">typecho</span><span class="hljs-selector-class">.sql</span></code></pre><h3 id="导入数据库"><a href="#导入数据库" class="headerlink" title="导入数据库"></a>导入数据库</h3><pre><code class="hljs css"><span class="hljs-selector-tag">mysql</span> <span class="hljs-selector-tag">-u</span> 用户名 <span class="hljs-selector-tag">-p</span> 数据库名 &lt; 数据库名<span class="hljs-selector-class">.sql</span></code></pre><p>例：</p><pre><code class="hljs css"><span class="hljs-selector-tag">mysql</span> <span class="hljs-selector-tag">-u</span> <span class="hljs-selector-tag">root</span> <span class="hljs-selector-tag">-p</span> <span class="hljs-selector-tag">typecho</span> &lt; <span class="hljs-selector-tag">typecho</span><span class="hljs-selector-class">.sql</span></code></pre><p>实际操作了一下，确实很简单方便好用。但问题是，对于我这种勤(lan)快的人肯定要脚本自动一体化啊。</p><h3 id="感觉很厉害的Script"><a href="#感觉很厉害的Script" class="headerlink" title="感觉很厉害的Script"></a>感觉很厉害的Script</h3><p>自我感觉，自我感觉。</p><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-comment">#定义数据库信息</span>USER=<span class="hljs-string">&quot;root&quot;</span>PASS=<span class="hljs-string">&quot;password&quot;</span>HOST=<span class="hljs-string">&quot;localhost&quot;</span>NAME=<span class="hljs-string">&quot;typecho&quot;</span>NAME2=<span class="hljs-string">&quot;wordpress&quot;</span><span class="hljs-comment">#其他信息</span>BAK_DIR=<span class="hljs-string">&quot;/root/backup/&quot;</span>TIME=`date +%F`<span class="hljs-comment">#操作</span>mysqldump -u<span class="hljs-variable">$USER</span> -p<span class="hljs-variable">$PASS</span> -h<span class="hljs-variable">$HOST</span> <span class="hljs-variable">$NAME</span> &gt; <span class="hljs-variable">$NAME</span><span class="hljs-string">&quot;_&quot;</span><span class="hljs-variable">$TIME</span>.sqlmysqldump -u<span class="hljs-variable">$USER</span> -p<span class="hljs-variable">$PASS</span> -h<span class="hljs-variable">$HOST</span> <span class="hljs-variable">$NAME2</span> &gt; <span class="hljs-variable">$NAME2</span><span class="hljs-string">&quot;_&quot;</span><span class="hljs-variable">$TIME</span>.sql<span class="hljs-comment">#压缩并移动</span><span class="hljs-comment">#tar -zPcvf /root/backup/tar.gz/sql/$NAME&quot;_&quot;$TIME.tar.gz /root/backup/$NAME&quot;_&quot;$TIME.sql</span><span class="hljs-comment">#tar -zPcvf /root/backup/tar.gz/sql/$NAME2&quot;_&quot;$TIME.tar.gz /root/backup/$NAME2&quot;_&quot;$TIME.sql</span><span class="hljs-comment">#删除多余文件</span>rm -rf /root/backup/<span class="hljs-variable">$NAME</span><span class="hljs-string">&quot;_&quot;</span><span class="hljs-variable">$TIME</span>.sql /root/backup/<span class="hljs-variable">$NAME2</span><span class="hljs-string">&quot;_&quot;</span><span class="hljs-variable">$TIME</span>.sqlrm -rf /root/<span class="hljs-variable">$NAME</span><span class="hljs-string">&quot;_&quot;</span><span class="hljs-variable">$TIME</span>.sql /root/<span class="hljs-variable">$NAME2</span><span class="hljs-string">&quot;_&quot;</span><span class="hljs-variable">$TIME</span>.sql<span class="hljs-comment">#删除三天前的数据</span>find /root/backup/tar.gz/sql -mtime +3 -name <span class="hljs-string">&quot;*.*&quot;</span> -<span class="hljs-built_in">exec</span> rm -rf &#123;&#125; \;</code></pre><p>只要将其放到crontab中，并按时间进行执行。就能实现完美的sql备份了。</p><p>再加上以前写过的一些备份其他文件的Shell Script，就能实现最基本的收据备份了。并且七牛的云储存有个在Linux上的下载备份脚本。正好给了我不小的帮助。</p><p>（虽然喜欢写交互式的脚本，但是只要将命令挑出来放crontab就好了）</p><h3 id="写入crontab"><a href="#写入crontab" class="headerlink" title="写入crontab"></a>写入crontab</h3><p>先来简单的介绍下可爱的crontab文件的时间格式吧。</p><p><img src="../images/%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BD%E5%A4%A7%E6%B3%95/4160640759.webp" alt="2.webp/"></p><p>星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。</p><p>逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”</p><p>中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”</p><p>正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。</p><p>然后就是写到Crontab里去了。第一次我也是以为直接找到并编辑crontab这个文件的，后来才发现，原来人家有编辑的命令的：</p><pre><code class="hljs ebnf"><span class="hljs-attribute">crontab -e</span></code></pre><p>然后按照格式讲我们的脚本写进去就好了。</p><pre><code class="hljs awk"><span class="hljs-comment"># m h  dom mon dow   comman</span><span class="hljs-number">0</span> <span class="hljs-number">5</span> * * * <span class="hljs-regexp">/bin/</span>sh <span class="hljs-regexp">/root/</span>backup/c.sh<span class="hljs-number">0</span> <span class="hljs-number">4</span> * * * <span class="hljs-regexp">/bin/</span>sh <span class="hljs-regexp">/root/</span>backup/d.sh</code></pre><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>进过超级简单的操作再配合定时任务，就能实现自动化的各种各样的操作了。对于备份这种操作，手动来做的话迟早会累死，就是不累也会感觉到烦。所以将其运用到定时任务上就是非常的人性化了。主要是方便，不需要任何的人工参与。</p><p>对于数据这方面的，还是经常性的备份比较重要。不光光是不本机的备份，也要经常性的实施多机备份。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QinQ基础操作</title>
    <link href="/defect/basic-knowledge-of-qinq.html"/>
    <url>/defect/basic-knowledge-of-qinq.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>QwQ♥</p></blockquote><h2 id="QinQ简介"><a href="#QinQ简介" class="headerlink" title="QinQ简介"></a>QinQ简介</h2><p>QinQ技术（或称为IEEE 802.1ad、Vlan stacking）。是802.1q协议（Virtual Bridged Local Area Networks）为基础衍生出的一种通讯协议。</p><p>它是一项拓展vlan空间的技术，通过在原有的以太网帧中再堆叠一个802.1q的报头来达到拓展vlan空间的功能。使其vlan数量最多可以达4094(inner)*4094(outer)。即802.1Q-in-802.1Q，所以称之为QinQ协议。</p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>随着当前的以太网技术的发展，利用传统802.1q vlan来对用户进行隔离和标识收到很大限制。因为IEEE802.1Q中定义的VLAN Tag域只有12个比特，仅能表示4096个VLAN，无法满足以太网中标识大量用户的需求，于是QinQ技术应运而生。</p><p>而运用了QinQ协议之后，可以在原有的vlan标签中再堆叠一层vlan标签，使其vlan的数量达到翻倍，极大的拓展了vlan的空间。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>扩展VLAN，对用户进行隔离和标识不再受到限制。</li><li>QinQ内外层标签可以代表不同的信息，如内层标签代表用户，外层标签代表业务，更利于业务的部署。</li><li>QinQ封装、终结的方式很丰富，帮助运营商实现业务精细化运营。</li></ul><ol><li>解决日益紧缺的公网VLAN ID 资源问题</li><li>用户可以规划自己的私网VLNA ID</li><li>提供一种较为简单的二层VPN解决方案</li><li>使用户网络具有较高的独立性</li></ol><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>QinQ拥有两种实现方式：</p><ol><li><p>基本QinQ</p><ol><li>如果收到的是带有VLAN Tag的报文，该报文就成为带双Tag的报文。</li><li>如果收到的是不带VLAN Tag的报文，该报文就成为带有本端口缺省VLAN Tag的报文。</li></ol></li><li><p>灵活QinQ</p><ol><li>为具有不同内层VLAN ID的报文添加不同的外层VLAN Tag。</li><li>根据报文内层VLAN的802.1p优先级标记外层VLAN的802.1p优先级和添加不同的外层VLAN Tag。通过使用灵活QinQ技术，在能够隔离运营商网络和用户网络的同时，又能够提供丰富的业务特性和更加灵活的组网能力。</li></ol></li></ol><ul><li><p>基本QinQ</p><p>基本QinQ是基于接口的封装，是指进入一个接口的所有流量都将全部封装为一个相同的外层Vlan tag。封装方式不够灵活，用户业务区分不够细致。这种封装方式称之为基本QinQ。</p></li><li><p>灵活QinQ</p><ul><li>基于Vlan ID的QinQ封装：这种封装方式可以针对不同的vlan tag来决定是否封装外层vlan tag、封装何种vlan tag。这种封装方式称之为灵活QinQ。</li><li>基于802.1q优先级的QinQ封装：这种封装方式可以针对用户不同优先级的数据流来决定是否封装外层vlan tag、封装何种vlan tag。这种封装方式亦称之为灵活QinQ。</li></ul></li></ul><h2 id="终结子接口"><a href="#终结子接口" class="headerlink" title="终结子接口"></a>终结子接口</h2><p>“终结”意思为设备对传过来的报文tag进行识别，然后根据后续的转发行为来对单层或双层的tag进行玻璃或继续传输。</p><p>“终结”一般作用于子接口上，故称之为：终结子接口</p><p>QinQ技术在和MPLS/IP核心网连接时，根据不同的情况，会用到不同的终结方法：</p><ul><li>如果路由子接口是对报文的单层Tag终结，那么该子接口称为Dot1q终结子接口；</li><li>如果路由子接口是对报文的双层Tag终结，那么该子接口称为QinQ终结子接口。</li></ul><p>Tips：Dot1q终结子接口和QinQ终结子接口不支持透传不带VLAN的报文，收到不带VLAN的报文会直接丢弃。</p><h2 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h2><p>QinQ报文有着固定的格式，就是在802.1Q的标签上再堆叠一层802.1Q标签。QinQ报文比普通的vlan标签多4个字节。vlan帧最小帧长为68字节。</p><p><img src="../images/QinQ%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/ethernet-QinQ-format2.webp" alt="ethernet-QinQ-format2"></p><table><thead><tr><th>字段</th><th>长度</th><th>含义</th></tr></thead><tbody><tr><td>Destination address</td><td>6字节</td><td>目的MAC地址。</td></tr><tr><td>Source address</td><td>6字节</td><td>源MAC地址。</td></tr><tr><td>Type</td><td>2字节</td><td>长度为2字节，表示帧类型。取值为0x8100时表示802.1Q Tag帧。如果不支持802.1Q的设备收到这样的帧，会将其丢弃。对于内层VLAN tag，该值设置为0x8100；对于外层VLAN tag，有下列几种类型0x8100：思科路由器使用0x88A8：Extreme Networks switches使用0x9100：Juniper路由器使用0x9200：Several路由器使用</td></tr><tr><td>PRI</td><td>3比特</td><td>Priority，长度为3比特，表示帧的优先级，取值范围为0～7，值越大优先级越高。用于当交换机阻塞时，优先发送优先级高的数据包。</td></tr><tr><td>CFI</td><td>1比特</td><td>CFI (Canonical Format Indicator)，长度为1比特，表示MAC地址是否是经典格式。CFI为0说明是经典格式，CFI为1表示为非经典格式。用于区分以太网帧、FDDI（Fiber Distributed Digital Interface）帧和令牌环网帧。在以太网中，CFI的值为0。</td></tr><tr><td>VID</td><td>12比特</td><td>LAN ID，长度为12比特，表示该帧所属的VLAN。在VRP中，可配置的VLAN ID取值范围为1～4094。</td></tr><tr><td>Length/Type</td><td>2字节</td><td>指后续数据的字节长度，但不包括CRC检验码。</td></tr><tr><td>Data</td><td>42~1500字节</td><td>负载（可能包含填充位）。</td></tr><tr><td>CRC</td><td>4字节</td><td>用于帧内后续字节差错的循环冗余检验（也称为FCS或帧检验序列）。</td></tr></tbody></table><h3 id="报文示例"><a href="#报文示例" class="headerlink" title="报文示例"></a>报文示例</h3><p><img src="../images/QinQ%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E6%8A%A5%E6%96%87-1582421531943.webp" alt="报文"></p><h3 id="TPID（Tag-Protocol-Identifier）"><a href="#TPID（Tag-Protocol-Identifier）" class="headerlink" title="TPID（Tag Protocol Identifier）"></a>TPID（Tag Protocol Identifier）</h3><p>TPID：标签协议标识ID（Tag Protocol Identifier）是Vlan tag中的一个字段，标识该vlan tag的协议类型。IEEE 802.1Q协议规定QinQ的外层vlan标签的type值为：（0x8100）。</p><p><img src="../images/QinQ%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E5%A4%96%E5%B1%82type.webp" alt="外层type"></p><blockquote><p>IEEE802.1Q协议定义的以太网帧的VLAN Tag。802.1Q Tag位于SA（Source Address）和Length/Type之间。通过检查对应的TPID值，设备可确定收到的帧承载的是运营商VLAN标记还是用户VLAN标记。接收到帧之后，设备将配置的TPID值与帧中TPID字段的值进行比较。如果二者匹配，则该帧承载的是对应的VLAN标记。例如，如果帧承载TPID值为0x8100的VLAN标记，而用户网络VLAN标记的TPID值配置为0x8200，设备将认为该帧没有用户VLAN标记。也就是说，设备认为该帧是Untagged报文。<br>另外，不同运营商的系统可能将QinQ帧外层VLAN标记的TPID设置为不同值。为实现与这些系统的兼容性，可以修改TPID值，使QinQ帧发送到公网时，承载与特定运营商相同的TPID值，从而实现与该运营商设备之间的互操作性。以太网帧的TPID与不带VLAN标记的帧的协议类型字段位置相同。为避免在网络中转发和处理数据包时出现问题，不可将TPID值设置为下表中的任意值：</p></blockquote><table><thead><tr><th align="center">协议类型</th><th align="center">对应值</th></tr></thead><tbody><tr><td align="center">ARP</td><td align="center">0x0806</td></tr><tr><td align="center">RARP</td><td align="center">0x8035</td></tr><tr><td align="center">IP</td><td align="center">0x0800</td></tr><tr><td align="center">IPV6</td><td align="center">0x86DD</td></tr><tr><td align="center">PPPoE</td><td align="center">0x8863/0x8864</td></tr><tr><td align="center">MPLS</td><td align="center">0x8847/0x8848</td></tr><tr><td align="center">IPX/SPX</td><td align="center">0x8137</td></tr><tr><td align="center">LACP</td><td align="center">0x8809</td></tr><tr><td align="center">802.1x</td><td align="center">0x888E</td></tr><tr><td align="center">HGMP</td><td align="center">0x88A7</td></tr><tr><td align="center">设备保留</td><td align="center">0xFFFD/0xFFFE/0xFFFF</td></tr></tbody></table><h2 id="基本QinQ配置"><a href="#基本QinQ配置" class="headerlink" title="基本QinQ配置"></a>基本QinQ配置</h2><p>拓扑：</p><p><img src="../images/QinQ%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E5%9F%BA%E6%9C%ACqinq.webp" alt="基本qinq"></p><p>如图示，SW2和SW3用于模拟运营商之间的Internet，SW1和SW4为客户内网。基本QinQ的配置就作用于SW2和SW3之间，将客户内网内的vlan10与vlan20封装上一层vlan100，用于再SW2和SW3之间传输。</p><ul><li>SW1和SW4配置相同：</li></ul><pre><code class="hljs routeros">sysname SW1<span class="hljs-comment">#</span>vlan batch 10 20<span class="hljs-comment">#</span>interface GigabitEthernet0/0/1<span class="hljs-built_in"> port </span>link-type trunk<span class="hljs-built_in"> port </span>trunk allow-pass<span class="hljs-built_in"> vlan </span>10 20<span class="hljs-comment">#</span>interface GigabitEthernet0/0/2<span class="hljs-built_in"> port </span>link-type access<span class="hljs-built_in"> port default vlan </span>10<span class="hljs-comment">#</span>interface GigabitEthernet0/0/3<span class="hljs-built_in"> port </span>link-type access<span class="hljs-built_in"> port default vlan </span>20</code></pre><p>SW1和SW4只需做基本配置，用作普通二层交换。</p><ul><li>SW2和SW3配置相同：</li></ul><pre><code class="hljs apache"><span class="hljs-attribute">sysname</span> SW<span class="hljs-number">2</span><span class="hljs-comment">#</span><span class="hljs-attribute">vlan</span> batch <span class="hljs-number">100</span><span class="hljs-comment">#</span><span class="hljs-attribute">interface</span> GigabitEthernet<span class="hljs-number">0</span>/<span class="hljs-number">0</span>/<span class="hljs-number">1</span> <span class="hljs-attribute">port</span> link-type dot<span class="hljs-number">1</span>q-tunnel//开启基本二层QinQ功能 <span class="hljs-attribute">port</span> default vlan <span class="hljs-number">100</span>//并划分为vlan<span class="hljs-number">100</span><span class="hljs-comment">#</span><span class="hljs-attribute">interface</span> GigabitEthernet<span class="hljs-number">0</span>/<span class="hljs-number">0</span>/<span class="hljs-number">2</span> <span class="hljs-attribute">port</span> link-type trunk//普通trunk <span class="hljs-attribute">port</span> trunk <span class="hljs-literal">allow</span>-pass vlan <span class="hljs-number">100</span></code></pre><p>SW1的<code>G 0/0/1</code>为trunk接口，对应连接的SW2的<code>G 0/0/1</code>为基本二层QinQ接口，划分vlan为vlan 100。</p><p>使用PC1发送ICMP包到PC3，数据包内容为：</p><p><img src="../images/QinQ%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E6%8A%A5%E6%96%872.webp" alt="报文2"></p><p>其中，可以看到内层的802.1q的vlan标签ID为10，type为（0x0800）；外层的，也就是SW2封装的vlan标签ID为100，type为（0x8100）。</p><h2 id="灵活QinQ配置"><a href="#灵活QinQ配置" class="headerlink" title="灵活QinQ配置"></a>灵活QinQ配置</h2><p>拓扑和上述一样：</p><p><img src="../images/QinQ%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E7%81%B5%E6%B4%BB%E6%8B%93%E6%89%91.webp" alt="灵活拓扑"></p><p>我们在模拟internet的SW2和SW3之间添加了一个vlan 200，用于配置灵活的QinQ的vlan 20堆叠一个vlan 200的tag。</p><p>SW1和SW4的配置与普通的QinQ的配置相同，无需改变。</p><ul><li>SW2与SW3配置相同：</li></ul><pre><code class="hljs apache"><span class="hljs-attribute">sysname</span> SW<span class="hljs-number">2</span><span class="hljs-comment">#</span><span class="hljs-attribute">vlan</span> batch <span class="hljs-number">100</span> <span class="hljs-number">200</span><span class="hljs-comment">#</span><span class="hljs-attribute">interface</span> GigabitEthernet<span class="hljs-number">0</span>/<span class="hljs-number">0</span>/<span class="hljs-number">1</span> <span class="hljs-attribute">port</span> link-type hybrid //必须是hybrid接口模式 <span class="hljs-attribute">qinq</span> vlan-translation enable//开启vlan转换 <span class="hljs-attribute">port</span> hybrid untagged vlan <span class="hljs-number">100</span> <span class="hljs-number">200</span>//出方向时剥离vlan<span class="hljs-number">100</span>和<span class="hljs-number">200</span>的标签 <span class="hljs-attribute">port</span> vlan-stacking vlan <span class="hljs-number">10</span> stack-vlan <span class="hljs-number">100</span>//vlan<span class="hljs-number">10</span>堆叠vlan<span class="hljs-number">100</span>tag <span class="hljs-attribute">port</span> vlan-stacking vlan <span class="hljs-number">20</span> stack-vlan <span class="hljs-number">200</span>////vlan<span class="hljs-number">20</span>堆叠vlan<span class="hljs-number">200</span>tag<span class="hljs-comment">#</span><span class="hljs-attribute">interface</span> GigabitEthernet<span class="hljs-number">0</span>/<span class="hljs-number">0</span>/<span class="hljs-number">2</span> <span class="hljs-attribute">port</span> link-type trunk <span class="hljs-attribute">port</span> trunk <span class="hljs-literal">allow</span>-pass vlan <span class="hljs-number">100</span> <span class="hljs-number">200</span></code></pre><p>从vlan10和vlan20的PC分别向各自的vlan发包，可以看到数据包内容：</p><ul><li>vlan10</li></ul><p><img src="../images/QinQ%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/%E6%8A%A5%E6%96%873.webp" alt="报文3"></p><ul><li>vlan20</li></ul><p><img src="../images/QinQ%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/vlan20.webp" alt="vlan20"><br>当两台PC机正常通信的时候，可以看到不同vlan封装的外层vlan tag也是不一样的。这就是基于vlan的灵活QinQ。</p><h2 id="上述拓扑"><a href="#上述拓扑" class="headerlink" title="上述拓扑"></a>上述拓扑</h2><ul><li><a href="http://cloud.defect.ink/s/s9l4h9rx">灵活QinQ</a></li><li><a href="http://cloud.defect.ink/s/5ttw9ett">接口QinQ</a></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.023wg.com/message/message/cd_feature_eth_qinq.html">QinQ帧格式</a></li><li><a href="https://blog.csdn.net/qq_38265137/article/details/80404320">QinQ基础知识</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决inotify watch不够⌚</title>
    <link href="/defect/fixed-inotify-watch-not-enough.html"/>
    <url>/defect/fixed-inotify-watch-not-enough.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>Failed to add /run/systemd/ask-password to directory watch: No space left on device</p></blockquote><p>这当然不是磁盘空间不足。</p><p>曾经被这问题折腾了很长时间，在磁盘空间充足的情况下，一直提示设备剩余空间不足，导致许多服务无法启动。该问题所在的根源是Inotify watch被占用光了导致的。</p><h2 id="inotify-watch"><a href="#inotify-watch" class="headerlink" title="inotify watch"></a>inotify watch</h2><p>Inotify 到底是什么？</p><p>Inotify 是一种文件变化通知机制，或者称之为监控文件系统，Linux 内核从 2.6.13 开始引入。在 BSD 和 Mac OS 系统中比较有名的是<a href="http://wiki.netbsd.se/kqueue_tutorial">kqueue</a>，它可以高效地实时跟踪 Linux 文件系统的变化。近些年来，以<a href="http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commitdiff;h=90586523eb4b349806887c62ee70685a49415124">fsnotify</a>作为后端，几乎所有的主流 Linux 发行版都支持 Inotify 机制。</p><p>可以简单的理解为，inotify就是监控我们当前系统上的文件变化。在日常工作中，人们往往需要知道在某些文件 (夹) 上都有那些变化，比如：</p><ul><li>通知配置文件的改变</li><li>跟踪某些关键的系统文件的变化</li><li>监控某个分区磁盘的整体使用情况</li><li>系统崩溃时进行自动清理</li><li>自动触发备份进程</li><li>向服务器上传文件结束时发出通知</li></ul><p>检查当前系统内核是否支持inotify机制：</p><pre><code class="hljs gradle"><span class="hljs-keyword">grep</span> INOTIFY_USER <span class="hljs-regexp">/boot/</span>config-$(uname -r)</code></pre><p>如果输出为：<code>CONFIG_INOTIFY_USER=y</code>，那么当前的系统内核便是支持inotify了。</p><h2 id="解决watch不够"><a href="#解决watch不够" class="headerlink" title="解决watch不够"></a>解决watch不够</h2><p>经常打开服务无法启动，提示：</p><pre><code class="hljs livecodeserver">Failed <span class="hljs-built_in">to</span> <span class="hljs-built_in">add</span> /run/systemd/ask-password <span class="hljs-built_in">to</span> <span class="hljs-built_in">directory</span> watch: No <span class="hljs-literal">space</span> left <span class="hljs-keyword">on</span> <span class="hljs-title">device</span></code></pre><p>便是inotify watch不够导致的服务无法启动，很多程序的进程都需要使用inotify watch来监控文件系统。当某些进程使用的太多的时候，就会导致watch不够，导致一些程序直接无法启动。</p><p>遇到这种情况解决办法非常的简单，毕竟不是磁盘的空间不够，我们不需要删除任何的文件，只需要放大足够的watch数量就ok了。</p><p>临时的解决办法：</p><pre><code class="hljs awk">echo <span class="hljs-number">1048576</span> &gt; <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/fs/i</span>notify/max_user_watches</code></pre><p>直接在终端<code>echo</code>一个大量的watch数量到指定的路径，不出意外的话就能够直接解决问题。但这只是个临时的解决办法，再重启机器后将会还原。</p><p>该临时解决办法的好处就是方便快捷，有次我的sshd因为watch数量的不够倒是无法启动时，唯一的解决办法就是连接vnc来解决，然后网页的vnc是不支持粘贴的，所以使用这一行命令也就非常的方便了。</p><p>长期解决方法：</p><pre><code class="hljs awk">vim <span class="hljs-regexp">/etc/</span>sysctl.conf fs.inotify.max_user_watches=<span class="hljs-number">1048576</span></code></pre><p>长期的解决方法也很简单，我们直接在<code>/etc/sysctl.conf </code>文件的末尾添加一句话就可以了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.infoq.cn/article/inotify-linux-file-system-event-monitoring">Inotify: 高效、实时的 Linux 文件系统事件监控框架</a></li><li><a href="https://blog.51cto.com/zhanx/2339983">磁盘空间充足，但是重启服务出现报错：Failed to add /run/systemd/</a></li><li><a href="https://zh.wikipedia.org/wiki/Inotify">inotify</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>踩坑</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开黑之路-Teamspeak Server搭建</title>
    <link href="/defect/teamspeak-server.html"/>
    <url>/defect/teamspeak-server.html</url>
    
    <content type="html"><![CDATA[<blockquote><p> 与小伙伴的开黑之路🤞</p></blockquote><h2 id="Teamspeak？"><a href="#Teamspeak？" class="headerlink" title="Teamspeak？"></a>Teamspeak？</h2><p><img src="../images/Teamspeak-Server/teamspeak.webp" alt="teamspeak"></p><p>Teamspeak是一套专有的VoIP软件。所谓VoIP软件，就是基于网络协议的语音通话。而Teamspeak就是和现在市面上大多数即时通讯软件差不多，可以发送即时消息以及多人语音通话。</p><p>它是以S(erver) -&gt; C(lient)架构基于Internet的运作方式，但是与其他多数软件不同的是，它允许自己搭建服务器。也就是说它的服务端也是可以下载安装的。</p><p>而且Teamspeak是一款多平台的软件，这就意味着，如果我们想，可以让在任何机器上运行成为服务端。它甚至支持离线/局域网的通信。</p><p>除此之外，它对自己的通信频道有着完全自定义的控制。设置官方称可以为整个服务器或只是特定通道启用基于AES的加密。</p><p>我主要喜欢它的地方在于，完全不需要注册账号。可以建立在私人服务器上并有着很完成的控制权限。</p><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>废话了半天，我们了解它是一款可以搭建在自己私人服务器上的一款即时通讯软件。所以接下来就是安装操作了。</p><h3 id="服务器环境"><a href="#服务器环境" class="headerlink" title="服务器环境"></a>服务器环境</h3><p>首先，我用做服务端的环境：</p><ul><li>Server：阿里云ECS</li><li>Bandwidth：1M</li><li>OS：Ubuntu 18.04 bionic</li></ul><pre><code class="hljs d">                         .<span class="hljs-comment">/+o+-       root@Cruiser</span><span class="hljs-comment">                 yyyyy- -yyyyyy+      OS: Ubuntu 18.04 bionic</span><span class="hljs-comment">              :/<span class="hljs-comment">/+//////-yyyyyyo      Kernel: x86_64 Linux 4.15.0-041500-generic</span></span><span class="hljs-comment"><span class="hljs-comment">          .++ .:<span class="hljs-comment">/++++++/</span>-.+sss/`      Uptime: 26d 11h 31m</span></span><span class="hljs-comment"><span class="hljs-comment">        .:++o:  <span class="hljs-comment">/++++++++/</span>:--:/-      Packages: 1031</span></span><span class="hljs-comment"><span class="hljs-comment">       o:+o+:++.`..```.-/oo+++++/</span>     Shell: zsh 5.4.2</span><span class="hljs-comment">      .:+o:+o/.          `+sssoo+/</span>    WM:  .++<span class="hljs-comment">/+:+oo+o:`             /sssooo.   CPU: Intel Xeon E5-2682 v4 @ 2.494GHz</span><span class="hljs-comment"><span class="hljs-comment">/+++/</span><span class="hljs-comment">/+:`oo+o               /::--:.   GPU: cirrusdrmfb</span></span><span class="hljs-comment"><span class="hljs-comment">\+/</span>+o+++`o++o               ++/</span><span class="hljs-comment">///.   RAM: 588MiB / 1993MiB</span> .++.o+++oo+:<span class="hljs-string">`             /dddhhh.  </span><span class="hljs-string">      .+.o+oo:.          `</span>oddhhhh+          \+.++o+o<span class="hljs-string">``</span>-<span class="hljs-string">``</span><span class="hljs-string">``</span>.:ohdhhhhh+            <span class="hljs-string">`:o+++ `</span>ohhhhhhhhyo++os:               .o:<span class="hljs-string">`.syhhhhhhh/.oo++o`</span>                   /osyyyyyyo++ooo+++/                      <span class="hljs-string">``</span><span class="hljs-string">``</span><span class="hljs-string">` +oo+++o\:    </span><span class="hljs-string">                         `</span>oo++.</code></pre><p>（主要是内存有点多的空闲……</p><h3 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h3><p>既然是安装，首先是下载用于作为服务端的软件。据我所知，TS是不开源的。</p><p>→<a href="https://www.teamspeak.com/zh-CN/downloads/">官方下载地址</a></p><p>客户端平台：</p><ul><li>LINUX</li><li>MACOS</li><li>WINDOWS</li><li>ANDROID</li><li>IOS</li></ul><p>听说两个移动端都不怎么样。</p><p>当然，我们主要搭建的是服务端，服务端的平台也不少：</p><ul><li>MACOS</li><li>WINDOWS</li><li>FREEBSD</li><li>LINUX</li></ul><p>这些都是我们常见的服务器操作系统。也就是说搭建服务端对系统没有多大挑剔性了。</p><h3 id="开始动手"><a href="#开始动手" class="headerlink" title="开始动手"></a>开始动手</h3><p>从上述的下载地址中，我们下将服务端的软件下载到我们的服务器上：</p><pre><code class="hljs apache"><span class="hljs-attribute">wget</span> https://files.teamspeak-services.com/releases/server/<span class="hljs-number">3</span>.<span class="hljs-number">6</span>.<span class="hljs-number">1</span>/teamspeak<span class="hljs-number">3</span>-server_linux_amd<span class="hljs-number">64</span>-<span class="hljs-number">3</span>.<span class="hljs-number">6</span>.<span class="hljs-number">1</span>.tar.bz<span class="hljs-number">2</span></code></pre><p>(这条命令的软件版本可能会随着TS的更新而失效)</p><p>由于下载下来的是<code>tar.bz2</code>的压缩格式，所以我们使用<code>-xjvf</code>来进行解压操作：</p><pre><code class="hljs apache"><span class="hljs-attribute">tar</span> -xjvf teamspeak<span class="hljs-number">3</span>-server_linux_amd<span class="hljs-number">64</span>-<span class="hljs-number">3</span>.<span class="hljs-number">6</span>.<span class="hljs-number">1</span>.tar.bz<span class="hljs-number">2</span></code></pre><p>解压之后的文件夹目录：</p><pre><code class="hljs apache"><span class="hljs-attribute">CHANGELOG</span>  libts<span class="hljs-number">3</span>db_mariadb.so  libts<span class="hljs-number">3</span>_ssh.so  LICENSE-THIRDPARTY  serverquerydocs  ts<span class="hljs-number">3</span>server                       ts<span class="hljs-number">3</span>server_startscript.sh<span class="hljs-attribute">doc</span>        libts<span class="hljs-number">3</span>db_sqlite<span class="hljs-number">3</span>.so  LICENSE        redist              sql              ts<span class="hljs-number">3</span>server_minimal_runscript.sh  tsdns</code></pre><p>我们可以了解到它有一堆各种各样的文件，我们不需要去一个个的了解。据说是专有软件，也就是不开源。所以我们也更不需要去编译等操作了。这些文件肯定都是已经编译好的了。</p><p>要运行服务端的软件，首先我们要同意它的许可协议。（如果有人愿意看的话</p><pre><code class="hljs apache"><span class="hljs-attribute">touch</span> .ts<span class="hljs-number">3</span>server_license_accepted</code></pre><p><code>touch</code>这样一个文件在刚刚解压出的目录就意味着我们同意License了。</p><p>同意过后，我们执行它的启动脚本：</p><pre><code class="hljs crmsh">./ts3server_startscript.sh <span class="hljs-literal">start</span></code></pre><p>如果是root用户运行的话，会在启动时提示为了”安全起见，不要使用root用户运行“：</p><pre><code class="hljs routeros"><span class="hljs-builtin-name">WARNING</span> ! <span class="hljs-keyword">For</span> security reasons we advise: <span class="hljs-keyword">DO</span> <span class="hljs-keyword">NOT</span> <span class="hljs-builtin-name">RUN</span> THE<span class="hljs-built_in"> SERVER </span>AS ROOT!!!!!!!!!!!</code></pre><p>当然等最后几个感叹号出现完之后，服务端软件就会正常运行了。就可以继续快乐的当root敢死队了🎉。当然使用什么用户运行取决于你自己。我这边是和自己的小伙伴开黑用的，几乎就是私用，不会将服务器做为公用。所以我并不怕死😈。</p><p>警告⚠我们过后，就是正常启动了</p><pre><code class="hljs asciidoc">Starting the TeamSpeak 3 serverTeamSpeak 3 server started, for details please view the log file<span class="hljs-code">                                                                                                                                                                  </span>------------------------------------------------------------------<span class="hljs-code">                      I M P O R T A N T                           </span>------------------------------------------------------------------<span class="hljs-code">               Server Query Admin Account created                 </span><span class="hljs-code">         loginname= &quot;serveradmin&quot;, password= &quot;dxxxxxxAa&quot;</span>------------------------------------------------------------------<span class="hljs-code"> ○ </span>------------------------------------------------------------------<span class="hljs-code">                      I M P O R T A N T                           </span>------------------------------------------------------------------<span class="hljs-code">      ServerAdmin privilege key created, please use it to gain </span><span class="hljs-code">      serveradmin rights for your virtualserver. please</span><span class="hljs-code">      also check the doc/privilegekey_guide.txt for details.</span><span class="hljs-code">       token=HxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxRL</span>------------------------------------------------------------------</code></pre><p>机会将等会会在客户端用的admin账户以及token显示在我们的终端上了。serveradmin账户和token都是TS的最高权限账户，可修改服务器设置。下文会用到</p><p>进程：</p><pre><code class="hljs angelscript"> ○ ps -aux | grep ts3 root      <span class="hljs-number">4031</span>  <span class="hljs-number">0.4</span>  <span class="hljs-number">1.1</span> <span class="hljs-number">689336</span> <span class="hljs-number">22820</span> pts/<span class="hljs-number">0</span>    Sl   <span class="hljs-number">10</span>:<span class="hljs-number">44</span>   <span class="hljs-number">0</span>:<span class="hljs-number">07</span> ./ts3server</code></pre><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><p>如果我们的服务器有启用防火墙来限制网络的话，ts需要一些TCP/UDP的端口来和客户端进行通信。</p><p>目前的Teamspeak 3需要这些端口：</p><ul><li>UDP: 9987</li><li>TCP: 10011</li><li>TCP: 30033</li></ul><p>可以在<code>iptables</code>中添加：</p><pre><code class="hljs pgsql">iptables -A <span class="hljs-keyword">INPUT</span> -p udp <span class="hljs-comment">--destination-port 9987 -j ACCEPT</span>iptables -A <span class="hljs-keyword">INPUT</span> -p tcp <span class="hljs-comment">--dport  10011 -j ACCEPT</span>iptables -A <span class="hljs-keyword">INPUT</span> -p tcp <span class="hljs-comment">--dport  30033 -j ACCEPT</span></code></pre><p>亦或者使用<code>firewalld</code>：</p><pre><code class="hljs routeros">rewall-cmd <span class="hljs-attribute">--zone</span>=public <span class="hljs-attribute">--add-port</span>=9987/udp --permanentfirewall-cmd <span class="hljs-attribute">--zone</span>=public <span class="hljs-attribute">--add-port</span>=10011/tcp --permanentfirewall-cmd <span class="hljs-attribute">--zone</span>=public <span class="hljs-attribute">--add-port</span>=30033/tcp --permanentfirewall-cmd --reload</code></pre><p>对于一些特殊的发行版可能需要特殊操作，例如我当前的ECS机器，它的防火墙（iptables）的工作方式不是以进程方式运行的。（虽然我也不懂…… </p><p>但是新建防火墙的规则与上述不同，具体可以了解我很早以前<a href="https://www.defectink.com/defect/23.html">水过的一篇文章</a></p><h3 id="开机启动"><a href="#开机启动" class="headerlink" title="开机启动"></a>开机启动</h3><p>当前已经添加过了端口并且已经成功启动了，我们基本上就可以正常连接了。当然还少了一个重要的一步，那就是开机自启了。<br>由于是使用脚本启动了，而没有使用<code>systemd</code>来进行控制，所以服务端需要使用<code>Crontab</code>来进行开机启动的控制</p><pre><code class="hljs awk">@reboot <span class="hljs-regexp">/root/</span>teamspeak<span class="hljs-regexp">/teamspeak3-server_linux_amd64/</span>ts3server_startscript.sh start</code></pre><p>在crontab文件中添加对应的ts脚本启动位置，来实现开机启动ts服务端的效果。<br>添加完成后我们可以使用<code>crontab -l</code>来查看添加完成后的crontab文件，确认是否添加成功。<br>至此，运行于Ubuntu上的Teamspeak服务端就运行成功了。</p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>上述我们介绍过客户端软件支持的平台以及服务端的安装搭建。客户端的<a href="https://www.teamspeak.com/en/downloads/">下载地址</a>于服务端是同一个地址，可以找的适用于自己的平台的安装包来进行下载安装。</p><h3 id="连接服务端"><a href="#连接服务端" class="headerlink" title="连接服务端"></a>连接服务端</h3><p>前面有介绍过TS使用的是C/S架构，我们搭建好了服务端当然是为了连接它。连接它比我们想象的要简单的多，打开软件后直接在工具栏就能找到连接这一选项。<br>单击连接，就可以根据服务器地来连接我们搭建好的服务端了。</p><p><img src="../images/Teamspeak-Server/%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8.webp" alt="连接服务器"></p><p>我们可以看到有三个选项框，第一个是服务器地址，其次是服务器密码，最后是用于展示给其他人的昵称<br>默认新安装的服务端是没有密码的，如果我们是连接一个新服务器的话，是可以将密码留空登陆。<br><strong>这里的昵称只用于展示于其他人，不等于我们的用户名。</strong></p><h3 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h3><p>在上述我们的安装服务端的操作中，第一次启动后会给我们一个serveradmin账户一段token码。ts这个软件不是那么的强调用户。我们登陆至服务器是不需要创建一个拥有密码的账户的。这和我们目前常用的微信、QQ等软件是略有不同的。</p><p>但是ts它也是有用户身份的，因为ts大部分对于服务器的控制操作都是可以在客户端完成的。这时候我们就需要一个有高等级权限的用户身份来完成这个操作。同样需要识别出其他连接进来的用户没有修改服务器的权限。</p><p>如果是第一次连接至ts的新服务器，那么我们连接成功后就会立马弹出一个用于输入token的对话框。我们将刚刚创建服务器时给我们的token填入即可。这样就可以直接在客户端修改自己的服务器了。</p><p><img src="../images/Teamspeak-Server/token.webp" alt="token"></p><p>因为ts默认在使用客户端时会自动创建一个用户身份，每个身份都是不相同的。<strong>那如果我们更换电脑连接自己的服务器时，或者想给其他人一个修改服务器的权限时该怎么办呢？</strong></p><ul><li>导出当前的用户身份</li></ul><p>在工具栏的“工具-身份”这个标签中，我们可以看到自己当前账户身份。直接右击便可以执行导出操作。在其他地方使用相同方法导入就可以继续使用这个身份了。<br><img src="../images/Teamspeak-Server/%E8%BA%AB%E4%BB%BD.webp" alt="身份"></p><ul><li>新建token码</li></ul><p>当我们想给其他身份的用户修改服务器的权限的时候，我们可以使用新建权限码的方式来提升其他用户的权限。<br>在工具栏的“权限-权限码清单”中就可以找的新建权限码的按钮以及已经新建过的权限码清单。新建时也可以选择不同的权限来进一步控制。使用权限码就和我们第一次使用时一样操作即可。<br><img src="../images/Teamspeak-Server/%E6%9D%83%E9%99%90%E7%A0%81.webp" alt="权限码"></p><h3 id="翻译插件"><a href="#翻译插件" class="headerlink" title="翻译插件"></a>翻译插件</h3><p>如何安装软件这里就不再做赘述。ts默认是英文版本的，可以自己在其他地方下载拥有中文汉化的第三方做的包来使用。也可以自己在原版的基础上添加汉化文件。亦或者是自己安装中文翻译的插件（目前中文插件仅有繁体中文）。</p><p>打开软件后，打开“工具-选项”(Alt+P)，找到“插件(add-ons)”这一选项卡。</p><p><img src="../images/Teamspeak-Server/%E6%8F%92%E4%BB%B6.webp" alt="插件"></p><p>默认看到的是当前本地的插件，我们可以选择“Browse online”来查看在线可以下载安装的插件。选择筛选器为”翻译“然后输入”Chinese“就可以找到一款繁体中文的插件。点击进入插件的详情页面就可以看到”install“。单击安装即可。</p><p><img src="../images/Teamspeak-Server/%E7%B9%81%E4%BD%93%E4%B8%AD%E6%96%87.webp" alt="繁体中文"></p><p>Install完成之后重新打开软件就会应用上翻译了。如果没有成功应用，可以再去刚刚插件地方看看有没有启用。<br>除了翻译插件之外，TS还有很多种类的插件，以及界面皮肤等。和刚刚安装翻译插件的方法一摸一样。</p><p><img src="../images/Teamspeak-Server/TS3-1582422801541.webp" alt="TS3"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://forum.teamspeak.com/threads/46486-Teamspeak-3-Server-Ports">Teamspeak 3 Server Ports</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Player</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Player</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Resilio Sync多平台实时同步</title>
    <link href="/defect/multi-platform-real-time-synchronization-by-resilio-sync.html"/>
    <url>/defect/multi-platform-real-time-synchronization-by-resilio-sync.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>备份，同步一步到位。🏹</p></blockquote><h2 id="什么是Resilio-Sync"><a href="#什么是Resilio-Sync" class="headerlink" title="什么是Resilio Sync"></a>什么是Resilio Sync</h2><p><a href="https://www.resilio.com/individuals/">Resilio Sync</a>是一款多平台的文件同步工具，能够实现几乎实时的同步效果。原名BitTorrent Sync，看到的原名就能想到，它的运作原理类似于我们的BitTorrent。</p><p>它是由<a href="https://en.wikipedia.org/wiki/BitTorrent_(company)">BitTorrent</a>开发的一款基于P2P的协议来进行传输文件的。</p><p>它和我以前用过的一款运作于Linux发行版之上的同步软件<a href="https://github.com/axkibe/lsyncd">lsyncd</a>类似，都能达到几乎实时监控指定文件夹变动的一款同步工具。</p><p>相比较二者之间的不同的是，Resilio Sync在Windows平台是拥有GUI的（亦是使用WebUI），但是在其他服务端的操作系统上，类似于各种Linux发行版与Windows Server。它的GUI是以WebUI的方式提供给我们使用的。</p><p>这也是它的优点之一了，在不用反复的修改配置文件的情况下，我们可以使用基于WebUI的一种交互方式来对其进行操作。</p><p>这也是我很喜欢它的地方之一了❤</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>如果我们用作同步工具来使用的话，它还是有很多的优点的：</p><ol><li>可以纯内网工作(P2P)</li><li>多人实时同步，原理是人越多速度越快(BitTorrent)</li><li>存储空间及流量等不受限制</li><li>多平台、多网络环境同步</li><li>Free for home</li><li>WebUI</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>事物都是拥有两面性的，既然它拥有不少优点。那么缺点肯定也不会缺席：</p><ol><li>闭源软件(Free for home)</li><li>公共网络可能会使用中转服务器</li><li>类似BT的原理，机器需要保持在线才能保证传输</li></ol><h3 id="多平台"><a href="#多平台" class="headerlink" title="多平台"></a>多平台</h3><ul><li>Windows</li><li>Mac OS</li><li>Linux</li><li>FreeBSD</li><li>NAS设备</li><li><a href="https://play.google.com/store/apps/details?id=com.resilio.sync&hl=en_US">Android</a></li><li><a href="https://itunes.apple.com/us/app/resilio-sync/id1126282325?mt=8">IOS</a></li></ul><p>两个移动设备上目前还是一款免费软件，不知道功能是什么样的。但是身为一个闭源软件在多平台都有免费使用的方案还是很欣慰的。</p><h2 id="同类"><a href="#同类" class="headerlink" title="同类"></a>同类</h2><p><a href="https://syncthing.net/">Syncthing</a>几乎就是Resilio Sync的另一面了，有人说它就是Resilio Sync的替代品。它不但能够实现相应的实时同步的所有功能，并且还是一款开源的自由软件。</p><p>对于我们来说，一款开源软件不仅仅是不收费这么简单。当一款开源软件由社区进行驱动时，人人都可以完全查看它的源代码以及改进。因此，一款开源软件对我们最大的益处就是真正安全与尊重隐私。</p><p>但闭源软件也有它存在的合理处，如果我们未来需要可靠稳定的支持，与更多的付费服务。Resilio Sync肯定也是一个不错的选择。毕竟顾客即是上帝🍡</p><p>总之各个实时同步的软件之间都是各有各的优缺点，具体想要使用哪一款，完全根据我们自身的需要与心情就OK了。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>上述我们有提到Resilio Sync支持多种平台，这里的我只使用到了Windows与Linux的两个发行版之间。所以其他平台的安装没有相应的记录。</p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>Windows是我们平常接触最多的一款GUI操作系统了，对于安装软件来说，差距都不会太大的。Resilio Sync也是同样。直接前往<a href="https://www.resilio.com/individuals/#hero">官网</a>选择合适的授权下载安装即可。</p><p>安装界面仅仅只需要一步</p><p><img src="../images/Resilio-Sync%E5%A4%9A%E5%B9%B3%E5%8F%B0%E5%AE%9E%E6%97%B6%E5%90%8C%E6%AD%A5/rs%E5%AE%89%E8%A3%85.webp" alt="rs安装"><br>合适的选择后，对于较新的Windows平台可是直接打开一个软件窗口</p><p><img src="../images/Resilio-Sync%E5%A4%9A%E5%B9%B3%E5%8F%B0%E5%AE%9E%E6%97%B6%E5%90%8C%E6%AD%A5/%E5%85%A5%E9%97%A8sync.webp" alt="入门sync"></p><p>接受了几个隐私政策与EULA之后（有空还是要多留意条款之类的），我们就可以正常使用了。</p><p>打开后的简洁的界面</p><p><img src="../images/Resilio-Sync%E5%A4%9A%E5%B9%B3%E5%8F%B0%E5%AE%9E%E6%97%B6%E5%90%8C%E6%AD%A5/%E6%89%93%E5%BC%80.webp" alt="打开"></p><p>配置之类的稍后再说，再将自己的其他平台的机器也给完成安装。</p><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>对于在各个Linux平台的安装，官方有给一个完整的<a href="https://help.resilio.com/hc/en-us/articles/206178924-Installing-Sync-package-on-Linux">帮助文档</a>其中有各个版本的不同数位版的下载链接。以及一些发行版的手动添加源的二进制安装方式。</p><ul><li>下载安装包</li></ul><p>对于网络环境不好的时候，可以考虑使用离线安装包的方式来安装。官方给了两个包，分别是deb和rpm。</p><p>DEB：</p><pre><code class="hljs vim">sudo dpkg -i &lt;resilio-<span class="hljs-keyword">sync</span>.<span class="hljs-keyword">deb</span>&gt;</code></pre><p>RPM</p><pre><code class="hljs xml">sudo rpm -i <span class="hljs-tag">&lt;<span class="hljs-name">resilio-sync.rpm</span>&gt;</span></code></pre><p>由于我的服务器因为网络环境无法与其官方源通信，所以只好选择使用下载离线安装包的方式来进行安装了。</p><p>相比较之下，个人感觉Linux平台的安装甚至比带有GUI的Windows更加方便。对于此软件，至需要一条命令即可。速度也很快。</p><ul><li>使用软件仓库安装</li></ul><p>使用软件仓库安装，我们需要简单的三个步骤：</p><ol><li>添加仓库源</li><li>添加GPG公钥用于验证</li><li>安装✨</li></ol><p>对于Debian-based Linux（Debian, Ubuntu, Mint, Zorin, Elementary）</p><p>创建用于安装的仓库源列表：</p><pre><code class="hljs awk">echo <span class="hljs-string">&quot;deb http://linux-packages.resilio.com/resilio-sync/deb resilio-sync non-free&quot;</span> | sudo tee <span class="hljs-regexp">/etc/</span>apt<span class="hljs-regexp">/sources.list.d/</span>resilio-sync.list</code></pre><p>添加公钥：</p><pre><code class="hljs sas">curl -LO http://linux-packages.resilio.com/resilio-sync/<span class="hljs-meta">key</span>.asc <span class="hljs-variable">&amp;&amp;</span> sudo apt-<span class="hljs-meta">key</span> <span class="hljs-meta">add</span> ./<span class="hljs-meta">key</span>.asc</code></pre><p>更新源与安装：</p><pre><code class="hljs routeros">sudo apt-<span class="hljs-builtin-name">get</span> updatesudo apt-<span class="hljs-builtin-name">get</span> install resilio-sync</code></pre><p>对于RPM-based Linux（Red Hat, Fedora, CentOS）</p><p>创建用于安装的仓库源列表：</p><pre><code class="hljs lsl">printf <span class="hljs-string">&quot;[resilio-sync]<span class="hljs-subst">\n</span>name=Resilio Sync<span class="hljs-subst">\n</span>baseurl=https://linux-packages.resilio.com/resilio-sync/rpm/\$basearch<span class="hljs-subst">\n</span>enabled=1<span class="hljs-subst">\n</span>gpgcheck=1<span class="hljs-subst">\n</span>&quot;</span> | sudo tee /etc/yum.repos.d/resilio-sync.repo</code></pre><p>添加公钥：</p><pre><code class="hljs awk">sudo rpm --import https:<span class="hljs-regexp">//</span>linux-packages.resilio.com<span class="hljs-regexp">/resilio-sync/</span>key.asc</code></pre><p>安装：</p><pre><code class="hljs sql">sudo yum <span class="hljs-keyword">install</span> resilio-<span class="hljs-keyword">sync</span></code></pre><p>更新：</p><pre><code class="hljs smali">sudo yum check-updatesudo yum update resilio-sync</code></pre><h2 id="运行与配置"><a href="#运行与配置" class="headerlink" title="运行与配置"></a>运行与配置</h2><p>Windows上的打开软件不需要任何多嘴了，双击快捷方式打开就好了。</p><p>对于Linux发行版上，几款目前常用的较新的发行版运行软件的方式都是差不多的。</p><p>可以使用Systemd进行控制</p><p>自动运行服务：</p><pre><code class="hljs routeros">sudo systemctl <span class="hljs-builtin-name">enable</span> resilio-sync</code></pre><p>启动与停止：</p><pre><code class="hljs sql">sudo systemctl <span class="hljs-keyword">start</span> resilio-<span class="hljs-keyword">sync</span>sudo systemctl <span class="hljs-keyword">stop</span> resilio-<span class="hljs-keyword">sync</span></code></pre><p>对于在没有GUI的机器的环境下，是可以使用WebUI通过其他机器的浏览器访问来进行控制操作。</p><p>所以我们可以修改其配置文件来进行启动操作。</p><h3 id="默认的配置文件"><a href="#默认的配置文件" class="headerlink" title="默认的配置文件"></a>默认的配置文件</h3><pre><code class="hljs awk"><span class="hljs-regexp">/etc/</span>resilio-sync/config.json</code></pre><p>而对于基本的使用，配置文件也是非常的简单易读的。</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">&quot;storage_path&quot;</span> : <span class="hljs-string">&quot;/var/lib/resilio-sync/&quot;</span>,    <span class="hljs-attr">&quot;pid_file&quot;</span> : <span class="hljs-string">&quot;/var/run/resilio-sync/sync.pid&quot;</span>,    <span class="hljs-attr">&quot;webui&quot;</span> :    &#123;        <span class="hljs-attr">&quot;listen&quot;</span> : <span class="hljs-string">&quot;127.0.0.1:8888&quot;</span>    &#125;&#125;</code></pre><p>对于，官方文档称为了安全选择，软件默认监听<code>127.0.0.1</code>。如果需要在其他机器上直接访问的话，我们需要修改监听地址为：</p><pre><code class="hljs css">&quot;<span class="hljs-selector-tag">listen</span>&quot; : &quot;0<span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-pseudo">:8888&quot;</span></code></pre><p>并且可以根据自己的需求修改监听的端口。</p><p>其中<code>storage_path</code>为软件的一些设置，log等文件的存放目录。也可以根据自身的需要修改。</p><pre><code class="hljs vim">╰─# <span class="hljs-keyword">ls</span> /var/lib/resilio-<span class="hljs-keyword">sync</span>/<span class="hljs-keyword">debug</span>.txt        <span class="hljs-keyword">history</span>.dat      http.port     settings.dat.old  storage.db-wal  <span class="hljs-keyword">sync</span>.dat.old  <span class="hljs-keyword">sync</span>.<span class="hljs-built_in">log</span>FileDelayConfig  <span class="hljs-keyword">history</span>.dat.old  settings.dat  storage.db        <span class="hljs-keyword">sync</span>.dat        <span class="hljs-keyword">sync</span>.lng</code></pre><h3 id="示例配置文件"><a href="#示例配置文件" class="headerlink" title="示例配置文件"></a>示例配置文件</h3><p>上述运行的配置文件那么的简单易懂，同时可自定义的功能也就是更少了。而对于软件的一些其他功能在配置文件中的写法，官方是有留给我们示例的配置文件的。</p><p>我们只需要使用一条命令就可以将示例的配置文件导出到当前目录下：</p><pre><code class="hljs stata">rslsync --dump-<span class="hljs-keyword">sample</span>-config &gt; sync.<span class="hljs-keyword">conf</span></code></pre><p>并且其中注释说明等都是非常完善的：</p><pre><code class="hljs awk">╰─<span class="hljs-comment"># cat sync.conf </span>&#123;   <span class="hljs-string">&quot;device_name&quot;</span>: <span class="hljs-string">&quot;My Sync Device&quot;</span>,<span class="hljs-regexp">//</span> <span class="hljs-string">&quot;listening_port&quot;</span> : <span class="hljs-number">0</span>, <span class="hljs-regexp">//</span> <span class="hljs-number">0</span> - randomize port<span class="hljs-regexp">/* storage_path dir contains auxilliary app files if no storage_path field: .sync dir created in current working directory */</span><span class="hljs-regexp">//</span> <span class="hljs-string">&quot;storage_path&quot;</span> : <span class="hljs-string">&quot;/home/user/.sync&quot;</span>,<span class="hljs-regexp">/* set location of pid file */</span><span class="hljs-regexp">//</span> <span class="hljs-string">&quot;pid_file&quot;</span> : <span class="hljs-string">&quot;/var/run/resilio/resilio.pid&quot;</span>,<span class="hljs-regexp">/* use UPnP for port mapping */</span>  <span class="hljs-string">&quot;use_upnp&quot;</span> : true,<span class="hljs-regexp">/* 这里只截取部分配置 */</span></code></pre><p>当我们修改的差不多的使用，我们就可以使用上述命令启动了。启动后，可以在进程中看到默认读取的配置文件的路径：</p><pre><code class="hljs angelscript">╰─# ps -aux | grep rslsync                  rslsync   <span class="hljs-number">88730</span>  <span class="hljs-number">0.5</span>  <span class="hljs-number">1.5</span> <span class="hljs-number">772560</span> <span class="hljs-number">15316</span> ?        Ssl  <span class="hljs-number">01</span>:<span class="hljs-number">12</span>   <span class="hljs-number">0</span>:<span class="hljs-number">05</span> /usr/bin/rslsync --config /etc/resilio-sync/config.json</code></pre><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><p>同样是为了安全原因，软件默认是使用最小权限的<strong>rslsync</strong>的用户来运行的。这样就会导致一个问题，在<strong>rslsync</strong>这个用户没有权限的目录就无法打开，就会导致无法使用该目录了。</p><p>最简便的解决办法就是将需要的文件夹给予用户<strong>rslsync</strong>可使用的权限，我们可以将<strong>rslsync</strong>添加到当前的用户组，并保证需要同步的文件夹用于上述组的权限：</p><pre><code class="hljs properties"><span class="hljs-attr">sudo</span> <span class="hljs-string">usermod -aG user_group rslsync</span><span class="hljs-attr">sudo</span> <span class="hljs-string">chmod g+rw synced_folder</span></code></pre><p>亦或者直接修改rslsync用户为当前使用的用户来运行程序，编辑文件**/usr/lib/systemd/user/resilio-sync.service**将文件中的：</p><pre><code class="hljs ini"><span class="hljs-attr">WantedBy</span> = multi-user.target</code></pre><p>修改为：</p><pre><code class="hljs aspectj">WantedBy = <span class="hljs-keyword">default</span>.<span class="hljs-keyword">target</span></code></pre><p>随后需要reload systemd并重启程序：</p><pre><code class="hljs crmsh">systemctl daemon-reloadsystemctl --<span class="hljs-keyword">user</span> <span class="hljs-title">start</span> resilio-sync</code></pre><p>此处的<code>--user</code>与普通启动可以分别守护两个进程，默认的分别为：</p><pre><code class="hljs apache"><span class="hljs-attribute">rslsync</span>  <span class="hljs-number">27519</span>  <span class="hljs-number">0</span>.<span class="hljs-number">4</span>  <span class="hljs-number">0</span>.<span class="hljs-number">8</span> <span class="hljs-number">670144</span> <span class="hljs-number">16928</span> ?        Ssl  <span class="hljs-number">15</span>:<span class="hljs-number">36</span>   <span class="hljs-number">0</span>:<span class="hljs-number">01</span> /usr/bin/rslsync --config /etc/resilio-sync/config.json<span class="hljs-attribute">root</span>     <span class="hljs-number">29385</span>  <span class="hljs-number">0</span>.<span class="hljs-number">3</span>  <span class="hljs-number">0</span>.<span class="hljs-number">4</span> <span class="hljs-number">589864</span>  <span class="hljs-number">9676</span> ?        Ssl  <span class="hljs-number">15</span>:<span class="hljs-number">43</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00</span> /usr/bin/rslsync --config /root/.config/resilio-sync/config.json</code></pre><p>且<code>--user</code>的用户成功被更改为当前用户root。当然配置文件也是独立的。    </p><h3 id="除此之外"><a href="#除此之外" class="headerlink" title="除此之外"></a>除此之外</h3><p>软件还可以直接在终端中使用<code>rslsync</code>命令来进行运行等其他控制。上述的打印示例配置文件就是一个例子。关于该方式的更多可以在官方的帮助文档<a href="https://help.resilio.com/hc/en-us/articles/204762449-Guide-to-Linux">Guide To Linux, And Sync Peculiarities</a>中找到。</p><p>成后运行后的界面与Windows完全一样。毕竟二者是同一种方式展示的UI界面。</p><p><img src="../images/Resilio-Sync%E5%A4%9A%E5%B9%B3%E5%8F%B0%E5%AE%9E%E6%97%B6%E5%90%8C%E6%AD%A5/home_centos.webp" alt="home_centos"></p><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>安装均已经完成，接下来就是简单从操作来实现需要的同步效果了。</p><p>在保证权限都是正常的情况下，添加在A机器添加我们需要进行同步的文件夹。选择好了之后就是三种分享链接的方式。</p><p><img src="../images/Resilio-Sync%E5%A4%9A%E5%B9%B3%E5%8F%B0%E5%AE%9E%E6%97%B6%E5%90%8C%E6%AD%A5/%E5%BC%80%E5%A7%8B%E5%90%8C%E6%AD%A5.webp" alt="开始同步"></p><p>分别是“链接”、“密钥”和二维码三种方式。</p><p>随后我们就可以使用三种方式的其中一种，例如使用我最喜欢的密钥，选择好读写权限后，在需要同步的B机器上输入复制过来的密钥。</p><p><img src="../images/Resilio-Sync%E5%A4%9A%E5%B9%B3%E5%8F%B0%E5%AE%9E%E6%97%B6%E5%90%8C%E6%AD%A5/%E8%BE%93%E5%85%A5%E5%AF%86%E9%92%A5.webp" alt="输入密钥"></p><p>然后等着他们自己开始同步就OK了。在多平台的环境下也是不会影响正常工作的。</p><p>除此之外，对于同步的文件夹还有一些其他的选项可以配置。具体就看自己的需要来配置了🌭</p><p><img src="../images/Resilio-Sync%E5%A4%9A%E5%B9%B3%E5%8F%B0%E5%AE%9E%E6%97%B6%E5%90%8C%E6%AD%A5/%E5%85%B6%E4%BB%96%E9%80%89%E9%A1%B9.webp" alt="其他选项"></p><h2 id="参考-amp-推荐阅读"><a href="#参考-amp-推荐阅读" class="headerlink" title="参考&amp;推荐阅读"></a>参考&amp;推荐阅读</h2><ul><li><a href="https://help.resilio.com/hc/en-us/articles/206178924-Installing-Sync-package-on-Linux">Installing Sync Package On Linux</a></li><li><a href="https://www.resilio.com/legal/eula/">Legal</a></li><li><a href="https://en.wikipedia.org/wiki/BitTorrent_(company)">BitTorrent (company)</a></li><li><a href="https://en.wikipedia.org/wiki/Resilio_Sync">Resilio Sync</a></li><li><a href="https://play.google.com/store/apps/details?id=com.resilio.sync&hl=en_US">Resilio Sync Android</a></li><li><a href="https://itunes.apple.com/us/app/resilio-sync/id1126282325?mt=8">Resilio Sync IOS</a></li><li><a href="https://help.resilio.com/hc/en-us">Resilio Sync Help Center</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Minecraft bedrock服务端🥂</title>
    <link href="/defect/minecraft-bedrock-server.html"/>
    <url>/defect/minecraft-bedrock-server.html</url>
    
    <content type="html"><![CDATA[<h2 id="Minecraft"><a href="#Minecraft" class="headerlink" title="Minecraft"></a>Minecraft</h2><p><strong>MINECRAFT 是什么？</strong></p><blockquote><p><strong>这是一个有关放置方块与探险的游戏。</strong><br>游戏设定在一片可以无限生成的世界里，这里有广袤而开阔的土地——由冰雪覆盖的山峰、潮湿的河口、辽阔的牧场等等组成——它们充满着奥秘、奇迹与危险。</p></blockquote><p>这个游戏应该是多数玩家都已不陌生，开发商为Mojang AB（Mojäng Aktiebolag），是瑞典的一家电子游戏开发商。他家也发行过其他的小游戏，但是名声都不怎么样。最后Minecraft一炮走红。2014年9月，财大气粗的软软以25亿美元收购Mojang以及游戏的知识产权。</p><p>最早的时候我们在PC上接触的应该都是开发商的Java版本，Java版本的好处就是它有各种各样的Mod，以及材质包等。对于玩家来说使用也非常的方便。虽然性能不是那么的卓越，但是现在依然是很受玩家的欢迎了。</p><p>在被微软收购以后，微软结合自家的Win10应用商店也出了一个Bedrock版本，与其不同的是，这次使用C语言写出来的。在自家的应用商店内，玩家们安装也变的更加的方便了。除此之外，性能方面肯定是要比Java好的多的。</p><h2 id="Bedrock-Server"><a href="#Bedrock-Server" class="headerlink" title="Bedrock Server"></a>Bedrock Server</h2><p>相比较以前的Java版本自建服务器来说，Bedrock版本的Server要比以前方便简单的多。虽然目前还处于Bate版本，但是支持的功能也比较完善了。</p><p>主要是简单的多，对于以前的Java，服务端搭建起来非常的麻烦，得力于Java，还非常吃服务器的资源。目前已经编译好的C语言来说，不仅省了很多事，还降低了对服务器的要求。当然，唯一一个缺点就是跨平台肯定没有Java方便了。</p><h2 id="搭建服务端"><a href="#搭建服务端" class="headerlink" title="搭建服务端"></a>搭建服务端</h2><p>服务端我们可以免费的在<a href="https://www.minecraft.net/en-us/download/server/bedrock/">官方网站</a>下载，目前只支持Windows与Ubuntu版本。在Windows上运行推荐使用Windows10/Windows Server 2016及以后的版本。</p><p><img src="../images/Minecraft-bedrock%E6%9C%8D%E5%8A%A1%E7%AB%AF/4100402335.png" alt="2019-05-13T05:16:24.png"></p><p>Windows版本与Ubuntu版本的文件几乎差不多，下载后直接解压，我们就能够看到一个可执行的<code>bedrock_server.exe</code>文件。当没有任何需求时，直接执行它就可以启动并正常使用服务端了。</p><p>启动后我们可以看到一个类似这样的命令提示符的界面：</p><p><img src="../images/Minecraft-bedrock%E6%9C%8D%E5%8A%A1%E7%AB%AF/3200057918.png" alt="2019-05-15T13:18:43.png"></p><p>此时的服务器端就已经启动完成了，若能直接访问服务器，就可以直接开始游戏了🥓。</p><p><em>需要使用在Windows商店下载的Minecarft作为客户端</em></p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>当然，默认的配置文件往往大多数时间都是不能满足我们的需求的。还有很多种情况需要我们根据自己的想法去自定义。例如修改个监听的端口。</p><p>目前的Bedrock服务端也有个较为完善的配置文件，可读性也非常的高。官方下载的包里不仅有个“How to”，并且配置文件内都有着很详细的注释，例如修改游戏模式：</p><pre><code class="hljs gams">gamemode=survival# <span class="hljs-keyword">Sets</span> the <span class="hljs-comment">game mode for new players.</span># Allowed <span class="hljs-comment">values:</span> <span class="hljs-comment">&quot;survival&quot;</span><span class="hljs-comment">,</span> <span class="hljs-comment">&quot;creative&quot;</span><span class="hljs-comment">, or</span> <span class="hljs-comment">&quot;adventure&quot;</span></code></pre><p>配置文件的修改入门很低，只要能打开几乎针对服务器的一些选项都可以自定义。除此之外，我们还可以在服务器允许中的命令行/shell内直接使用一些命令，例如提出某个在线的玩家：</p><pre><code class="hljs xml">kick <span class="hljs-tag">&lt;<span class="hljs-name">player</span> <span class="hljs-attr">name</span> <span class="hljs-attr">or</span> <span class="hljs-attr">xuid</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">reason</span>&gt;</span></code></pre><p>或者是关闭服务器：</p><pre><code class="hljs arduino"><span class="hljs-built_in">stop</span></code></pre><p><em>当然你喜欢的话也可以直接终止这个进程，当然不推荐这么做。</em></p><p>压缩包内的“bedrock_server_how_to.html”写的非常的详细，功能也非常的全。对于一些日常的使用，或者是入门的话，可以多参考参考该文件。</p><p>为了方便，我还放了个在线版本的<a href="https://www.defectink.com/defect/bedrock_server_how_to.html">📢bedrock_server_how_to</a>。是当前最新的1.11.2.1版本的，后续可能不会持续更新。当前写的非常的详细了。</p><h3 id="权限级别"><a href="#权限级别" class="headerlink" title="权限级别"></a>权限级别</h3><p>配置文件可以修改大多数服务端的配置，主要是针对游戏服务器的修改。像是对于游戏内的具体修改并没有写在配置文件内，例如对玩家的修改以及修改世界的选项。这些操作选项需要我们手动赋予一个玩家“操作员”的权限，这样，该玩家就会有对目前游戏的整个世界的完整操作权限。</p><p><img src="../images/Minecraft-bedrock%E6%9C%8D%E5%8A%A1%E7%AB%AF/2032314932.png" alt="2019-05-15T15:27:50.png"></p><p>在游戏的目录下有个名为<code>permissions.json</code>的json文件，在默认情况下它是空的，我们可以根据帮助文件提供的格式直接赋予某个玩家权限：</p><pre><code class="hljs json">[    &#123;        <span class="hljs-attr">&quot;permission&quot;</span>: <span class="hljs-string">&quot;operator&quot;</span>,        <span class="hljs-attr">&quot;xuid&quot;</span>: <span class="hljs-string">&quot;451298348&quot;</span>    &#125;]</code></pre><p><em>需要注意的是，我们需要对应的玩家的<code>xuid</code>值，这在玩家连接时会显示在终端上。</em></p><p>一次赋予多个玩家的格式：</p><pre><code class="hljs json">[    &#123;        <span class="hljs-attr">&quot;permission&quot;</span>: <span class="hljs-string">&quot;operator&quot;</span>,        <span class="hljs-attr">&quot;xuid&quot;</span>: <span class="hljs-string">&quot;451298348&quot;</span>    &#125;,    &#123;        <span class="hljs-attr">&quot;permission&quot;</span>: <span class="hljs-string">&quot;member&quot;</span>,        <span class="hljs-attr">&quot;xuid&quot;</span>: <span class="hljs-string">&quot;52819329&quot;</span>    &#125;,    &#123;        <span class="hljs-attr">&quot;permission&quot;</span>: <span class="hljs-string">&quot;visitor&quot;</span>,        <span class="hljs-attr">&quot;xuid&quot;</span>: <span class="hljs-string">&quot;234114123&quot;</span>    &#125;]</code></pre><p>当玩家被赋予<code>operator</code>的权限时，重启服务端，再次进入游戏时该玩家就拥有了对世界的完整控制。</p><p><em>某些世界生成后就不能修改的选项除外</em></p><h2 id="备份世界"><a href="#备份世界" class="headerlink" title="备份世界"></a>备份世界</h2><p>最简单也是最直接的备份方式就是直接备份当前服务端的整个文件夹，如果这个操作太过于麻烦的话，或者说文件夹已经达到了臃肿的地步了。我们可以使用预留的备份命令，可以生成<code>.db</code>的文件用于copy。文档的详细解释：</p><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td>save hold</td><td>This will ask the server to prepare for a backup. It’s asynchronous and will return immediately.</td></tr><tr><td>save query</td><td>After calling <code>save hold</code> you should call this command repeatedly to see if the preparation has finished. When it returns a success it will return a file list (with lengths for each file) of the files you need to copy. The server will not pause while this is happening, so some files can be modified while the backup is taking place. As long as you only copy the files in the given file list and truncate the copied files to the specified lengths, then the backup should be valid.</td></tr><tr><td>save resume</td><td>When you’re finished with copying the files you should call this to tell the server that it’s okay to remove old files again.</td></tr></tbody></table><p>我们可以直接使用<code>save hold</code>来生成备份文件，然后再使用<code>save query</code>来查询文件的位置。<em>注意：当我们的世界名称使用中文时，可能会出现在终端中文乱码的情况</em>，例如：</p><p><img src="../images/Minecraft-bedrock%E6%9C%8D%E5%8A%A1%E7%AB%AF/1339714059.png" alt="2019-05-15T15:50:09.png"></p><p>此时最佳解决办法就是换个世界名称。但是直接在配置文件中更换名称后，会导致重新创建一个新的世界。为了避免这个现象，达到给旧世界更换名称的操作。我们需要同时修改三个地方的名称，并保持一致：</p><ul><li><code>server.properties</code>文件内的名称</li><li><code>world</code>文件夹内的世界文件夹名称</li><li>世界文件夹内的<code>levelname.txt</code>内的文字</li></ul><p>当这三处名称统一修改时，再重新启动服务器就会达到修改世界名称的效果了。</p><p>目前推荐的最佳的备份方法就是直接备份<code>world</code>文件夹的所有内容，在服务器运行时对文件夹进行复制操作不会影响服务器的正常运行。</p><h2 id="网易代理"><a href="#网易代理" class="headerlink" title="网易代理"></a>网易代理</h2><p>网易代理的Minecraft对游戏的本质来说或许没有太多的不同，对于收费模式也是符合目前国内的游戏较为普遍的免费进入游戏，后续再根据自己的选择购买一些增值服务。也就是非买断制。但是网易拥有租赁服务器的服务，可能是想方便提供给玩家们一个更加方便的购买与启用服务器的渠道，但是他直接禁止使用其他的第三方服务器。对于某些玩家来说可能不是个好的选择。</p><p>虽然微软在Xbox上也有这类似的操作，但是Windows商店的Minecraft也不是天价，对于不想玩个mc就把身份证给网易的小伙伴们，Windows商店可能是个更好的选择。</p>]]></content>
    
    
    <categories>
      
      <category>实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Minecraft</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使typecho支持emoji🎈</title>
    <link href="/defect/make-typecho-support-the-emoji.html"/>
    <url>/defect/make-typecho-support-the-emoji.html</url>
    
    <content type="html"><![CDATA[<h2 id="Emoji？"><a href="#Emoji？" class="headerlink" title="Emoji？"></a>Emoji？</h2><p>emoji是我们身边常见的且神奇的表情符号，它被称为绘文字（えもじ <em>emoji</em>）。最初是日本在无线通信中所使用的视觉情感符号。与我们常发的表情包不同的是，它并不是图片。</p><p>Emoji的编码是Unicode字符集中的一部分，特定形象的Emoji表情符号对应到特定的Unicode字节。也就是说emoji是unicode编码。好处是无论在什么地方使用都不像是图片那么难处理，以及可以直接写在数据库内。</p><p><img src="../images/%E4%BD%BFtypecho%E6%94%AF%E6%8C%81emoji/2721696195.webp" alt="emoji_unicode.webp"></p><h3 id="词语发音"><a href="#词语发音" class="headerlink" title="词语发音"></a>词语发音</h3><p>絵文字/えもじ（emoji）的发音是 /emoꜜdʑi/（此处为国际音标）。 <a href="../images/%E4%BD%BFtypecho%E6%94%AF%E6%8C%81emoji/1431864746.webp">2</a> </p><ul><li>/e/：即汉语拼音 y<strong>e</strong>中<strong>ê</strong>的发音，英语单词 b<strong>e</strong>d 中<strong>e</strong>的发音。</li><li>/dʑ/：与汉语拼音 j 对应的浊音。与潮州话拼音方案的 r 相似，如潮州话“字”（ri⁷）字的声母。 <a href="../images/%E4%BD%BFtypecho%E6%94%AF%E6%8C%81emoji/175217384.webp">3</a> </li><li>/mo/ 为重读音节。</li></ul><p>在英语中，emoji 常被读作 /ɪˈmoʊdʒi/。 </p><h2 id="在typecho中使用emoji"><a href="#在typecho中使用emoji" class="headerlink" title="在typecho中使用emoji"></a>在typecho中使用emoji</h2><p>现在多数的软件、网站等都已经广泛的支持emoji表情了。自己也是非常的喜欢这类表情，特别喜欢微软家的，那种扁平的风格真的很招人喜爱。</p><p><img src="../images/%E4%BD%BFtypecho%E6%94%AF%E6%8C%81emoji/1431864746.webp" alt="1557663679707.webp"></p><p>但是最近使用typecho的时候遇到点小问题，发现新安装的typecho居然不支持使用emoji。在文章等页面使用了emoji之后，保存会提示数据库查询错误。</p><p>这是因为数据库默认使用的是<code>utf8</code>编码，在<code>utf8</code>的编码中最多只支持3个字节，而我们可爱的emoji是4个字节，如上述所说的，emoji并非图片，是直接存储在数据库内的。所以就出现了数据库查询错误导致无法使用emoji的问题。</p><h3 id="修改数据库"><a href="#修改数据库" class="headerlink" title="修改数据库"></a>修改数据库</h3><p>解决办法也非常的简单，我们直接使用phpMyAdmin或者sql，修改数据库<code>charset</code>为<code>utf8mb4</code>就ok了</p><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> typecho_comments <span class="hljs-keyword">convert</span> <span class="hljs-keyword">to</span> <span class="hljs-built_in">character</span> <span class="hljs-keyword">set</span> utf8mb4 <span class="hljs-keyword">collate</span> utf8mb4_unicode_ci;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> typecho_contents <span class="hljs-keyword">convert</span> <span class="hljs-keyword">to</span> <span class="hljs-built_in">character</span> <span class="hljs-keyword">set</span> utf8mb4 <span class="hljs-keyword">collate</span> utf8mb4_unicode_ci;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> typecho_fields <span class="hljs-keyword">convert</span> <span class="hljs-keyword">to</span> <span class="hljs-built_in">character</span> <span class="hljs-keyword">set</span> utf8mb4 <span class="hljs-keyword">collate</span> utf8mb4_unicode_ci;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> typecho_metas <span class="hljs-keyword">convert</span> <span class="hljs-keyword">to</span> <span class="hljs-built_in">character</span> <span class="hljs-keyword">set</span> utf8mb4 <span class="hljs-keyword">collate</span> utf8mb4_unicode_ci;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> typecho_options <span class="hljs-keyword">convert</span> <span class="hljs-keyword">to</span> <span class="hljs-built_in">character</span> <span class="hljs-keyword">set</span> utf8mb4 <span class="hljs-keyword">collate</span> utf8mb4_unicode_ci;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> typecho_relationships <span class="hljs-keyword">convert</span> <span class="hljs-keyword">to</span> <span class="hljs-built_in">character</span> <span class="hljs-keyword">set</span> utf8mb4 <span class="hljs-keyword">collate</span> utf8mb4_unicode_ci;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> typecho_users <span class="hljs-keyword">convert</span> <span class="hljs-keyword">to</span> <span class="hljs-built_in">character</span> <span class="hljs-keyword">set</span> utf8mb4 <span class="hljs-keyword">collate</span> utf8mb4_unicode_ci;</code></pre><p>如果有没有涉及的表，按照同样的语句修改就可以了。</p><p>修改后就可以看到表的‘排序规则’(charset)为可以使用emoji的<code>utf8mb4</code>了。</p><p><img src="../images/%E4%BD%BFtypecho%E6%94%AF%E6%8C%81emoji/175217384.webp" alt="2019-05-12T12:27:33.webp"></p><h3 id="修改typecho配置文件"><a href="#修改typecho配置文件" class="headerlink" title="修改typecho配置文件"></a>修改typecho配置文件</h3><p>当数据库修改完成之后，到typecho的目录下找到其配置文件<code>config.inc.php</code>。并且修改为刚刚设置编码就ok了</p><pre><code class="hljs php">$db-&gt;addServer(<span class="hljs-keyword">array</span> (    <span class="hljs-string">&#x27;host&#x27;</span>      =&gt;  localhost,    <span class="hljs-string">&#x27;user&#x27;</span>      =&gt;  <span class="hljs-string">&#x27;root&#x27;</span>,    <span class="hljs-string">&#x27;password&#x27;</span>  =&gt;  <span class="hljs-string">&#x27;my_password&#x27;</span>,    <span class="hljs-string">&#x27;charset&#x27;</span>   =&gt;  <span class="hljs-string">&#x27;utf8mb4&#x27;</span>, <span class="hljs-comment">//修改这一行</span>    <span class="hljs-string">&#x27;port&#x27;</span>      =&gt;  <span class="hljs-number">3306</span>,    <span class="hljs-string">&#x27;database&#x27;</span>  =&gt;  <span class="hljs-string">&#x27;喵喵喵&#x27;</span>)</code></pre><p>全部修改完成后就能正常的在typecho中使用emoji了</p><p><img src="../images/%E4%BD%BFtypecho%E6%94%AF%E6%8C%81emoji/4188132525.webp" alt="2019-05-12T12:31:18.webp"></p>]]></content>
    
    
    <categories>
      
      <category>实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>typecho</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>想起来当年还折腾过hexo</title>
    <link href="/defect/hexo-again.html"/>
    <url>/defect/hexo-again.html</url>
    
    <content type="html"><![CDATA[<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p>曾经的水文：</p><p><a href="/defect/hexo.html">Hexo</a>✔<br><a href="/defect/hexo-and-github.html">Hexo and Github</a>✔</p><p>谁还不喜欢水呢（小声</p><p>hexo估计了解的人有很多了，在业界也是很知名的一款blog框架。说到blog程序，可能很多人都听说过知名的wordpress、typecho等。</p><p>那么hexo相对于他们的优势有什么呢？</p><ul><li>全静态化站点</li><li>可部署于GitHub</li><li>一键部署</li><li>同样有丰富的插件</li><li>原生支持Markdown</li></ul><p>曾经的曾经，那时的我刚开始研究hexo，还不够了解它的工作机制。谁让我以前比较笨。</p><p>以前我以为它是和部署普通的blog程序一样的，只是不需要用到数据库而已。于是我直接将其装在了自己的VPS上，虽然它也支持使用hexo-server来启用网页服务，直接部署在当前机器上。但是在我那个卡的要死的机器上使用ssh+vim来写markdown肯定不好受。</p><p>就算是在本地写完再上传也是比较麻烦的，尤其是后来研究了hexo与GitHub共同工作之后。发现它完全就可以部署在本地计算机上。写起来也更加的方便。<br>这就是这篇文章的作用了。</p><h2 id="部署于Windows"><a href="#部署于Windows" class="headerlink" title="部署于Windows"></a>部署于Windows</h2><p>所需：</p><ul><li><a href="https://gitforwindows.org/">Gitbash</a>（git for windows）</li><li><a href="https://nodejs.org/en/">Node.js</a></li><li>Github仓库</li></ul><blockquote><p>Windows 用户<br>对于windows用户来说，建议使用安装程序进行安装。安装时，请勾选Add to PATH选项。<br>另外，您也可以使用Git Bash，这是git for windows自带的一组程序，提供了Linux风格的shell，在该环境下，您可以直接用上面提到的命令来安装Node.js。打开它的方法很简单，在任意位置单击右键，选择“Git Bash Here”即可。由于Hexo的很多操作都涉及到命令行，您可以考虑始终使用Git Bash来进行操作。</p></blockquote><p>Gitbash与Node.js均有在Windows下的独立安装程序，就和安装其他软件一般，非常简单。不再赘述。当然也可以使用gitbash来安装node.js，都是同样的简单。</p><p>当git与node.js全部安装完成后，我们就可以使用一条命令直接安装hexo了。</p><pre><code class="hljs npm">$ npm install -g hexo-cli</code></pre><h2 id="建站🏘"><a href="#建站🏘" class="headerlink" title="建站🏘"></a>建站🏘</h2><p>当hexo以及其他所需要的环境都安装在我们的Windows上后，就可以开始配合GitHub来搭建一个托放在GitHub上的静态化blog了。</p><pre><code class="hljs bash">$ hexo init &lt;folder&gt;$ <span class="hljs-built_in">cd</span> &lt;folder&gt;$ npm install</code></pre><p>仅需三条命令，就可以部署一个文件夹为我们的站点跟目录了。当然这个文件夹需要是空的，必须要是新建的一个全空的文件夹，才能正常执行 hexo init 。<br>正常安装完成后，可以在目录下看到如下的文件树了。</p><pre><code class="hljs bash">.├── _config.yml├── package.json├── scaffolds├── <span class="hljs-built_in">source</span>|   ├── _drafts|   └── _posts└── themes</code></pre><p>日后我们新建的文章都会存放在source/_posts中，以便于hexo的渲染。</p><h3 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h3><p>该配置文件用于修改一些站点的配置。可以修改大多数站点的参数。例如：站点标题，时区等。</p><pre><code class="hljs avrasm"><span class="hljs-meta"># Site</span><span class="hljs-symbol">title:</span> Defectink<span class="hljs-symbol">subtitle:</span> Another Defectink?<span class="hljs-symbol">description:</span> Just Blog<span class="hljs-symbol">keywords:</span><span class="hljs-symbol">author:</span> DefectingCat</code></pre><p>更多：<a href="https://hexo.io/zh-cn/docs/configuration">配置</a></p><h3 id="部署至GitHub🛰"><a href="#部署至GitHub🛰" class="headerlink" title="部署至GitHub🛰"></a>部署至GitHub🛰</h3><p>部署至GitHub是非常简单且方便的一个操作了。相对于自己建设于VPS上的站点来说，优势于：</p><ul><li>免费</li><li>利用多个分支实现备份</li><li>版本控制</li></ul><p>安装用于部署至GitHub的工具 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a></p><pre><code class="hljs bash">$ npm install hexo-deployer-git --save</code></pre><p>修改_config.yml中的deploy配置。</p><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><span class="hljs-symbol">  type:</span> git<span class="hljs-symbol">  repo:</span> <span class="hljs-params">&lt;repository url&gt;</span> <span class="hljs-meta">#https:<span class="hljs-comment">//bitbucket.org/JohnSmith/johnsmith.bitbucket.io</span></span><span class="hljs-symbol">  branch:</span> [branch] <span class="hljs-meta">#published</span><span class="hljs-symbol">  message:</span> [message]</code></pre><p>如果要利用多个分支实现，一个分支用于存放hexo的文件，一个分支用于部署hexo生成的网页。那么就需要修改branch中的分支了。hexo会根据配置文件中的分支来创建并提交到分支中。</p><blockquote><p>这一切是如何发生的？<br>当初次新建一个库的时候，库将自动包含一个master分支。请在这个分支下进行写作和各种配置来完善您的网页。当执行hexo deploy时，Hexo会创建或更新另外一个用于部署的分支，这个分支就是_config.yml配置文件中指定的分支。Hexo会将生成的站点文件推送至该分支下，并且完全覆盖该分支下的已有内容。因此，部署分支应当不同于写作分支。（一个推荐的方式是把master作为写作分支，另外使用public分支作为部署分支。）值得注意的是，hexo deploy并不会对本地或远程的写作分支进行任何操作，因此依旧需要手动推送写作分支的所有改动以实现版本控制。此外，如果您的Github Pages需要使用CNAME文件自定义域名，请将CNAME文件置于写作分支的source_dir目录下，只有这样hexo deploy才能将CNAME文件一并推送至部署分支。</p></blockquote><p>首先需要满足：</p><ul><li>仓库名（用户名.github.io）✔</li><li>用于存放网页的必须是master分支✔</li></ul><p>如果不满足呢？当然也可以。</p><p>但是当你使用其他仓库名来创建网页（GitHub Pages），也可以使用“用户名.github.io”这个域名。但是会在域名后面添加一个仓库名。例如：“defectingcat.github.io/test”。 就好像是子目录一样。且不知道为什么分支只能使用gh-pages。</p><p>当所有条件都准备好了，配置文件也准备好了。那么现在就可以部署了。</p><pre><code class="hljs bash">hexo clean &amp;&amp; hexo deploy</code></pre><p>前者清除站点文件，后者重新生成站点文件并将之推送到指定的库分支。<br>每次都需要这么长的命令吗？不，通过markdown写完文章后。直接使用</p><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g -d</span></code></pre><p>来部署至GitHub。</p><blockquote><p>INFO Deploy done: git</p></blockquote><p>看到这条消息，就说明我们已经向GitHub部署成功了。<br>此时访问GitHub的域名就可以打开刚刚部署好的hexo了。</p><h3 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h3><p>部署至GitHub最大的好处就在于这里了，那就是恢复。刚刚上述有说过，我们利用两个分支，将生成的静态站点放在master分支，再额外创建一个分支用于存放hexo的核心文件。并使用git同步。</p><p>这样，当我们的本地的hexo的核心文件遭受损坏，或者误删的时候，我们就可以使用git。很轻松的获取一份曾经的备份。<br>例：</p><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/DefectingCat/</span>DefectingCat.github.io<span class="hljs-regexp">/tree/</span>file</code></pre><p>另外，hexo默认是没有后台的面板的。毕竟是纯静态化的站点。貌似使用某些插件可以实现拥有后台面板。没有后台就意味着我们不在自己的电脑环境下更新自己的hexo文章就比较麻烦了。或者说更换电脑、操作系统等。我们的环境都会被更改。</p><p>此时，亦可以使用git恢复备份的文件。并再通过上述几个简单的步骤安装hexo。值得注意的是，使用以前的命令若安装不成功，可以试试：</p><pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> hexo <span class="hljs-comment">--save</span></code></pre><h2 id="主题⛺"><a href="#主题⛺" class="headerlink" title="主题⛺"></a>主题⛺</h2><p>无论是什么程序，那可能离不开主题。hexo也有很多很棒的主题，其中大部分都是开源主题。用起来也是很方便。<br>大红大紫的NexT应该是很多人都有了解了。找了半天也没有找到啥合适心意的主题。就决定试试这款主题了。<br>主题官方网站也有很完善的安装文档?<a href="http://theme-next.iissnan.com/getting-started.html">使用文档</a></p><h3 id="安装与启用"><a href="#安装与启用" class="headerlink" title="安装与启用"></a>安装与启用</h3><p>开源主题，直接clone。</p><pre><code class="hljs awk">$ cd your-hexo-site$ git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/iissnan/</span>hexo-theme-<span class="hljs-keyword">next</span> themes/<span class="hljs-keyword">next</span></code></pre><p>亦或者使用其他方法：</p><pre><code class="hljs awk">curl -s https:<span class="hljs-regexp">//</span>api.github.com<span class="hljs-regexp">/repos/ii</span>ssnan<span class="hljs-regexp">/hexo-theme-next/</span>releases<span class="hljs-regexp">/latest | grep tarball_url | cut -d &#x27;&quot;&#x27; -f 4 | wget -i - -O- | tar -zx -C themes/</span><span class="hljs-keyword">next</span> --strip-components=<span class="hljs-number">1</span></code></pre><p>ok，无论是什么方法下载下来。都会在同一个文件夹<code>themes/next</code>文件夹下。若不在，还是要主动移动到指定的文件较内。</p><p>安装完成后，可以通过修改配置文件来进行启用了。hexo很多的操作都是通过修改配置文件来实现的。虽然时修改配置文件，但是配置文件都是很人性化的，修改起来也非常的简单。并且NexT这款主题也有很完善的配置文档。</p><blockquote><p>在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。</p></blockquote><p>与其他所有hexo主题一样，启用方法都是：在站点配置文件中找到<code>theme</code>字段，如下修改：</p><pre><code class="hljs autoit">theme: <span class="hljs-keyword">next</span></code></pre><p><strong>完成只后推荐使用hexo clean来清除下缓存</strong></p><h3 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h3><blockquote><p>菜单配置包括三个部分，第一是菜单项（名称和链接），第二是菜单项的显示文本，第三是菜单项对应的图标。 NexT 使用的是 Font Awesome 提供的图标， Font Awesome 提供了 600+ 的图标，可以满足绝大的多数的场景，同时无须担心在 Retina 屏幕下 图标模糊的问题。</p></blockquote><p>也就相当于我们常见的独立页面了。<br>编辑主题配置文件，修改如下：</p><p>设定菜单内容，对应的字段是 menu。 菜单内容的设置格式是：item name: link。其中 item name 是一个名称，这个名称并不直接显示在页面上，她将用于匹配图标以及翻译。</p><pre><code class="hljs dts"><span class="hljs-symbol">menu:</span><span class="hljs-symbol">  home:</span> / || home<span class="hljs-symbol">  about:</span> <span class="hljs-meta-keyword">/about/</span> || user<span class="hljs-symbol">  tags:</span> <span class="hljs-meta-keyword">/tags/</span> || tags<span class="hljs-symbol">  categories:</span> <span class="hljs-meta-keyword">/categories/</span> || th<span class="hljs-symbol">  archives:</span> <span class="hljs-meta-keyword">/archives/</span> || archive  <span class="hljs-meta">#schedule: /schedule/ || calendar</span><span class="hljs-symbol">  sitemap:</span> /sitemap.xml || sitemap<span class="hljs-symbol">  commonweal:</span> /<span class="hljs-number">404</span>/ || heartbeat</code></pre><p>这里与官方配置文档写的不同的是，随着新版的更新，配置文件也更加的方便了。上述提到的 Font Awesome图标就是在menu配置后直接写的。例如：</p><pre><code class="hljs arduino"><span class="hljs-built_in">home</span>: / || <span class="hljs-built_in">home</span></code></pre><p>这个<code>|| home</code>就是Font Awesome的图标名啦。<br>而启用这个图标也非常的简单，就在上述配置的下方就有一个开关。</p><pre><code class="hljs yaml"><span class="hljs-comment"># Enable/Disable menu icons.</span><span class="hljs-attr">menu_icons:</span>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span></code></pre><p><strong>除了主页与归档，其他页面都需要手动创建</strong></p><h4 id="创建独立页面"><a href="#创建独立页面" class="headerlink" title="创建独立页面"></a>创建独立页面</h4><p>开启菜单的话，就需要创建一些独立页面来使用了。创建独立页面使用的就是hexo所说的“模板”了。官方文档<a href="https://hexo.io/zh-cn/docs/templates">模板</a></p><p>创建一个独立页面和创建一个新的文章的方式是一样的简单，但是使用到对应的模板创建成功后才能算是一个独立页面。</p><pre><code class="hljs routeros">hexo new<span class="hljs-built_in"> page </span>about</code></pre><p>使用这样的命令与创建文章的页面有什么不同呢？它也是生产一个新的<code>index.html</code>。但它会在<code>source</code>文件下创建对应的文件夹。例如：</p><pre><code class="hljs gradle">$  ls <span class="hljs-keyword">source</span>/_posts<span class="hljs-regexp">/ about/</span></code></pre><p>创建about页面后就会有个about文件夹。其他页面同理。</p><h3 id="菜单页面"><a href="#菜单页面" class="headerlink" title="菜单页面"></a>菜单页面</h3><p>上述我们启用了主题的菜单选项，但是菜单对应的都是一个独立页面。也就是类似于about所建立的独立页面。创建方法一样。不同的是根据主题的配置。</p><p>所有的菜单的页面配置都类似，在新建好的独立页面中配置类型“type”。例如tags：</p><pre><code class="hljs yaml"><span class="hljs-attr">title:</span> <span class="hljs-string">标签</span><span class="hljs-attr">date:</span> <span class="hljs-number">2014-12-22 12:39:04</span><span class="hljs-attr">type:</span> <span class="hljs-string">&quot;tags&quot;</span><span class="hljs-meta">---</span></code></pre><p>或者是categories:</p><pre><code class="hljs yaml"><span class="hljs-attr">title:</span> <span class="hljs-string">分类</span><span class="hljs-attr">date:</span> <span class="hljs-number">2014-12-22 12:39:04</span><span class="hljs-attr">type:</span> <span class="hljs-string">&quot;categories&quot;</span><span class="hljs-meta">---</span></code></pre><p>配和上述开启所需要的菜单后，我们就能在菜单栏中打开并访问对应的页面了。虽然是修改配置文件，但是也是非常的简单呢。?</p><p>若要禁止使用评论功能：</p><pre><code class="hljs yaml"><span class="hljs-attr">comments:</span> <span class="hljs-literal">false</span></code></pre><h2 id="CNAME"><a href="#CNAME" class="headerlink" title="CNAME"></a>CNAME</h2><p>虽然GitHub送给我们了一个二级域名，但那个二级域名是需要配置自己的GitHub用户名使用的，往往我们的用户名可能就很长。本来就是二级域名了，再加上很长的域名，可能有时候自己都懒得输。</p><p>所以最佳、最方便的解决办法就是添加一个自己域名的cname解析到GitHub白送我们的域名上。<br>除了解析，hexo也要做相应的配置。也是非常的简单呢。</p><p>在网页的根目录下的<code>source/</code>文件下新建一个名为<code>CNAME</code>的空文件，在文件内写入我们cname过来的域名。</p><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">cat</span> source/CNAMEdefect.ink</code></pre><p><strong>只需要写上域名就可以了，不需要戴上http等。</strong></p><h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><p>记录的虽然不是太多，也可能不是那么详细。但是还是大致的顺着搭建成功这么一个放向来的的。<br>所以就留下一个截图的纪念吧?</p><p><img src="https://cdn.defectink.com/2019/01/%E9%A1%B5%E9%9D%A2%E9%A2%84%E8%A7%88.webp-shuiyin" alt="截图纪念"></p><p><del>图丢了</del></p>]]></content>
    
    
    <categories>
      
      <category>实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo and Github</title>
    <link href="/defect/hexo-and-github.html"/>
    <url>/defect/hexo-and-github.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>这是一篇写于较早期的文章，当时水平有限，文章质量不高。</p></blockquote><p>上次搭建hexo的时候是直接在服务器上使用hexo -server仍在服务器发布的。这次决定配合github，将hexo生成的静态页面部署至github，不仅有了github.io的域名，还能在github上做备份、版本控制等。</p><p>关于hexo安装的，可以去参考上一篇文章 →</p><p>安装完成后就是将hexo与github关联起来了</p><h2 id="创建Repositories"><a href="#创建Repositories" class="headerlink" title="创建Repositories"></a>创建Repositories</h2><p>为了将网页部署到github并发布，需要先创建一个仓库</p><p>在个人资料页面选择仓库（Repositories），并单击New来创建一个新的仓库：</p><p><img src="../images/Hexo-and-Github/profile.webp" alt="profile"></p><p><img src="../images/Hexo-and-Github/repository.webp" alt="repository"></p><p>• Repository name：仓库名称（需要使用格式为”Your_github_name.github.io”。Your_github_name一定要为你的github昵称，否则出现404状况）<br>• Description：仓库描述（选填）<br>• Public/Private：仓库类型（公开/私有）<br>• Initialize this repository with a README：是否生成一个README文件初始化仓库（可选）</p><p>所有选项都填写完成后，点击Create Repository来创建仓库</p><p>随后便能看到自己刚刚创建的仓库了（下图为未创建一个README文件来初始化仓库）</p><p><img src="../images/Hexo-and-Github/create.webp" alt="create"></p><h2 id="关联Github"><a href="#关联Github" class="headerlink" title="关联Github"></a>关联Github</h2><p>创建好仓库后，需要配置Github信息，以便于等会部署。</p><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;name&quot;</span>git config --global user.email <span class="hljs-string">&quot;mail&quot;</span></code></pre><h3 id="生成SSH密钥"><a href="#生成SSH密钥" class="headerlink" title="生成SSH密钥"></a>生成SSH密钥</h3><pre><code class="hljs bash">ssh-keygen -t rsa</code></pre><p>在生成时可以全部保持默认路径即可。</p><p>生成完毕后可以看到公钥的默认路径为：</p><pre><code class="hljs bash">/root/.ssh/id_rsa.pub</code></pre><p>直接编辑并将所有内容复制至Github</p><pre><code class="hljs bash">vim .ssh/id_rsa.pub</code></pre><h3 id="部署至Github"><a href="#部署至Github" class="headerlink" title="部署至Github"></a>部署至Github</h3><p>直接修改_config.yml文件，并找到Deployment，修改为如下内容</p><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span>   <span class="hljs-attr">type:</span> <span class="hljs-string">git</span>   <span class="hljs-attr">repo :</span> <span class="hljs-string">git@github.com:DefectingCat/DefectingCat.github.io.git</span>   <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span></code></pre><p>repo：仓库的路径</p><p>branch：分支（默认为master）</p><pre><code class="hljs bash">hexo ghexo dhexo d -g</code></pre><p>部署前生成静态页面</p><p>Deployer not found：git？</p><p>尝试如下命令：</p><pre><code class="hljs bash">npm install hexo-deployer-git --save</code></pre><p>成功部署</p><p>查看刚刚所部署的仓库</p><p><img src="../images/Hexo-and-Github/ggg.webp" alt="ggg"></p><p>访问域名测试</p><p><img src="../images/Hexo-and-Github/web.webp" alt="web"></p><p>到此就成功部署到Github并运行成功了呢。</p><h2 id="Over"><a href="#Over" class="headerlink" title="Over"></a>Over</h2><p>这个只是最基本的部署发布页面，hexo还有很多高级操作。官方文档写的也非常详细，更多操作可以去参考官方文档 <a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></p>]]></content>
    
    
    <categories>
      
      <category>实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo</title>
    <link href="/defect/hexo.html"/>
    <url>/defect/hexo.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>这是一篇写于较早期的文章，当时水平有限，文章质量不高。</p></blockquote><p>好久不见</p><h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo?"></a>Hexo?</h2><p>Hexo是一款博客页面框架。特点是简洁、高效。使用markdown语法渲染文章。</p><p>其大概原理将本地markdown编写的.md文件经过多次渲染为html等静态页面文件。再由hexo服务发布。</p><p>可参考：</p><ul><li><a href="https://www.zhihu.com/question/51588481">https://www.zhihu.com/question/51588481</a></li><li><a href="http://coderunthings.com/2017/08/20/howhexoworks/">http://coderunthings.com/2017/08/20/howhexoworks/</a></li><li>中文官网： <a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Ubuntu</p><p>hexo的安装过程简便，工作原理与其他blog程序都大不相同。</p><p>安装前提</p><p>安装 Hexo 相当简单。然而在安装前，必须检查电脑中是否已安装下列应用程序：</p><p>• Node.js<br>• Git</p><p>官方文档中提到安装所需要的上述应用程序，在ubuntu环境下Git在默认情况下为已经安装的。</p><p>若无git，可使用如下命令进行安装</p><pre><code class="hljs bash">apt install git</code></pre><p>首先安装npm与node.js</p><pre><code class="hljs bash">apt install npm nodejs-legacynpm install -g hexo-cli</code></pre><p>界面可能会如下</p><p>等待npm install -g hexo-cli命令完成后，hexo就已经安装在系统中了</p><p>接下来就是使用hexo建立站点了，可参考官方文档： <a href="https://hexo.io/zh-cn/docs/setup.html">https://hexo.io/zh-cn/docs/setup.html</a></p><pre><code class="hljs bash">$ hexo init &lt;folder&gt;$ <span class="hljs-built_in">cd</span> &lt;folder&gt;$ npm install</code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><pre><code class="hljs bash">hexo init web</code></pre><p><img src="../images/hexo/init.webp" alt="init"></p><p>过程略长，稍等即可</p><p>init文件夹完成后，进入并安装</p><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> web &amp;&amp; npm install</code></pre><p>完成后文件目录为如下。</p><p>新建完成后，指定文件夹的目录如下：</p><pre><code class="hljs sqf">.├── <span class="hljs-variable">_config</span>.yml├── package.json├── scaffolds├── source|   ├── <span class="hljs-variable">_drafts</span>|   └── <span class="hljs-variable">_posts</span>└── themes</code></pre><ul><li>_config.yml：站点的配置文件</li><li>package.json：应用程序信息</li><li>scaffolds：模版文件夹</li><li>source：用户资源存放文件夹</li><li>themes：主题文件夹</li></ul><p>关于_config.yml的详细配置说明可参考官方文档： <a href="https://hexo.io/zh-cn/docs/configuration.html">https://hexo.io/zh-cn/docs/configuration.html</a></p><h2 id="服务端hexo-server"><a href="#服务端hexo-server" class="headerlink" title="服务端hexo-server"></a>服务端hexo-server</h2><p>Hexo 3.0 把服务器独立成了个别模块，需要安装才能够使用。</p><pre><code class="hljs bsah">npm install hexo-server --save</code></pre><p>安装完毕后，启动服务。（_config.yml需要先配置好）</p><pre><code class="hljs bash">hexo server -p 80 -s</code></pre><p>正常情况下便可以直接进行访问，为如下页面。</p><p><img src="../images/hexo/web.webp" alt="web"></p><p>Cannot GET /  ？</p><p>如出现运行服务端后访问提示为”Cannot GET / “，请尝试：</p><p>• 确保在init的目录下运行过npm install<br>• 添加了-s 参数，需要运行”hexo generate”命令生成静态文件。</p><p>无法打开？</p><p>• Hexo server默认端口号为4000，可用-p参数进行修改<br>• 需要在_config.yml配置文件中配置域名。</p><p>• 也可以使用-i命令修改监听的ip地址。默认为0.0.0.0<br>• 需要在所init的目录下运行server命令</p><p>Hexo server会占用整个shell，对于ssh连接来说，断开后便会中断服务。</p><p>我们可以使用screen命令搭配运行hexo server</p><pre><code class="hljs angelscript">screen hexo s -p <span class="hljs-number">80</span> -s</code></pre><p>运行后按下<code>Ctrl+a+d</code>将当前窗口放置后台运行</p><p>查看<code>screen -ls</code></p><p>重新连接会话<code>screen -r 25211</code></p><h2 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h2><p>可以执行下列命令来创建一篇新文章。</p><pre><code class="hljs bash">$ hexo new [layout] &lt;title&gt;</code></pre><p>可以直接使用命令来创建文章，默认文件名为title</p><pre><code class="hljs bash">hexo new TEST</code></pre><p>可以看到创建的文章会被创建为source目录下的.md文件，可以直接使用markdown语法写作修改。</p><blockquote><p>若是静态运行，每次修改文章后需要使用hexo generate命令渲染。</p></blockquote><p>更多方式可以了解官方说明： <a href="https://hexo.io/zh-cn/docs/writing.html">https://hexo.io/zh-cn/docs/writing.html</a></p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>Hexo是一款不同与其他的博客框架，其简洁、高效和多样性的用法也是吸引人的一大特点。无需数据库，所有文章都在统一文件夹内，真正纯静态化的站点。新颖、特殊的工作方式让人眼前一亮。由于与众不同的特点，hexo与markdown的方式还得日后慢慢学习使用。</p><p>此文完全参照与官方说明文档。</p>]]></content>
    
    
    <categories>
      
      <category>实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/defect/hello-world.html"/>
    <url>/defect/hello-world.html</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
